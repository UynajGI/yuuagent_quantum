[
  {
    "category": "examples",
    "name": "example.z_exact_diag",
    "content": "# Example Source: z_exact_diag.py\n\"\"\"A simple example comparing DMRG output with full diagonalization (ED).\n\nSorry that this is not well documented! ED is meant to be used for debugging only ;)\n\"\"\"\n# Copyright (C) TeNPy Developers, Apache license\n\nimport tenpy.linalg.np_conserved as npc\nfrom tenpy.algorithms import dmrg\nfrom tenpy.algorithms.exact_diag import ExactDiag\nfrom tenpy.models.xxz_chain import XXZChain\nfrom tenpy.networks.mps import MPS\n\n\ndef example_exact_diagonalization(L, Jz):\n    xxz_pars = dict(L=L, Jxx=1.0, Jz=Jz, hz=0.0, bc_MPS='finite', sort_charge=True)\n    M = XXZChain(xxz_pars)\n\n    product_state = ['up', 'down'] * (xxz_pars['L'] // 2)  # this selects a charge sector!\n    psi_DMRG = MPS.from_product_state(M.lat.mps_sites(), product_state, unit_cell_width=M.lat.mps_unit_cell_width)\n    charge_sector = psi_DMRG.get_total_charge(True)  # ED charge sector should match\n\n    ED = ExactDiag(M, charge_sector=charge_sector, max_size=2.0e6)\n    ED.build_full_H_from_mpo()\n    # ED.build_full_H_from_bonds()  # whatever you prefer\n    print('start diagonalization')\n    ED.full_diagonalization()  # the expensive part for large L\n    E0_ED, psi_ED = ED.groundstate()  # return the ground state\n    print('psi_ED =', psi_ED)\n\n    print('run DMRG')\n    dmrg.run(psi_DMRG, M, {'verbose': 0})  # modifies psi_DMRG in place!\n    # first way to compare ED with DMRG: convert MPS to ED vector\n    psi_DMRG_full = ED.mps_to_full(psi_DMRG)\n    print('psi_DMRG_full =', psi_DMRG_full)\n    ov = npc.inner(psi_ED, psi_DMRG_full, axes='range', do_conj=True)\n    print('<psi_ED|psi_DMRG_full> =', ov)\n    assert abs(abs(ov) - 1.0) < 1.0e-13\n\n    # second way: convert ED vector to MPS\n    psi_ED_mps = ED.full_to_mps(psi_ED)\n    ov2 = psi_ED_mps.overlap(psi_DMRG)\n    print('<psi_ED_mps|psi_DMRG> =', ov2)\n    assert abs(abs(ov2) - 1.0) < 1.0e-13\n    assert abs(ov - ov2) < 1.0e-13\n    # -> advantage: expectation_value etc. of MPS are available!\n    print('<Sz> =', psi_ED_mps.expectation_value('Sz'))\n\n\nif __name__ == '__main__':\n    example_exact_diagonalization(10, 1.0)",
    "search_text": "example.z_exact_diag # example source: z_exact_diag.py\n\"\"\"a simple example comparing dmrg output with full diagonalization (ed).\n\nsorry that this is not well documented! ed is meant to be used for debugging only ;)\n\"\"\"\n# copyright (c) tenpy developers, apache license\n\nimport tenpy.linalg.np_conserved as npc\nfrom tenpy.algorithms import dmrg\nfrom tenpy.algorithms.exact_diag import exactdiag\nfrom tenpy.models.xxz_chain import xxzchain\nfrom tenpy.networks.mps import mps\n\n\ndef example_exact_diagonalization(l, jz):\n    xxz_pars = dict(l=l, jxx=1.0, jz=jz, hz=0.0, bc_mps='finite', sort_charge=true)\n    m = xxzchain(xxz_pars)\n\n    product_state = ['up', 'down'] * (xxz_pars['l'] // 2)  # this selects a charge sector!\n    psi_dmrg = mps.from_product_state(m.lat.mps_sites(), product_state, unit_cell_width=m.lat.mps_unit_cell_width)\n    charge_sector = psi_dmrg.get_total_charge(true)  # ed charge sector should match\n\n    ed = exactdiag(m, charge_sector=charge_sector, max_size=2.0e6)\n    ed.build_full_h_from_mpo()\n    # ed.build_full_h_from_bonds()  # whatever you prefer\n    print('start diagonalization')\n    ed.full_diagonalization()  # the expensive part for large l\n    e0_ed, psi_ed = ed.groundstate()  # return the ground state\n    print('psi_ed =', psi_ed)\n\n    print('run dmrg')\n    dmrg.run(psi_dmrg, m, {'verbose': 0})  # modifies psi_dmrg in place!\n    # first way to compare ed with dmrg: convert mps to ed vector\n    psi_dmrg_full = ed.mps_to_full(psi_dmrg)\n    print('psi_dmrg_full =', psi_dmrg_full)\n    ov = npc.inner(psi_ed, psi_dmrg_full, axes='range', do_conj=true)\n    print('<psi_ed|psi_dmrg_full> =', ov)\n    assert abs(abs(ov) - 1.0) < 1.0e-13\n\n    # second way: convert ed vector to mps\n    psi_ed_mps = ed.full_to_mps(psi_ed)\n    ov2 = psi_ed_mps.overlap(psi_dmrg)\n    print('<psi_ed_mps|psi_dmrg> =', ov2)\n    assert abs(abs(ov2) - 1.0) < 1.0e-13\n    assert abs(ov - ov2) < 1.0e-13\n    # -> advantage: expectation_value etc. of mps are available!\n    print('<sz> =', psi_ed_mps.expectation_value('sz'))\n\n\nif __name__ == '__main__':\n    example_exact_diagonalization(10, 1.0) example z exact diag",
    "tokens": 659
  },
  {
    "category": "examples",
    "name": "example.e_tdvp",
    "content": "# Example Source: e_tdvp.py\n\"\"\"Example illustrating the use of TDVP in tenpy.\n\nAs of now, we have TDVP only for finite systems. The call structure is quite similar to TEBD. A\ndifference is that we can run one-site TDVP or two-site TDVP. In the former, the bond dimension can\nnot grow; the latter allows to grow the bond dimension and hence requires a truncation.\n\"\"\"\n\n# Copyright (C) TeNPy Developers, Apache license\nimport numpy as np\n\nimport tenpy\nfrom tenpy.algorithms import tdvp\nfrom tenpy.networks.mps import MPS\n\n\ndef example_TDVP():\n    L = 14\n    chi = 20  # exemplary strong truncation!\n    delta_t = 0.1\n    model_params = {\n        'L': L,\n        'S': 0.5,\n        'conserve': 'Sz',\n        'Jz': 1.0,\n        'Jy': 1.0,\n        'Jx': 1.0,\n        'hx': 0.0,\n        'hy': 0.0,\n        'hz': 0.0,\n        'muJ': 0.0,\n        'bc_MPS': 'finite',\n    }\n\n    heisenberg = tenpy.models.spins.SpinChain(model_params)\n    product_state = ['up', 'down'] * (L // 2)\n    # starting from a Neel product state which is not an eigenstate of the Heisenberg model\n    psi = MPS.from_product_state(\n        heisenberg.lat.mps_sites(),\n        product_state,\n        bc=heisenberg.lat.bc_MPS,\n        form='B',\n        unit_cell_width=heisenberg.lat.mps_unit_cell_width,\n    )\n\n    tdvp_params = {\n        'start_time': 0,\n        'dt': delta_t,\n        'N_steps': 1,\n        'trunc_params': {'chi_max': chi, 'svd_min': 1.0e-10, 'trunc_cut': None},\n    }\n    tdvp_engine = tdvp.TwoSiteTDVPEngine(psi, heisenberg, tdvp_params)\n    times = []\n    S_mid = []\n    Es = []\n\n    def measure():\n        times.append(tdvp_engine.evolved_time)\n        S_mid.append(psi.entanglement_entropy(bonds=[L // 2])[0])\n        Es.append(heisenberg.H_MPO.expectation_value(psi))\n\n    measure()\n    for i in range(30):\n        tdvp_engine.run()\n        measure()\n\n    tdvp_engine = tdvp.SingleSiteTDVPEngine.switch_engine(tdvp_engine)\n    for i in range(30):\n        tdvp_engine.run()\n        measure()\n\n    return times, S_mid, Es\n\n\ndef plot_example_TDVP(times, S_mid, Es):\n\n    axes[0].plot(times, S_mid)\n    axes[0].set_ylabel('entroy $S$ at center bond')\n    axes[1].plot(times, np.array(Es) - Es[0])\n    axes[1].set_ylabel('energy $E - E(t=0)$')\n    axes[1].set_xlabel('time $t$')\n    for ax in axes:\n        ax.axvline(x=3.01, color='red')\n    axes[0].text(2.9, 0.0000015, 'Two-site update', ha='right')\n    axes[0].text(3.1, 0.0000015, 'One-site update, strict TDVP')\n\n\nif __name__ == '__main__':\n    import logging\n\n    logging.basicConfig(level=logging.INFO)\n    measure = example_TDVP()\n    plot_example_TDVP(*measure)",
    "search_text": "example.e_tdvp # example source: e_tdvp.py\n\"\"\"example illustrating the use of tdvp in tenpy.\n\nas of now, we have tdvp only for finite systems. the call structure is quite similar to tebd. a\ndifference is that we can run one-site tdvp or two-site tdvp. in the former, the bond dimension can\nnot grow; the latter allows to grow the bond dimension and hence requires a truncation.\n\"\"\"\n\n# copyright (c) tenpy developers, apache license\nimport numpy as np\n\nimport tenpy\nfrom tenpy.algorithms import tdvp\nfrom tenpy.networks.mps import mps\n\n\ndef example_tdvp():\n    l = 14\n    chi = 20  # exemplary strong truncation!\n    delta_t = 0.1\n    model_params = {\n        'l': l,\n        's': 0.5,\n        'conserve': 'sz',\n        'jz': 1.0,\n        'jy': 1.0,\n        'jx': 1.0,\n        'hx': 0.0,\n        'hy': 0.0,\n        'hz': 0.0,\n        'muj': 0.0,\n        'bc_mps': 'finite',\n    }\n\n    heisenberg = tenpy.models.spins.spinchain(model_params)\n    product_state = ['up', 'down'] * (l // 2)\n    # starting from a neel product state which is not an eigenstate of the heisenberg model\n    psi = mps.from_product_state(\n        heisenberg.lat.mps_sites(),\n        product_state,\n        bc=heisenberg.lat.bc_mps,\n        form='b',\n        unit_cell_width=heisenberg.lat.mps_unit_cell_width,\n    )\n\n    tdvp_params = {\n        'start_time': 0,\n        'dt': delta_t,\n        'n_steps': 1,\n        'trunc_params': {'chi_max': chi, 'svd_min': 1.0e-10, 'trunc_cut': none},\n    }\n    tdvp_engine = tdvp.twositetdvpengine(psi, heisenberg, tdvp_params)\n    times = []\n    s_mid = []\n    es = []\n\n    def measure():\n        times.append(tdvp_engine.evolved_time)\n        s_mid.append(psi.entanglement_entropy(bonds=[l // 2])[0])\n        es.append(heisenberg.h_mpo.expectation_value(psi))\n\n    measure()\n    for i in range(30):\n        tdvp_engine.run()\n        measure()\n\n    tdvp_engine = tdvp.singlesitetdvpengine.switch_engine(tdvp_engine)\n    for i in range(30):\n        tdvp_engine.run()\n        measure()\n\n    return times, s_mid, es\n\n\ndef plot_example_tdvp(times, s_mid, es):\n\n    axes[0].plot(times, s_mid)\n    axes[0].set_ylabel('entroy $s$ at center bond')\n    axes[1].plot(times, np.array(es) - es[0])\n    axes[1].set_ylabel('energy $e - e(t=0)$')\n    axes[1].set_xlabel('time $t$')\n    for ax in axes:\n        ax.axvline(x=3.01, color='red')\n    axes[0].text(2.9, 0.0000015, 'two-site update', ha='right')\n    axes[0].text(3.1, 0.0000015, 'one-site update, strict tdvp')\n\n\nif __name__ == '__main__':\n    import logging\n\n    logging.basicconfig(level=logging.info)\n    measure = example_tdvp()\n    plot_example_tdvp(*measure) example e tdvp",
    "tokens": 793
  },
  {
    "category": "examples",
    "name": "example.tfi_exact",
    "content": "# Example Source: tfi_exact.py\nr\"\"\"Provides exact ground state energies for the transverse field ising model for comparison.\n\nThe Hamiltonian reads\n\n.. math ::\n    H = - J \\sum_{i} \\sigma^x_i \\sigma^x_{i+1} - g \\sum_{i} \\sigma^z_i\n\n\"\"\"\n# Copyright (C) TeNPy Developers, Apache license\n\nimport warnings\n\nimport numpy as np\nimport scipy.integrate\nimport scipy.sparse as sparse\nfrom scipy.sparse.linalg import eigsh\n\n\ndef finite_gs_energy(L, J, g):\n    \"\"\"For comparison: obtain ground state energy from exact diagonalization.\n\n    Exponentially expensive in L, only works for small enough `L` <~ 20.\n    \"\"\"\n    if L >= 20:\n        warnings.warn('Large L: Exact diagonalization might take a long time!')\n    # get single site operaors\n    sx = sparse.csr_matrix(np.array([[0.0, 1.0], [1.0, 0.0]]))\n    sz = sparse.csr_matrix(np.array([[1.0, 0.0], [0.0, -1.0]]))\n    id = sparse.csr_matrix(np.eye(2))\n    sx_list = []  # sx_list[i] = kron([id, id, ..., id, sx, id, .... id])\n    sz_list = []\n    for i_site in range(L):\n        x_ops = [id] * L\n        z_ops = [id] * L\n        x_ops[i_site] = sx\n        z_ops[i_site] = sz\n        X = x_ops[0]\n        Z = z_ops[0]\n        for j in range(1, L):\n            X = sparse.kron(X, x_ops[j], 'csr')\n            Z = sparse.kron(Z, z_ops[j], 'csr')\n        sx_list.append(X)\n        sz_list.append(Z)\n    H_xx = sparse.csr_matrix((2**L, 2**L))\n    H_z = sparse.csr_matrix((2**L, 2**L))\n    for i in range(L - 1):\n        H_xx = H_xx + sx_list[i] * sx_list[(i + 1) % L]\n    for i in range(L):\n        H_z = H_z + sz_list[i]\n    H = -J * H_xx - g * H_z\n    E, V = eigsh(H, k=1, which='SA', return_eigenvectors=True, ncv=20)\n    return E[0]\n\n\ndef infinite_gs_energy(J, g):\n    \"\"\"For comparison: Calculate groundstate energy density from analytic formula.\n\n    The analytic formula stems from mapping the model to free fermions, see P. Pfeuty, The one-\n    dimensional Ising model with a transverse field, Annals of Physics 57, p. 79 (1970). Note that\n    we use Pauli matrices compared this reference using spin-1/2 matrices and replace the sum_k ->\n    integral dk/2pi to obtain the result in the N -> infinity limit.\n    \"\"\"\n\n    def f(k, lambda_):\n        return np.sqrt(1 + lambda_**2 + 2 * lambda_ * np.cos(k))\n\n    E0_exact = -g / (J * 2.0 * np.pi) * scipy.integrate.quad(f, -np.pi, np.pi, args=(J / g,))[0]\n    return E0_exact",
    "search_text": "example.tfi_exact # example source: tfi_exact.py\nr\"\"\"provides exact ground state energies for the transverse field ising model for comparison.\n\nthe hamiltonian reads\n\n.. math ::\n    h = - j \\sum_{i} \\sigma^x_i \\sigma^x_{i+1} - g \\sum_{i} \\sigma^z_i\n\n\"\"\"\n# copyright (c) tenpy developers, apache license\n\nimport warnings\n\nimport numpy as np\nimport scipy.integrate\nimport scipy.sparse as sparse\nfrom scipy.sparse.linalg import eigsh\n\n\ndef finite_gs_energy(l, j, g):\n    \"\"\"for comparison: obtain ground state energy from exact diagonalization.\n\n    exponentially expensive in l, only works for small enough `l` <~ 20.\n    \"\"\"\n    if l >= 20:\n        warnings.warn('large l: exact diagonalization might take a long time!')\n    # get single site operaors\n    sx = sparse.csr_matrix(np.array([[0.0, 1.0], [1.0, 0.0]]))\n    sz = sparse.csr_matrix(np.array([[1.0, 0.0], [0.0, -1.0]]))\n    id = sparse.csr_matrix(np.eye(2))\n    sx_list = []  # sx_list[i] = kron([id, id, ..., id, sx, id, .... id])\n    sz_list = []\n    for i_site in range(l):\n        x_ops = [id] * l\n        z_ops = [id] * l\n        x_ops[i_site] = sx\n        z_ops[i_site] = sz\n        x = x_ops[0]\n        z = z_ops[0]\n        for j in range(1, l):\n            x = sparse.kron(x, x_ops[j], 'csr')\n            z = sparse.kron(z, z_ops[j], 'csr')\n        sx_list.append(x)\n        sz_list.append(z)\n    h_xx = sparse.csr_matrix((2**l, 2**l))\n    h_z = sparse.csr_matrix((2**l, 2**l))\n    for i in range(l - 1):\n        h_xx = h_xx + sx_list[i] * sx_list[(i + 1) % l]\n    for i in range(l):\n        h_z = h_z + sz_list[i]\n    h = -j * h_xx - g * h_z\n    e, v = eigsh(h, k=1, which='sa', return_eigenvectors=true, ncv=20)\n    return e[0]\n\n\ndef infinite_gs_energy(j, g):\n    \"\"\"for comparison: calculate groundstate energy density from analytic formula.\n\n    the analytic formula stems from mapping the model to free fermions, see p. pfeuty, the one-\n    dimensional ising model with a transverse field, annals of physics 57, p. 79 (1970). note that\n    we use pauli matrices compared this reference using spin-1/2 matrices and replace the sum_k ->\n    integral dk/2pi to obtain the result in the n -> infinity limit.\n    \"\"\"\n\n    def f(k, lambda_):\n        return np.sqrt(1 + lambda_**2 + 2 * lambda_ * np.cos(k))\n\n    e0_exact = -g / (j * 2.0 * np.pi) * scipy.integrate.quad(f, -np.pi, np.pi, args=(j / g,))[0]\n    return e0_exact example tfi exact",
    "tokens": 740
  },
  {
    "category": "examples",
    "name": "example.d_dmrg",
    "content": "# Example Source: d_dmrg.py\n\"\"\"Example illustrating the use of DMRG in tenpy.\n\nThe example functions in this class do the same as the ones in `toycodes/d_dmrg.py`,\nbut make use of the classes defined in tenpy.\n\"\"\"\n# Copyright (C) TeNPy Developers, Apache license\n\nimport numpy as np\n\nfrom tenpy.algorithms import dmrg\nfrom tenpy.models.spins import SpinModel\nfrom tenpy.models.tf_ising import TFIChain\nfrom tenpy.networks.mps import MPS\n\n\ndef example_DMRG_tf_ising_finite(L, g):\n    print('finite DMRG, transverse field Ising model')\n    print(f'L={L:d}, g={g:.2f}')\n    model_params = dict(L=L, J=1.0, g=g, bc_MPS='finite', conserve=None)\n    M = TFIChain(model_params)\n    product_state = ['up'] * M.lat.N_sites\n    psi = MPS.from_product_state(\n        M.lat.mps_sites(), product_state, bc=M.lat.bc_MPS, unit_cell_width=M.lat.mps_unit_cell_width\n    )\n    dmrg_params = {\n        'mixer': None,  # setting this to True helps to escape local minima\n        'max_E_err': 1.0e-10,\n        'trunc_params': {'chi_max': 30, 'svd_min': 1.0e-10},\n        'combine': True,\n    }\n    info = dmrg.run(psi, M, dmrg_params)  # the main work...\n    E = info['E']\n    print(f'E = {E:.13f}')\n    print('final bond dimensions: ', psi.chi)\n    mag_x = np.sum(psi.expectation_value('Sigmax'))\n    mag_z = np.sum(psi.expectation_value('Sigmaz'))\n    print(f'magnetization in X = {mag_x:.5f}')\n    print(f'magnetization in Z = {mag_z:.5f}')\n    if L < 20:  # compare to exact result\n        from tfi_exact import finite_gs_energy\n\n        E_exact = finite_gs_energy(L, 1.0, g)\n        print(f'Exact diagonalization: E = {E_exact:.13f}')\n        print('relative error: ', abs((E - E_exact) / E_exact))\n    return E, psi, M\n\n\ndef example_1site_DMRG_tf_ising_finite(L, g):\n    print('single-site finite DMRG, transverse field Ising model')\n    print(f'L={L:d}, g={g:.2f}')\n    model_params = dict(L=L, J=1.0, g=g, bc_MPS='finite', conserve=None)\n    M = TFIChain(model_params)\n    product_state = ['up'] * M.lat.N_sites\n    psi = MPS.from_product_state(\n        M.lat.mps_sites(), product_state, bc=M.lat.bc_MPS, unit_cell_width=M.lat.mps_unit_cell_width\n    )\n    dmrg_params = {\n        'mixer': True,  # setting this to True is essential for the 1-site algorithm to work.\n        'max_E_err': 1.0e-10,\n        'trunc_params': {'chi_max': 30, 'svd_min': 1.0e-10},\n        'combine': False,\n        'active_sites': 1,  # specifies single-site\n    }\n    info = dmrg.run(psi, M, dmrg_params)\n    E = info['E']\n    print(f'E = {E:.13f}')\n    print('final bond dimensions: ', psi.chi)\n    mag_x = np.sum(psi.expectation_value('Sigmax'))\n    mag_z = np.sum(psi.expectation_value('Sigmaz'))\n    print(f'magnetization in X = {mag_x:.5f}')\n    print(f'magnetization in Z = {mag_z:.5f}')\n    if L < 20:  # compare to exact result\n        from tfi_exact import finite_gs_energy\n\n        E_exact = finite_gs_energy(L, 1.0, g)\n        print(f'Exact diagonalization: E = {E_exact:.13f}')\n        print('relative error: ', abs((E - E_exact) / E_exact))\n    return E, psi, M\n\n\ndef example_DMRG_tf_ising_infinite(g):\n    print('infinite DMRG, transverse field Ising model')\n    print(f'g={g:.2f}')\n    model_params = dict(L=2, J=1.0, g=g, bc_MPS='infinite', conserve=None)\n    M = TFIChain(model_params)\n    product_state = ['up'] * M.lat.N_sites\n    psi = MPS.from_product_state(\n        M.lat.mps_sites(), product_state, bc=M.lat.bc_MPS, unit_cell_width=M.lat.mps_unit_cell_width\n    )\n    dmrg_params = {\n        'mixer': True,  # setting this to True helps to escape local minima\n        'trunc_params': {'chi_max': 30, 'svd_min': 1.0e-10},\n        'max_E_err': 1.0e-10,\n    }\n    # Sometimes, we want to call a 'DMRG engine' explicitly\n    eng = dmrg.TwoSiteDMRGEngine(psi, M, dmrg_params)\n    E, psi = eng.run()  # equivalent to dmrg.run() up to the return parameters.\n    print(f'E = {E:.13f}')\n    print('final bond dimensions: ', psi.chi)\n    mag_x = np.mean(psi.expectation_value('Sigmax'))\n    mag_z = np.mean(psi.expectation_value('Sigmaz'))\n    print(f'<sigma_x> = {mag_x:.5f}')\n    print(f'<sigma_z> = {mag_z:.5f}')\n    print('correlation length:', psi.correlation_length())\n    # compare to exact result\n    from tfi_exact import infinite_gs_energy\n\n    E_exact = infinite_gs_energy(1.0, g)\n    print(f'Analytic result: E (per site) = {E_exact:.13f}')\n    print('relative error: ', abs((E - E_exact) / E_exact))\n    return E, psi, M\n\n\ndef example_1site_DMRG_tf_ising_infinite(g):\n    print('single-site infinite DMRG, transverse field Ising model')\n    print(f'g={g:.2f}')\n    model_params = dict(L=2, J=1.0, g=g, bc_MPS='infinite', conserve=None)\n    M = TFIChain(model_params)\n    product_state = ['up'] * M.lat.N_sites\n    psi = MPS.from_product_state(\n        M.lat.mps_sites(), product_state, bc=M.lat.bc_MPS, unit_cell_width=M.lat.mps_unit_cell_width\n    )\n    dmrg_params = {\n        'mixer': True,  # setting this to True is essential for the 1-site algorithm to work.\n        'trunc_params': {'chi_max': 30, 'svd_min': 1.0e-10},\n        'max_E_err': 1.0e-10,\n        'combine': True,\n    }\n    eng = dmrg.SingleSiteDMRGEngine(psi, M, dmrg_params)\n    E, psi = eng.run()  # equivalent to dmrg.run() up to the return parameters.\n    print(f'E = {E:.13f}')\n    print('final bond dimensions: ', psi.chi)\n    mag_x = np.mean(psi.expectation_value('Sigmax'))\n    mag_z = np.mean(psi.expectation_value('Sigmaz'))\n    print(f'<sigma_x> = {mag_x:.5f}')\n    print(f'<sigma_z> = {mag_z:.5f}')\n    print('correlation length:', psi.correlation_length())\n    # compare to exact result\n    from tfi_exact import infinite_gs_energy\n\n    E_exact = infinite_gs_energy(1.0, g)\n    print(f'Analytic result: E (per site) = {E_exact:.13f}')\n    print('relative error: ', abs((E - E_exact) / E_exact))\n\n\ndef example_DMRG_heisenberg_xxz_infinite(Jz, conserve='best'):\n    print('infinite DMRG, Heisenberg XXZ chain')\n    print(f'Jz={Jz:.2f}, conserve={conserve!r}')\n    model_params = dict(\n        L=2,\n        S=0.5,  # spin 1/2\n        Jx=1.0,\n        Jy=1.0,\n        Jz=Jz,  # couplings\n        bc_MPS='infinite',\n        conserve=conserve,\n    )\n    M = SpinModel(model_params)\n    product_state = ['up', 'down']  # initial Neel state\n    psi = MPS.from_product_state(\n        M.lat.mps_sites(), product_state, bc=M.lat.bc_MPS, unit_cell_width=M.lat.mps_unit_cell_width\n    )\n    dmrg_params = {\n        'mixer': True,  # setting this to True helps to escape local minima\n        'trunc_params': {\n            'chi_max': 100,\n            'svd_min': 1.0e-10,\n        },\n        'max_E_err': 1.0e-10,\n    }\n    info = dmrg.run(psi, M, dmrg_params)\n    E = info['E']\n    print(f'E = {E:.13f}')\n    print('final bond dimensions: ', psi.chi)\n    Sz = psi.expectation_value('Sz')  # Sz instead of Sigma z: spin-1/2 operators!\n    mag_z = np.mean(Sz)\n    print(f'<S_z> = [{Sz[0]:.5f}, {Sz[1]:.5f}]; mean ={mag_z:.5f}')\n    # note: it's clear that mean(<Sz>) is 0: the model has Sz conservation!\n    print('correlation length:', psi.correlation_length())\n    corrs = psi.correlation_function('Sz', 'Sz', sites1=range(10))\n    print('correlations <Sz_i Sz_j> =')\n    print(corrs)\n    return E, psi, M\n\n\nif __name__ == '__main__':\n    import logging\n\n    logging.basicConfig(level=logging.INFO)\n    example_DMRG_tf_ising_finite(L=10, g=1.0)\n    print('-' * 100)\n    example_1site_DMRG_tf_ising_finite(L=10, g=1.0)\n    print('-' * 100)\n    example_DMRG_tf_ising_infinite(g=1.5)\n    print('-' * 100)\n    example_1site_DMRG_tf_ising_infinite(g=1.5)\n    print('-' * 100)\n    example_DMRG_heisenberg_xxz_infinite(Jz=1.5)",
    "search_text": "example.d_dmrg # example source: d_dmrg.py\n\"\"\"example illustrating the use of dmrg in tenpy.\n\nthe example functions in this class do the same as the ones in `toycodes/d_dmrg.py`,\nbut make use of the classes defined in tenpy.\n\"\"\"\n# copyright (c) tenpy developers, apache license\n\nimport numpy as np\n\nfrom tenpy.algorithms import dmrg\nfrom tenpy.models.spins import spinmodel\nfrom tenpy.models.tf_ising import tfichain\nfrom tenpy.networks.mps import mps\n\n\ndef example_dmrg_tf_ising_finite(l, g):\n    print('finite dmrg, transverse field ising model')\n    print(f'l={l:d}, g={g:.2f}')\n    model_params = dict(l=l, j=1.0, g=g, bc_mps='finite', conserve=none)\n    m = tfichain(model_params)\n    product_state = ['up'] * m.lat.n_sites\n    psi = mps.from_product_state(\n        m.lat.mps_sites(), product_state, bc=m.lat.bc_mps, unit_cell_width=m.lat.mps_unit_cell_width\n    )\n    dmrg_params = {\n        'mixer': none,  # setting this to true helps to escape local minima\n        'max_e_err': 1.0e-10,\n        'trunc_params': {'chi_max': 30, 'svd_min': 1.0e-10},\n        'combine': true,\n    }\n    info = dmrg.run(psi, m, dmrg_params)  # the main work...\n    e = info['e']\n    print(f'e = {e:.13f}')\n    print('final bond dimensions: ', psi.chi)\n    mag_x = np.sum(psi.expectation_value('sigmax'))\n    mag_z = np.sum(psi.expectation_value('sigmaz'))\n    print(f'magnetization in x = {mag_x:.5f}')\n    print(f'magnetization in z = {mag_z:.5f}')\n    if l < 20:  # compare to exact result\n        from tfi_exact import finite_gs_energy\n\n        e_exact = finite_gs_energy(l, 1.0, g)\n        print(f'exact diagonalization: e = {e_exact:.13f}')\n        print('relative error: ', abs((e - e_exact) / e_exact))\n    return e, psi, m\n\n\ndef example_1site_dmrg_tf_ising_finite(l, g):\n    print('single-site finite dmrg, transverse field ising model')\n    print(f'l={l:d}, g={g:.2f}')\n    model_params = dict(l=l, j=1.0, g=g, bc_mps='finite', conserve=none)\n    m = tfichain(model_params)\n    product_state = ['up'] * m.lat.n_sites\n    psi = mps.from_product_state(\n        m.lat.mps_sites(), product_state, bc=m.lat.bc_mps, unit_cell_width=m.lat.mps_unit_cell_width\n    )\n    dmrg_params = {\n        'mixer': true,  # setting this to true is essential for the 1-site algorithm to work.\n        'max_e_err': 1.0e-10,\n        'trunc_params': {'chi_max': 30, 'svd_min': 1.0e-10},\n        'combine': false,\n        'active_sites': 1,  # specifies single-site\n    }\n    info = dmrg.run(psi, m, dmrg_params)\n    e = info['e']\n    print(f'e = {e:.13f}')\n    print('final bond dimensions: ', psi.chi)\n    mag_x = np.sum(psi.expectation_value('sigmax'))\n    mag_z = np.sum(psi.expectation_value('sigmaz'))\n    print(f'magnetization in x = {mag_x:.5f}')\n    print(f'magnetization in z = {mag_z:.5f}')\n    if l < 20:  # compare to exact result\n        from tfi_exact import finite_gs_energy\n\n        e_exact = finite_gs_energy(l, 1.0, g)\n        print(f'exact diagonalization: e = {e_exact:.13f}')\n        print('relative error: ', abs((e - e_exact) / e_exact))\n    return e, psi, m\n\n\ndef example_dmrg_tf_ising_infinite(g):\n    print('infinite dmrg, transverse field ising model')\n    print(f'g={g:.2f}')\n    model_params = dict(l=2, j=1.0, g=g, bc_mps='infinite', conserve=none)\n    m = tfichain(model_params)\n    product_state = ['up'] * m.lat.n_sites\n    psi = mps.from_product_state(\n        m.lat.mps_sites(), product_state, bc=m.lat.bc_mps, unit_cell_width=m.lat.mps_unit_cell_width\n    )\n    dmrg_params = {\n        'mixer': true,  # setting this to true helps to escape local minima\n        'trunc_params': {'chi_max': 30, 'svd_min': 1.0e-10},\n        'max_e_err': 1.0e-10,\n    }\n    # sometimes, we want to call a 'dmrg engine' explicitly\n    eng = dmrg.twositedmrgengine(psi, m, dmrg_params)\n    e, psi = eng.run()  # equivalent to dmrg.run() up to the return parameters.\n    print(f'e = {e:.13f}')\n    print('final bond dimensions: ', psi.chi)\n    mag_x = np.mean(psi.expectation_value('sigmax'))\n    mag_z = np.mean(psi.expectation_value('sigmaz'))\n    print(f'<sigma_x> = {mag_x:.5f}')\n    print(f'<sigma_z> = {mag_z:.5f}')\n    print('correlation length:', psi.correlation_length())\n    # compare to exact result\n    from tfi_exact import infinite_gs_energy\n\n    e_exact = infinite_gs_energy(1.0, g)\n    print(f'analytic result: e (per site) = {e_exact:.13f}')\n    print('relative error: ', abs((e - e_exact) / e_exact))\n    return e, psi, m\n\n\ndef example_1site_dmrg_tf_ising_infinite(g):\n    print('single-site infinite dmrg, transverse field ising model')\n    print(f'g={g:.2f}')\n    model_params = dict(l=2, j=1.0, g=g, bc_mps='infinite', conserve=none)\n    m = tfichain(model_params)\n    product_state = ['up'] * m.lat.n_sites\n    psi = mps.from_product_state(\n        m.lat.mps_sites(), product_state, bc=m.lat.bc_mps, unit_cell_width=m.lat.mps_unit_cell_width\n    )\n    dmrg_params = {\n        'mixer': true,  # setting this to true is essential for the 1-site algorithm to work.\n        'trunc_params': {'chi_max': 30, 'svd_min': 1.0e-10},\n        'max_e_err': 1.0e-10,\n        'combine': true,\n    }\n    eng = dmrg.singlesitedmrgengine(psi, m, dmrg_params)\n    e, psi = eng.run()  # equivalent to dmrg.run() up to the return parameters.\n    print(f'e = {e:.13f}')\n    print('final bond dimensions: ', psi.chi)\n    mag_x = np.mean(psi.expectation_value('sigmax'))\n    mag_z = np.mean(psi.expectation_value('sigmaz'))\n    print(f'<sigma_x> = {mag_x:.5f}')\n    print(f'<sigma_z> = {mag_z:.5f}')\n    print('correlation length:', psi.correlation_length())\n    # compare to exact result\n    from tfi_exact import infinite_gs_energy\n\n    e_exact = infinite_gs_energy(1.0, g)\n    print(f'analytic result: e (per site) = {e_exact:.13f}')\n    print('relative error: ', abs((e - e_exact) / e_exact))\n\n\ndef example_dmrg_heisenberg_xxz_infinite(jz, conserve='best'):\n    print('infinite dmrg, heisenberg xxz chain')\n    print(f'jz={jz:.2f}, conserve={conserve!r}')\n    model_params = dict(\n        l=2,\n        s=0.5,  # spin 1/2\n        jx=1.0,\n        jy=1.0,\n        jz=jz,  # couplings\n        bc_mps='infinite',\n        conserve=conserve,\n    )\n    m = spinmodel(model_params)\n    product_state = ['up', 'down']  # initial neel state\n    psi = mps.from_product_state(\n        m.lat.mps_sites(), product_state, bc=m.lat.bc_mps, unit_cell_width=m.lat.mps_unit_cell_width\n    )\n    dmrg_params = {\n        'mixer': true,  # setting this to true helps to escape local minima\n        'trunc_params': {\n            'chi_max': 100,\n            'svd_min': 1.0e-10,\n        },\n        'max_e_err': 1.0e-10,\n    }\n    info = dmrg.run(psi, m, dmrg_params)\n    e = info['e']\n    print(f'e = {e:.13f}')\n    print('final bond dimensions: ', psi.chi)\n    sz = psi.expectation_value('sz')  # sz instead of sigma z: spin-1/2 operators!\n    mag_z = np.mean(sz)\n    print(f'<s_z> = [{sz[0]:.5f}, {sz[1]:.5f}]; mean ={mag_z:.5f}')\n    # note: it's clear that mean(<sz>) is 0: the model has sz conservation!\n    print('correlation length:', psi.correlation_length())\n    corrs = psi.correlation_function('sz', 'sz', sites1=range(10))\n    print('correlations <sz_i sz_j> =')\n    print(corrs)\n    return e, psi, m\n\n\nif __name__ == '__main__':\n    import logging\n\n    logging.basicconfig(level=logging.info)\n    example_dmrg_tf_ising_finite(l=10, g=1.0)\n    print('-' * 100)\n    example_1site_dmrg_tf_ising_finite(l=10, g=1.0)\n    print('-' * 100)\n    example_dmrg_tf_ising_infinite(g=1.5)\n    print('-' * 100)\n    example_1site_dmrg_tf_ising_infinite(g=1.5)\n    print('-' * 100)\n    example_dmrg_heisenberg_xxz_infinite(jz=1.5) example d dmrg",
    "tokens": 2381
  },
  {
    "category": "examples",
    "name": "example.b_mps",
    "content": "# Example Source: b_mps.py\n\"\"\"Simplified version of `a_np_conserved.py` making use of other classes (like MPS, MPO).\n\nThis example includes the following steps:\n1) create Arrays for an Neel MPS\n2) create an MPO representing the nearest-neighbour AFM Heisenberg Hamiltonian\n3) define 'environments' left and right\n4) contract MPS and MPO to calculate the energy\n5) extract two-site hamiltonian ``H2`` from the MPO\n6) calculate ``exp(-1.j*dt*H2)`` by diagonalization of H2\n7) apply ``exp(H2)`` to two sites of the MPS and truncate with svd\n\nNote that this example performs the same steps as `a_np_conserved.py`,\nbut makes use of other predefined classes except npc.\n\"\"\"\n# Copyright (C) TeNPy Developers, Apache license\n\nimport numpy as np\n\nimport tenpy.linalg.np_conserved as npc\nfrom tenpy.linalg.truncation import svd_theta\nfrom tenpy.models.lattice import Chain\nfrom tenpy.networks.mpo import MPO, MPOEnvironment\nfrom tenpy.networks.mps import MPS\n\n# some more imports\nfrom tenpy.networks.site import SpinHalfSite\n\n# model parameters\nJxx, Jz = 1.0, 1.0\nL = 20\ndt = 0.1\ncutoff = 1.0e-10\nprint(f'Jxx={Jxx}, Jz={Jz}, L={L:d}')\n\nprint('1) create Arrays for an Neel MPS')\nsite = SpinHalfSite(conserve='Sz')  # predefined charges and Sp,Sm,Sz operators\np_leg = site.leg\nchinfo = p_leg.chinfo\n# make lattice from unit cell and create product state MPS\nlat = Chain(L, site, bc_MPS='finite')\nstate = ['up', 'down'] * (L // 2) + ['up'] * (L % 2)  # Neel state\nprint('state = ', state)\npsi = MPS.from_product_state(lat.mps_sites(), state, lat.bc_MPS, unit_cell_width=lat.mps_unit_cell_width)\n\nprint('2) create an MPO representing the AFM Heisenberg Hamiltonian')\n\n# predefined physical spin-1/2 operators Sz, S+, S-\nSz, Sp, Sm, Id = site.Sz, site.Sp, site.Sm, site.Id\n\nmpo_leg = npc.LegCharge.from_qflat(chinfo, [[0], [2], [-2], [0], [0]])\n\nW_grid = [[Id,   Sp,   Sm,   Sz,   None          ],\n          [None, None, None, None, 0.5 * Jxx * Sm],\n          [None, None, None, None, 0.5 * Jxx * Sp],\n          [None, None, None, None, Jz * Sz       ],\n          [None, None, None, None, Id            ]]  # fmt: skip\n\nW = npc.grid_outer(W_grid, [mpo_leg, mpo_leg.conj()], grid_labels=['wL', 'wR'])\n# wL/wR = virtual left/right of the MPO\nWs = [W] * L\nWs[0] = W[:1, :]\nWs[-1] = W[:, -1:]\nH = MPO(psi.sites, Ws, psi.bc, IdL=0, IdR=-1, mps_unit_cell_width=L)\n\nprint(\"3) define 'environments' left and right\")\n\n# this is automatically done during initialization of MPOEnvironment\nenv = MPOEnvironment(psi, H, psi)\nenvL = env.get_LP(0)\nenvR = env.get_RP(L - 1)\n\nprint('4) contract MPS and MPO to calculate the energy <psi|H|psi>')\n\nE = env.full_contraction(L - 1)\nprint('E =', E)\n\nprint('5) calculate two-site hamiltonian ``H2`` from the MPO')\n# label left, right physical legs with p, q\nW0 = H.get_W(0).replace_labels(['p', 'p*'], ['p0', 'p0*'])\nW1 = H.get_W(1).replace_labels(['p', 'p*'], ['p1', 'p1*'])\nH2 = npc.tensordot(W0, W1, axes=('wR', 'wL')).itranspose(['wL', 'wR', 'p0', 'p1', 'p0*', 'p1*'])\nH2 = H2[H.IdL[0], H.IdR[2]]  # (If H has single-site terms, it's not that simple anymore)\nprint('H2 labels:', H2.get_leg_labels())\n\nprint('6) calculate exp(H2) by diagonalization of H2')\n# diagonalization requires to view H2 as a matrix\nH2 = H2.combine_legs([('p0', 'p1'), ('p0*', 'p1*')], qconj=[+1, -1])\nprint('labels after combine_legs:', H2.get_leg_labels())\nE2, U2 = npc.eigh(H2)\nprint('Eigenvalues of H2:', E2)\nU_expE2 = U2.scale_axis(np.exp(-1.0j * dt * E2), axis=1)  # scale_axis ~= apply a diagonal matrix\nexp_H2 = npc.tensordot(U_expE2, U2.conj(), axes=(1, 1))\nexp_H2.iset_leg_labels(H2.get_leg_labels())\nexp_H2 = exp_H2.split_legs()  # by default split all legs which are `LegPipe`\n# (this restores the originial labels ['p0', 'p1', 'p0*', 'p1*'] of `H2` in `exp_H2`)\n\n# alternative way: use :func:`~tenpy.linalg.np_conserved.expm`\nexp_H2_alternative = npc.expm(-1.0j * dt * H2).split_legs()\nassert npc.norm(exp_H2_alternative - exp_H2) < 1.0e-14\n\nprint('7) apply exp(H2) to even/odd bonds of the MPS and truncate with svd')\n# (this implements one time step of first order TEBD)\ntrunc_par = {'svd_min': cutoff, 'trunc_cut': None}\nfor even_odd in [0, 1]:\n    for i in range(even_odd, L - 1, 2):\n        theta = psi.get_theta(i, 2)  # handles canonical form (i.e. scaling with 'S')\n        theta = npc.tensordot(exp_H2, theta, axes=(['p0*', 'p1*'], ['p0', 'p1']))\n        # view as matrix for SVD\n        theta = theta.combine_legs([('vL', 'p0'), ('p1', 'vR')], new_axes=[0, 1], qconj=[+1, -1])\n        # now theta has labels '(vL.p0)', '(p1.vR)'\n        U, S, V, err, invsq = svd_theta(theta, trunc_par, inner_labels=['vR', 'vL'])\n        psi.set_SR(i, S)\n        A_L = U.split_legs('(vL.p0)').ireplace_label('p0', 'p')\n        B_R = V.split_legs('(p1.vR)').ireplace_label('p1', 'p')\n        psi.set_B(i, A_L, form='A')  # left-canonical form\n        psi.set_B(i + 1, B_R, form='B')  # right-canonical form\nprint('finished')",
    "search_text": "example.b_mps # example source: b_mps.py\n\"\"\"simplified version of `a_np_conserved.py` making use of other classes (like mps, mpo).\n\nthis example includes the following steps:\n1) create arrays for an neel mps\n2) create an mpo representing the nearest-neighbour afm heisenberg hamiltonian\n3) define 'environments' left and right\n4) contract mps and mpo to calculate the energy\n5) extract two-site hamiltonian ``h2`` from the mpo\n6) calculate ``exp(-1.j*dt*h2)`` by diagonalization of h2\n7) apply ``exp(h2)`` to two sites of the mps and truncate with svd\n\nnote that this example performs the same steps as `a_np_conserved.py`,\nbut makes use of other predefined classes except npc.\n\"\"\"\n# copyright (c) tenpy developers, apache license\n\nimport numpy as np\n\nimport tenpy.linalg.np_conserved as npc\nfrom tenpy.linalg.truncation import svd_theta\nfrom tenpy.models.lattice import chain\nfrom tenpy.networks.mpo import mpo, mpoenvironment\nfrom tenpy.networks.mps import mps\n\n# some more imports\nfrom tenpy.networks.site import spinhalfsite\n\n# model parameters\njxx, jz = 1.0, 1.0\nl = 20\ndt = 0.1\ncutoff = 1.0e-10\nprint(f'jxx={jxx}, jz={jz}, l={l:d}')\n\nprint('1) create arrays for an neel mps')\nsite = spinhalfsite(conserve='sz')  # predefined charges and sp,sm,sz operators\np_leg = site.leg\nchinfo = p_leg.chinfo\n# make lattice from unit cell and create product state mps\nlat = chain(l, site, bc_mps='finite')\nstate = ['up', 'down'] * (l // 2) + ['up'] * (l % 2)  # neel state\nprint('state = ', state)\npsi = mps.from_product_state(lat.mps_sites(), state, lat.bc_mps, unit_cell_width=lat.mps_unit_cell_width)\n\nprint('2) create an mpo representing the afm heisenberg hamiltonian')\n\n# predefined physical spin-1/2 operators sz, s+, s-\nsz, sp, sm, id = site.sz, site.sp, site.sm, site.id\n\nmpo_leg = npc.legcharge.from_qflat(chinfo, [[0], [2], [-2], [0], [0]])\n\nw_grid = [[id,   sp,   sm,   sz,   none          ],\n          [none, none, none, none, 0.5 * jxx * sm],\n          [none, none, none, none, 0.5 * jxx * sp],\n          [none, none, none, none, jz * sz       ],\n          [none, none, none, none, id            ]]  # fmt: skip\n\nw = npc.grid_outer(w_grid, [mpo_leg, mpo_leg.conj()], grid_labels=['wl', 'wr'])\n# wl/wr = virtual left/right of the mpo\nws = [w] * l\nws[0] = w[:1, :]\nws[-1] = w[:, -1:]\nh = mpo(psi.sites, ws, psi.bc, idl=0, idr=-1, mps_unit_cell_width=l)\n\nprint(\"3) define 'environments' left and right\")\n\n# this is automatically done during initialization of mpoenvironment\nenv = mpoenvironment(psi, h, psi)\nenvl = env.get_lp(0)\nenvr = env.get_rp(l - 1)\n\nprint('4) contract mps and mpo to calculate the energy <psi|h|psi>')\n\ne = env.full_contraction(l - 1)\nprint('e =', e)\n\nprint('5) calculate two-site hamiltonian ``h2`` from the mpo')\n# label left, right physical legs with p, q\nw0 = h.get_w(0).replace_labels(['p', 'p*'], ['p0', 'p0*'])\nw1 = h.get_w(1).replace_labels(['p', 'p*'], ['p1', 'p1*'])\nh2 = npc.tensordot(w0, w1, axes=('wr', 'wl')).itranspose(['wl', 'wr', 'p0', 'p1', 'p0*', 'p1*'])\nh2 = h2[h.idl[0], h.idr[2]]  # (if h has single-site terms, it's not that simple anymore)\nprint('h2 labels:', h2.get_leg_labels())\n\nprint('6) calculate exp(h2) by diagonalization of h2')\n# diagonalization requires to view h2 as a matrix\nh2 = h2.combine_legs([('p0', 'p1'), ('p0*', 'p1*')], qconj=[+1, -1])\nprint('labels after combine_legs:', h2.get_leg_labels())\ne2, u2 = npc.eigh(h2)\nprint('eigenvalues of h2:', e2)\nu_expe2 = u2.scale_axis(np.exp(-1.0j * dt * e2), axis=1)  # scale_axis ~= apply a diagonal matrix\nexp_h2 = npc.tensordot(u_expe2, u2.conj(), axes=(1, 1))\nexp_h2.iset_leg_labels(h2.get_leg_labels())\nexp_h2 = exp_h2.split_legs()  # by default split all legs which are `legpipe`\n# (this restores the originial labels ['p0', 'p1', 'p0*', 'p1*'] of `h2` in `exp_h2`)\n\n# alternative way: use :func:`~tenpy.linalg.np_conserved.expm`\nexp_h2_alternative = npc.expm(-1.0j * dt * h2).split_legs()\nassert npc.norm(exp_h2_alternative - exp_h2) < 1.0e-14\n\nprint('7) apply exp(h2) to even/odd bonds of the mps and truncate with svd')\n# (this implements one time step of first order tebd)\ntrunc_par = {'svd_min': cutoff, 'trunc_cut': none}\nfor even_odd in [0, 1]:\n    for i in range(even_odd, l - 1, 2):\n        theta = psi.get_theta(i, 2)  # handles canonical form (i.e. scaling with 's')\n        theta = npc.tensordot(exp_h2, theta, axes=(['p0*', 'p1*'], ['p0', 'p1']))\n        # view as matrix for svd\n        theta = theta.combine_legs([('vl', 'p0'), ('p1', 'vr')], new_axes=[0, 1], qconj=[+1, -1])\n        # now theta has labels '(vl.p0)', '(p1.vr)'\n        u, s, v, err, invsq = svd_theta(theta, trunc_par, inner_labels=['vr', 'vl'])\n        psi.set_sr(i, s)\n        a_l = u.split_legs('(vl.p0)').ireplace_label('p0', 'p')\n        b_r = v.split_legs('(p1.vr)').ireplace_label('p1', 'p')\n        psi.set_b(i, a_l, form='a')  # left-canonical form\n        psi.set_b(i + 1, b_r, form='b')  # right-canonical form\nprint('finished') example b mps",
    "tokens": 1672
  },
  {
    "category": "examples",
    "name": "example.purification",
    "content": "# Example Source: purification.py\n\"\"\"An example for purification MPS.\"\"\"\n# Copyright (C) TeNPy Developers, Apache license\n\nfrom tenpy.algorithms.purification import PurificationApplyMPO, PurificationTEBD\nfrom tenpy.models.tf_ising import TFIChain\nfrom tenpy.networks.purification_mps import PurificationMPS\n\n\ndef imag_tebd(L=30, beta_max=3.0, dt=0.05, order=2, bc='finite'):\n    model_params = dict(L=L, J=1.0, g=1.2)\n    M = TFIChain(model_params)\n    psi = PurificationMPS.from_infiniteT(M.lat.mps_sites(), bc=bc)\n    options = {'trunc_params': {'chi_max': 100, 'svd_min': 1.0e-8}, 'order': order, 'dt': dt, 'N_steps': 1}\n    beta = 0.0\n    eng = PurificationTEBD(psi, M, options)\n    Szs = [psi.expectation_value('Sz')]\n    betas = [0.0]\n    while beta < beta_max:\n        beta += 2.0 * dt  # factor of 2:  |psi> ~= exp^{- dt H}, but rho = |psi><psi|\n        betas.append(beta)\n        eng.run_imaginary(dt)  # cool down by dt\n        Szs.append(psi.expectation_value('Sz'))  # and further measurements...\n    return {'beta': betas, 'Sz': Szs}\n\n\ndef imag_apply_mpo(L=30, beta_max=3.0, dt=0.05, order=2, bc='finite', approx='II'):\n    model_params = dict(L=L, J=1.0, g=1.2)\n    M = TFIChain(model_params)\n    psi = PurificationMPS.from_infiniteT(M.lat.mps_sites(), bc=bc)\n    options = {'trunc_params': {'chi_max': 100, 'svd_min': 1.0e-8}}\n    beta = 0.0\n    if order == 1:\n        Us = [M.H_MPO.make_U(-dt, approx)]\n    elif order == 2:\n        Us = [M.H_MPO.make_U(-d * dt, approx) for d in [0.5 + 0.5j, 0.5 - 0.5j]]\n    eng = PurificationApplyMPO(psi, Us[0], options)\n    Szs = [psi.expectation_value('Sz')]\n    betas = [0.0]\n    while beta < beta_max:\n        beta += 2.0 * dt  # factor of 2:  |psi> ~= exp^{- dt H}, but rho = |psi><psi|\n        betas.append(beta)\n        for U in Us:\n            eng.init_env(U)  # reset environment, initialize new copy of psi\n            eng.run()  # apply U to psi\n        Szs.append(psi.expectation_value('Sz'))  # and further measurements...\n    return {'beta': betas, 'Sz': Szs}\n\n\nif __name__ == '__main__':\n    import logging\n\n    logging.basicConfig(level=logging.INFO)\n    data_tebd = imag_tebd()\n    data_mpo = imag_apply_mpo()\n\n    import numpy as np\n",
    "search_text": "example.purification # example source: purification.py\n\"\"\"an example for purification mps.\"\"\"\n# copyright (c) tenpy developers, apache license\n\nfrom tenpy.algorithms.purification import purificationapplympo, purificationtebd\nfrom tenpy.models.tf_ising import tfichain\nfrom tenpy.networks.purification_mps import purificationmps\n\n\ndef imag_tebd(l=30, beta_max=3.0, dt=0.05, order=2, bc='finite'):\n    model_params = dict(l=l, j=1.0, g=1.2)\n    m = tfichain(model_params)\n    psi = purificationmps.from_infinitet(m.lat.mps_sites(), bc=bc)\n    options = {'trunc_params': {'chi_max': 100, 'svd_min': 1.0e-8}, 'order': order, 'dt': dt, 'n_steps': 1}\n    beta = 0.0\n    eng = purificationtebd(psi, m, options)\n    szs = [psi.expectation_value('sz')]\n    betas = [0.0]\n    while beta < beta_max:\n        beta += 2.0 * dt  # factor of 2:  |psi> ~= exp^{- dt h}, but rho = |psi><psi|\n        betas.append(beta)\n        eng.run_imaginary(dt)  # cool down by dt\n        szs.append(psi.expectation_value('sz'))  # and further measurements...\n    return {'beta': betas, 'sz': szs}\n\n\ndef imag_apply_mpo(l=30, beta_max=3.0, dt=0.05, order=2, bc='finite', approx='ii'):\n    model_params = dict(l=l, j=1.0, g=1.2)\n    m = tfichain(model_params)\n    psi = purificationmps.from_infinitet(m.lat.mps_sites(), bc=bc)\n    options = {'trunc_params': {'chi_max': 100, 'svd_min': 1.0e-8}}\n    beta = 0.0\n    if order == 1:\n        us = [m.h_mpo.make_u(-dt, approx)]\n    elif order == 2:\n        us = [m.h_mpo.make_u(-d * dt, approx) for d in [0.5 + 0.5j, 0.5 - 0.5j]]\n    eng = purificationapplympo(psi, us[0], options)\n    szs = [psi.expectation_value('sz')]\n    betas = [0.0]\n    while beta < beta_max:\n        beta += 2.0 * dt  # factor of 2:  |psi> ~= exp^{- dt h}, but rho = |psi><psi|\n        betas.append(beta)\n        for u in us:\n            eng.init_env(u)  # reset environment, initialize new copy of psi\n            eng.run()  # apply u to psi\n        szs.append(psi.expectation_value('sz'))  # and further measurements...\n    return {'beta': betas, 'sz': szs}\n\n\nif __name__ == '__main__':\n    import logging\n\n    logging.basicconfig(level=logging.info)\n    data_tebd = imag_tebd()\n    data_mpo = imag_apply_mpo()\n\n    import numpy as np\n example purification",
    "tokens": 724
  },
  {
    "category": "examples",
    "name": "example.model_custom",
    "content": "# Example Source: model_custom.py\n\"\"\"This file ``/examples/model_custom.py`` illustrates customization code for simulations.\n\nPut this file somewhere where it can be importet by python, i.e. either in the working directory\nor somewhere in the ``PYTHON_PATH``. Then you can use it with the parameters file\n``/examples/model_custom.yml`` from the terminal like this::\n\n    tenpy-run -i model_custom simulation_custom.yml\n\"\"\"\n\nimport numpy as np\n\nfrom tenpy.linalg import np_conserved as npc\nfrom tenpy.models.lattice import Chain\nfrom tenpy.models.model import CouplingMPOModel, NearestNeighborModel\nfrom tenpy.networks.mps import TransferMatrix\nfrom tenpy.networks.site import SpinSite\n\n\nclass AnisotropicSpin1Chain(CouplingMPOModel, NearestNeighborModel):\n    r\"\"\"An example for a custom model, implementing the Hamiltonian of :arxiv:`1204.0704`.\n\n    .. math ::\n        H = J \\sum_i \\vec{S}_i \\cdot \\vec{S}_{i+1} + B \\sum_i S^x_i + D \\sum_i (S^z_i)^2\n    \"\"\"\n\n    default_lattice = Chain\n    force_default_lattice = True\n\n    def init_sites(self, model_params):\n        conserve = model_params.get('conserve', 'best')\n        if conserve == 'best':\n            conserve = 'Sz' if not model_params.any_nonzero(['B']) else None\n            self.logger.info('%s: set conserve to %s', self.name, conserve)\n        sort_charge = model_params.get('sort_charge', True)\n        return SpinSite(S=1.0, conserve=None, sort_charge=sort_charge)\n\n    def init_terms(self, model_params):\n        J = model_params.get('J', 1.0)\n        B = model_params.get('B', 0.0)\n        D = model_params.get('D', 0.0)\n\n        for u1, u2, dx in self.lat.pairs['nearest_neighbors']:\n            self.add_coupling(J / 2.0, u1, 'Sp', u2, 'Sm', dx, plus_hc=True)\n            self.add_coupling(J, u1, 'Sz', u2, 'Sz', dx)\n\n        for u in range(len(self.lat.unit_cell)):\n            self.add_onsite(B, u, 'Sx')\n            self.add_onsite(D, u, 'Sz Sz')\n\n\ndef m_pollmann_turner_inversion(results, psi, model, simulation, tol=0.01):\n    \"\"\"Measurement function for equation 15 of :arxiv:`1204.0704`.\n\n    See :func:`~tenpy.simulations.measurement.measurement_index` for the call structure.\n    \"\"\"\n    psi2 = psi.copy()\n    psi2.spatial_inversion()\n    mixed_TM = TransferMatrix(psi, psi2, transpose=False, charge_sector=0, form='B')\n    evals, evecs = mixed_TM.eigenvectors(which='LM', num_ev=1)\n    results['pollmann_turner_inversion_eta'] = eta = evals[0]\n    U_I = evecs[0].split_legs().transpose().conj()\n    U_I *= np.sqrt(U_I.shape[0])  # previously normalized to npc.norm(U_I) = 1, need unitary\n    results['pollmann_turner_inversion_U_I'] = U_I\n    if abs(eta) < 1.0 - tol:\n        O_I = 0.0\n    else:\n        O_I = npc.inner(U_I, U_I.conj(), axes=[[0, 1], [1, 0]]) / U_I.shape[0]\n    results['pollmann_turner_inversion'] = O_I",
    "search_text": "example.model_custom # example source: model_custom.py\n\"\"\"this file ``/examples/model_custom.py`` illustrates customization code for simulations.\n\nput this file somewhere where it can be importet by python, i.e. either in the working directory\nor somewhere in the ``python_path``. then you can use it with the parameters file\n``/examples/model_custom.yml`` from the terminal like this::\n\n    tenpy-run -i model_custom simulation_custom.yml\n\"\"\"\n\nimport numpy as np\n\nfrom tenpy.linalg import np_conserved as npc\nfrom tenpy.models.lattice import chain\nfrom tenpy.models.model import couplingmpomodel, nearestneighbormodel\nfrom tenpy.networks.mps import transfermatrix\nfrom tenpy.networks.site import spinsite\n\n\nclass anisotropicspin1chain(couplingmpomodel, nearestneighbormodel):\n    r\"\"\"an example for a custom model, implementing the hamiltonian of :arxiv:`1204.0704`.\n\n    .. math ::\n        h = j \\sum_i \\vec{s}_i \\cdot \\vec{s}_{i+1} + b \\sum_i s^x_i + d \\sum_i (s^z_i)^2\n    \"\"\"\n\n    default_lattice = chain\n    force_default_lattice = true\n\n    def init_sites(self, model_params):\n        conserve = model_params.get('conserve', 'best')\n        if conserve == 'best':\n            conserve = 'sz' if not model_params.any_nonzero(['b']) else none\n            self.logger.info('%s: set conserve to %s', self.name, conserve)\n        sort_charge = model_params.get('sort_charge', true)\n        return spinsite(s=1.0, conserve=none, sort_charge=sort_charge)\n\n    def init_terms(self, model_params):\n        j = model_params.get('j', 1.0)\n        b = model_params.get('b', 0.0)\n        d = model_params.get('d', 0.0)\n\n        for u1, u2, dx in self.lat.pairs['nearest_neighbors']:\n            self.add_coupling(j / 2.0, u1, 'sp', u2, 'sm', dx, plus_hc=true)\n            self.add_coupling(j, u1, 'sz', u2, 'sz', dx)\n\n        for u in range(len(self.lat.unit_cell)):\n            self.add_onsite(b, u, 'sx')\n            self.add_onsite(d, u, 'sz sz')\n\n\ndef m_pollmann_turner_inversion(results, psi, model, simulation, tol=0.01):\n    \"\"\"measurement function for equation 15 of :arxiv:`1204.0704`.\n\n    see :func:`~tenpy.simulations.measurement.measurement_index` for the call structure.\n    \"\"\"\n    psi2 = psi.copy()\n    psi2.spatial_inversion()\n    mixed_tm = transfermatrix(psi, psi2, transpose=false, charge_sector=0, form='b')\n    evals, evecs = mixed_tm.eigenvectors(which='lm', num_ev=1)\n    results['pollmann_turner_inversion_eta'] = eta = evals[0]\n    u_i = evecs[0].split_legs().transpose().conj()\n    u_i *= np.sqrt(u_i.shape[0])  # previously normalized to npc.norm(u_i) = 1, need unitary\n    results['pollmann_turner_inversion_u_i'] = u_i\n    if abs(eta) < 1.0 - tol:\n        o_i = 0.0\n    else:\n        o_i = npc.inner(u_i, u_i.conj(), axes=[[0, 1], [1, 0]]) / u_i.shape[0]\n    results['pollmann_turner_inversion'] = o_i example model custom",
    "tokens": 801
  },
  {
    "category": "examples",
    "name": "example.c_tebd",
    "content": "# Example Source: c_tebd.py\n\"\"\"Example illustrating the use of TEBD in tenpy.\n\nThe example functions in this class do the same as the ones in `toycodes/c_tebd.py`, but make use\nof the classes defined in tenpy.\n\"\"\"\n# Copyright (C) TeNPy Developers, Apache license\n\nimport numpy as np\n\nfrom tenpy.algorithms import tebd\nfrom tenpy.models.tf_ising import TFIChain\nfrom tenpy.networks.mps import MPS\n\n\ndef example_TEBD_gs_tf_ising_finite(L, g):\n    print('finite TEBD, imaginary time evolution, transverse field Ising')\n    print(f'L={L:d}, g={g:.2f}')\n    model_params = dict(L=L, J=1.0, g=g, bc_MPS='finite', conserve=None)\n    M = TFIChain(model_params)\n    product_state = ['up'] * M.lat.N_sites\n    psi = MPS.from_product_state(\n        M.lat.mps_sites(), product_state, bc=M.lat.bc_MPS, unit_cell_width=M.lat.mps_unit_cell_width\n    )\n    tebd_params = {\n        'order': 2,\n        'delta_tau_list': [0.1, 0.01, 0.001, 1.0e-4, 1.0e-5],\n        'N_steps': 10,\n        'max_error_E': 1.0e-6,\n        'trunc_params': {'chi_max': 30, 'svd_min': 1.0e-10},\n    }\n    eng = tebd.TEBDEngine(psi, M, tebd_params)\n    eng.run_GS()  # the main work...\n\n    # expectation values\n    E = np.sum(M.bond_energies(psi))  # M.bond_energies() works only a for NearestNeighborModel\n    # alternative: directly measure E2 = np.sum(psi.expectation_value(M.H_bond[1:]))\n    print(f'E = {E:.13f}')\n    print('final bond dimensions: ', psi.chi)\n    mag_x = np.sum(psi.expectation_value('Sigmax'))\n    mag_z = np.sum(psi.expectation_value('Sigmaz'))\n    print(f'magnetization in X = {mag_x:.5f}')\n    print(f'magnetization in Z = {mag_z:.5f}')\n    if L < 20:  # compare to exact result\n        from tfi_exact import finite_gs_energy\n\n        E_exact = finite_gs_energy(L, 1.0, g)\n        print(f'Exact diagonalization: E = {E_exact:.13f}')\n        print('relative error: ', abs((E - E_exact) / E_exact))\n    return E, psi, M\n\n\ndef example_TEBD_gs_tf_ising_infinite(g):\n    print('infinite TEBD, imaginary time evolution, transverse field Ising')\n    print(f'g={g:.2f}')\n    model_params = dict(L=2, J=1.0, g=g, bc_MPS='infinite', conserve=None)\n    M = TFIChain(model_params)\n    product_state = ['up'] * M.lat.N_sites\n    psi = MPS.from_product_state(\n        M.lat.mps_sites(), product_state, bc=M.lat.bc_MPS, unit_cell_width=M.lat.mps_unit_cell_width\n    )\n    tebd_params = {\n        'order': 2,\n        'delta_tau_list': [0.1, 0.01, 0.001, 1.0e-4, 1.0e-5],\n        'N_steps': 10,\n        'max_error_E': 1.0e-8,\n        'trunc_params': {'chi_max': 30, 'svd_min': 1.0e-10},\n    }\n    eng = tebd.TEBDEngine(psi, M, tebd_params)\n    eng.run_GS()  # the main work...\n    E = np.mean(M.bond_energies(psi))  # M.bond_energies() works only a for NearestNeighborModel\n    # alternative: directly measure E2 = np.mean(psi.expectation_value(M.H_bond))\n    print(f'E (per site) = {E:.13f}')\n    print('final bond dimensions: ', psi.chi)\n    mag_x = np.mean(psi.expectation_value('Sigmax'))\n    mag_z = np.mean(psi.expectation_value('Sigmaz'))\n    print(f'<sigma_x> = {mag_x:.5f}')\n    print(f'<sigma_z> = {mag_z:.5f}')\n    print('correlation length:', psi.correlation_length())\n    # compare to exact result\n    from tfi_exact import infinite_gs_energy\n\n    E_exact = infinite_gs_energy(1.0, g)\n    print(f'Analytic result: E (per site) = {E_exact:.13f}')\n    print('relative error: ', abs((E - E_exact) / E_exact))\n    return E, psi, M\n\n\ndef example_TEBD_tf_ising_lightcone(L, g, tmax, dt):\n    print('finite TEBD, real time evolution')\n    print(f'L={L:d}, g={g:.2f}, tmax={tmax:.2f}, dt={dt:.3f}')\n    # find ground state with TEBD or DMRG\n    #  E, psi, M = example_TEBD_gs_tf_ising_finite(L, g)\n    from d_dmrg import example_DMRG_tf_ising_finite\n\n    print('(run DMRG to get the groundstate)')\n    E, psi, M = example_DMRG_tf_ising_finite(L, g)\n    print('(DMRG finished)')\n    i0 = L // 2\n    # apply sigmaz on site i0\n    psi.apply_local_op(i0, 'Sigmaz', unitary=True)\n    dt_measure = 0.05\n    # tebd.TEBDEngine makes 'N_steps' steps of `dt` at once;\n    # for second order this is more efficient.\n    tebd_params = {\n        'order': 2,\n        'dt': dt,\n        'N_steps': int(dt_measure / dt + 0.5),\n        'trunc_params': {'chi_max': 50, 'svd_min': 1.0e-10, 'trunc_cut': None},\n    }\n    eng = tebd.TEBDEngine(psi, M, tebd_params)\n    S = [psi.entanglement_entropy()]\n    for n in range(int(tmax / dt_measure + 0.5)):\n        eng.run()\n        S.append(psi.entanglement_entropy())\n\n        S[::-1],\n        vmin=0.0,\n        aspect='auto',\n        interpolation='nearest',\n        extent=(0, L - 1.0, -0.5 * dt_measure, eng.evolved_time + 0.5 * dt_measure),\n    )\n    filename = f'c_tebd_lightcone_{g:.2f}.pdf'\n    print('saved ' + filename)\n\n\ndef example_TEBD_gs_tf_ising_next_nearest_neighbor(L, g, Jp):\n    from tenpy.models.model import NearestNeighborModel\n    from tenpy.models.spins_nnn import SpinChainNNN2\n\n    print('finite TEBD, imaginary time evolution, transverse field Ising next-nearest neighbor')\n    print(f'L={L:d}, g={g:.2f}, Jp={Jp:.2f}')\n    model_params = dict(\n        L=L,\n        Jx=1.0,\n        Jy=0.0,\n        Jz=0.0,\n        Jxp=Jp,\n        Jyp=0.0,\n        Jzp=0.0,\n        hz=g,\n        bc_MPS='finite',\n        conserve=None,\n    )\n    # we start with the non-grouped sites, but next-nearest neighbor interactions, building the MPO\n    M = SpinChainNNN2(model_params)\n    product_state = ['up'] * M.lat.N_sites\n    psi = MPS.from_product_state(\n        M.lat.mps_sites(), product_state, bc=M.lat.bc_MPS, unit_cell_width=M.lat.mps_unit_cell_width\n    )\n\n    # now we group each to sites ...\n    psi.group_sites(n=2)  # ... in the state\n    M.group_sites(n=2)  # ... and model\n    # now, M has only 'nearest-neighbor' interactions with respect to the grouped sites\n    # thus, we can convert the MPO into H_bond terms:\n    M_nn = NearestNeighborModel.from_MPOModel(M)  # hence, we can initialize H_bond from the MPO\n\n    # now, we continue to run TEBD as before\n    tebd_params = {\n        'order': 2,\n        'delta_tau_list': [0.1, 0.01, 0.001, 1.0e-4, 1.0e-5],\n        'N_steps': 10,\n        'max_error_E': 1.0e-6,\n        'trunc_params': {'chi_max': 30, 'svd_min': 1.0e-10},\n    }\n    eng = tebd.TEBDEngine(psi, M_nn, tebd_params)  # use M_nn and grouped psi\n    eng.run_GS()  # the main work...\n\n    # expectation values:\n    E = np.sum(M_nn.bond_energies(psi))  # bond_energies() works only a for NearestNeighborModel\n    print(f'E = {E:.13f}')\n    print('final bond dimensions: ', psi.chi)\n    # we can split the sites of the state again for an easier evaluation of expectation values\n    psi.group_split()\n    mag_x = 2.0 * np.sum(psi.expectation_value('Sx'))  # factor of 2 for Sx vs Sigmax\n    mag_z = 2.0 * np.sum(psi.expectation_value('Sz'))\n    print(f'magnetization in X = {mag_x:.5f}')\n    print(f'magnetization in Z = {mag_z:.5f}')\n    return E, psi, M\n\n\nif __name__ == '__main__':\n    import logging\n\n    logging.basicConfig(level=logging.INFO)\n    example_TEBD_gs_tf_ising_finite(L=10, g=1.0)\n    print('=' * 100, '', '', '=' * 100, sep='\\n')\n    example_TEBD_gs_tf_ising_infinite(g=1.5)\n    print('=' * 100, '', '', '=' * 100, sep='\\n')\n    example_TEBD_tf_ising_lightcone(L=20, g=1.5, tmax=3.0, dt=0.01)\n    print('=' * 100, '', '', '=' * 100, sep='\\n')\n    example_TEBD_gs_tf_ising_next_nearest_neighbor(L=10, g=1.0, Jp=0.1)",
    "search_text": "example.c_tebd # example source: c_tebd.py\n\"\"\"example illustrating the use of tebd in tenpy.\n\nthe example functions in this class do the same as the ones in `toycodes/c_tebd.py`, but make use\nof the classes defined in tenpy.\n\"\"\"\n# copyright (c) tenpy developers, apache license\n\nimport numpy as np\n\nfrom tenpy.algorithms import tebd\nfrom tenpy.models.tf_ising import tfichain\nfrom tenpy.networks.mps import mps\n\n\ndef example_tebd_gs_tf_ising_finite(l, g):\n    print('finite tebd, imaginary time evolution, transverse field ising')\n    print(f'l={l:d}, g={g:.2f}')\n    model_params = dict(l=l, j=1.0, g=g, bc_mps='finite', conserve=none)\n    m = tfichain(model_params)\n    product_state = ['up'] * m.lat.n_sites\n    psi = mps.from_product_state(\n        m.lat.mps_sites(), product_state, bc=m.lat.bc_mps, unit_cell_width=m.lat.mps_unit_cell_width\n    )\n    tebd_params = {\n        'order': 2,\n        'delta_tau_list': [0.1, 0.01, 0.001, 1.0e-4, 1.0e-5],\n        'n_steps': 10,\n        'max_error_e': 1.0e-6,\n        'trunc_params': {'chi_max': 30, 'svd_min': 1.0e-10},\n    }\n    eng = tebd.tebdengine(psi, m, tebd_params)\n    eng.run_gs()  # the main work...\n\n    # expectation values\n    e = np.sum(m.bond_energies(psi))  # m.bond_energies() works only a for nearestneighbormodel\n    # alternative: directly measure e2 = np.sum(psi.expectation_value(m.h_bond[1:]))\n    print(f'e = {e:.13f}')\n    print('final bond dimensions: ', psi.chi)\n    mag_x = np.sum(psi.expectation_value('sigmax'))\n    mag_z = np.sum(psi.expectation_value('sigmaz'))\n    print(f'magnetization in x = {mag_x:.5f}')\n    print(f'magnetization in z = {mag_z:.5f}')\n    if l < 20:  # compare to exact result\n        from tfi_exact import finite_gs_energy\n\n        e_exact = finite_gs_energy(l, 1.0, g)\n        print(f'exact diagonalization: e = {e_exact:.13f}')\n        print('relative error: ', abs((e - e_exact) / e_exact))\n    return e, psi, m\n\n\ndef example_tebd_gs_tf_ising_infinite(g):\n    print('infinite tebd, imaginary time evolution, transverse field ising')\n    print(f'g={g:.2f}')\n    model_params = dict(l=2, j=1.0, g=g, bc_mps='infinite', conserve=none)\n    m = tfichain(model_params)\n    product_state = ['up'] * m.lat.n_sites\n    psi = mps.from_product_state(\n        m.lat.mps_sites(), product_state, bc=m.lat.bc_mps, unit_cell_width=m.lat.mps_unit_cell_width\n    )\n    tebd_params = {\n        'order': 2,\n        'delta_tau_list': [0.1, 0.01, 0.001, 1.0e-4, 1.0e-5],\n        'n_steps': 10,\n        'max_error_e': 1.0e-8,\n        'trunc_params': {'chi_max': 30, 'svd_min': 1.0e-10},\n    }\n    eng = tebd.tebdengine(psi, m, tebd_params)\n    eng.run_gs()  # the main work...\n    e = np.mean(m.bond_energies(psi))  # m.bond_energies() works only a for nearestneighbormodel\n    # alternative: directly measure e2 = np.mean(psi.expectation_value(m.h_bond))\n    print(f'e (per site) = {e:.13f}')\n    print('final bond dimensions: ', psi.chi)\n    mag_x = np.mean(psi.expectation_value('sigmax'))\n    mag_z = np.mean(psi.expectation_value('sigmaz'))\n    print(f'<sigma_x> = {mag_x:.5f}')\n    print(f'<sigma_z> = {mag_z:.5f}')\n    print('correlation length:', psi.correlation_length())\n    # compare to exact result\n    from tfi_exact import infinite_gs_energy\n\n    e_exact = infinite_gs_energy(1.0, g)\n    print(f'analytic result: e (per site) = {e_exact:.13f}')\n    print('relative error: ', abs((e - e_exact) / e_exact))\n    return e, psi, m\n\n\ndef example_tebd_tf_ising_lightcone(l, g, tmax, dt):\n    print('finite tebd, real time evolution')\n    print(f'l={l:d}, g={g:.2f}, tmax={tmax:.2f}, dt={dt:.3f}')\n    # find ground state with tebd or dmrg\n    #  e, psi, m = example_tebd_gs_tf_ising_finite(l, g)\n    from d_dmrg import example_dmrg_tf_ising_finite\n\n    print('(run dmrg to get the groundstate)')\n    e, psi, m = example_dmrg_tf_ising_finite(l, g)\n    print('(dmrg finished)')\n    i0 = l // 2\n    # apply sigmaz on site i0\n    psi.apply_local_op(i0, 'sigmaz', unitary=true)\n    dt_measure = 0.05\n    # tebd.tebdengine makes 'n_steps' steps of `dt` at once;\n    # for second order this is more efficient.\n    tebd_params = {\n        'order': 2,\n        'dt': dt,\n        'n_steps': int(dt_measure / dt + 0.5),\n        'trunc_params': {'chi_max': 50, 'svd_min': 1.0e-10, 'trunc_cut': none},\n    }\n    eng = tebd.tebdengine(psi, m, tebd_params)\n    s = [psi.entanglement_entropy()]\n    for n in range(int(tmax / dt_measure + 0.5)):\n        eng.run()\n        s.append(psi.entanglement_entropy())\n\n        s[::-1],\n        vmin=0.0,\n        aspect='auto',\n        interpolation='nearest',\n        extent=(0, l - 1.0, -0.5 * dt_measure, eng.evolved_time + 0.5 * dt_measure),\n    )\n    filename = f'c_tebd_lightcone_{g:.2f}.pdf'\n    print('saved ' + filename)\n\n\ndef example_tebd_gs_tf_ising_next_nearest_neighbor(l, g, jp):\n    from tenpy.models.model import nearestneighbormodel\n    from tenpy.models.spins_nnn import spinchainnnn2\n\n    print('finite tebd, imaginary time evolution, transverse field ising next-nearest neighbor')\n    print(f'l={l:d}, g={g:.2f}, jp={jp:.2f}')\n    model_params = dict(\n        l=l,\n        jx=1.0,\n        jy=0.0,\n        jz=0.0,\n        jxp=jp,\n        jyp=0.0,\n        jzp=0.0,\n        hz=g,\n        bc_mps='finite',\n        conserve=none,\n    )\n    # we start with the non-grouped sites, but next-nearest neighbor interactions, building the mpo\n    m = spinchainnnn2(model_params)\n    product_state = ['up'] * m.lat.n_sites\n    psi = mps.from_product_state(\n        m.lat.mps_sites(), product_state, bc=m.lat.bc_mps, unit_cell_width=m.lat.mps_unit_cell_width\n    )\n\n    # now we group each to sites ...\n    psi.group_sites(n=2)  # ... in the state\n    m.group_sites(n=2)  # ... and model\n    # now, m has only 'nearest-neighbor' interactions with respect to the grouped sites\n    # thus, we can convert the mpo into h_bond terms:\n    m_nn = nearestneighbormodel.from_mpomodel(m)  # hence, we can initialize h_bond from the mpo\n\n    # now, we continue to run tebd as before\n    tebd_params = {\n        'order': 2,\n        'delta_tau_list': [0.1, 0.01, 0.001, 1.0e-4, 1.0e-5],\n        'n_steps': 10,\n        'max_error_e': 1.0e-6,\n        'trunc_params': {'chi_max': 30, 'svd_min': 1.0e-10},\n    }\n    eng = tebd.tebdengine(psi, m_nn, tebd_params)  # use m_nn and grouped psi\n    eng.run_gs()  # the main work...\n\n    # expectation values:\n    e = np.sum(m_nn.bond_energies(psi))  # bond_energies() works only a for nearestneighbormodel\n    print(f'e = {e:.13f}')\n    print('final bond dimensions: ', psi.chi)\n    # we can split the sites of the state again for an easier evaluation of expectation values\n    psi.group_split()\n    mag_x = 2.0 * np.sum(psi.expectation_value('sx'))  # factor of 2 for sx vs sigmax\n    mag_z = 2.0 * np.sum(psi.expectation_value('sz'))\n    print(f'magnetization in x = {mag_x:.5f}')\n    print(f'magnetization in z = {mag_z:.5f}')\n    return e, psi, m\n\n\nif __name__ == '__main__':\n    import logging\n\n    logging.basicconfig(level=logging.info)\n    example_tebd_gs_tf_ising_finite(l=10, g=1.0)\n    print('=' * 100, '', '', '=' * 100, sep='\\n')\n    example_tebd_gs_tf_ising_infinite(g=1.5)\n    print('=' * 100, '', '', '=' * 100, sep='\\n')\n    example_tebd_tf_ising_lightcone(l=20, g=1.5, tmax=3.0, dt=0.01)\n    print('=' * 100, '', '', '=' * 100, sep='\\n')\n    example_tebd_gs_tf_ising_next_nearest_neighbor(l=10, g=1.0, jp=0.1) example c tebd",
    "tokens": 2399
  },
  {
    "category": "examples",
    "name": "example.a_np_conserved",
    "content": "# Example Source: a_np_conserved.py\n\"\"\"An example code to demonstrate the usage of :class:`~tenpy.linalg.np_conserved.Array`.\n\nThis example includes the following steps:\n1) create Arrays for an Neel MPS\n2) create an MPO representing the nearest-neighbour AFM Heisenberg Hamiltonian\n3) define 'environments' left and right\n4) contract MPS and MPO to calculate the energy\n5) extract two-site hamiltonian ``H2`` from the MPO\n6) calculate ``exp(-1.j*dt*H2)`` by diagonalization of H2\n7) apply ``exp(H2)`` to two sites of the MPS and truncate with svd\n\nNote that this example uses only np_conserved, but no other modules.\nCompare it to the example `b_mps.py`,\nwhich does the same steps using a few predefined classes like MPS and MPO.\n\"\"\"\n# Copyright (C) TeNPy Developers, Apache license\n\nimport numpy as np\n\nimport tenpy.linalg.np_conserved as npc\n\n# model parameters\nJxx, Jz = 1.0, 1.0\nL = 20\ndt = 0.1\ncutoff = 1.0e-10\nprint(f'Jxx={Jxx}, Jz={Jz}, L={L:d}')\n\nprint('1) create Arrays for an Neel MPS')\n\n#  vL ->--B-->- vR\n#         |\n#         ^\n#         |\n#         p\n\n# create a ChargeInfo to specify the nature of the charge\nchinfo = npc.ChargeInfo([1], ['2*Sz'])  # the second argument is just a descriptive name\n\n# create LegCharges on physical leg and even/odd bonds\np_leg = npc.LegCharge.from_qflat(chinfo, [[1], [-1]])  # charges for up, down\nv_leg_even = npc.LegCharge.from_qflat(chinfo, [[0]])\nv_leg_odd = npc.LegCharge.from_qflat(chinfo, [[1]])\n\nB_even = npc.zeros([v_leg_even, v_leg_odd.conj(), p_leg], labels=['vL', 'vR', 'p'])  # virtual left/right, physical\nB_odd = npc.zeros([v_leg_odd, v_leg_even.conj(), p_leg], labels=['vL', 'vR', 'p'])\nB_even[0, 0, 0] = 1.0  # up\nB_odd[0, 0, 1] = 1.0  # down\n\nBs = [B_even, B_odd] * (L // 2) + [B_even] * (L % 2)  # (right-canonical)\nSs = [np.ones(1)] * L  # Ss[i] are singular values between Bs[i-1] and Bs[i]\n\n# Side remark:\n# An MPS is expected to have non-zero entries everywhere compatible with the charges.\n# In general, we recommend to use `sort_legcharge` (or `as_completely_blocked`)\n# to ensure complete blocking. (But the code will also work, if you don't do it.)\n# The drawback is that this might introduce permutations in the indices of single legs,\n# which you have to keep in mind when converting dense numpy arrays to and from npc.Arrays.\n\nprint('2) create an MPO representing the AFM Heisenberg Hamiltonian')\n\n#         p*\n#         |\n#         ^\n#         |\n#  wL ->--W-->- wR\n#         |\n#         ^\n#         |\n#         p\n\n# create physical spin-1/2 operators Sz, S+, S-\nSz = npc.Array.from_ndarray([[0.5, 0.0], [0.0, -0.5]], [p_leg, p_leg.conj()], labels=['p', 'p*'])\nSp = npc.Array.from_ndarray([[0.0, 1.0], [0.0, 0.0]], [p_leg, p_leg.conj()], labels=['p', 'p*'])\nSm = npc.Array.from_ndarray([[0.0, 0.0], [1.0, 0.0]], [p_leg, p_leg.conj()], labels=['p', 'p*'])\nId = npc.eye_like(Sz, labels=Sz.get_leg_labels())  # identity\n\nmpo_leg = npc.LegCharge.from_qflat(chinfo, [[0], [2], [-2], [0], [0]])\n\nW_grid = [[Id,   Sp,   Sm,   Sz,   None          ],\n          [None, None, None, None, 0.5 * Jxx * Sm],\n          [None, None, None, None, 0.5 * Jxx * Sp],\n          [None, None, None, None, Jz * Sz       ],\n          [None, None, None, None, Id            ]]  # fmt: skip\n\nW = npc.grid_outer(W_grid, [mpo_leg, mpo_leg.conj()], grid_labels=['wL', 'wR'])\n# wL/wR = virtual left/right of the MPO\nWs = [W] * L\n\nprint(\"3) define 'environments' left and right\")\n\n#  .---->- vR     vL ->----.\n#  |                       |\n#  envL->- wR     wL ->-envR\n#  |                       |\n#  .---->- vR*    vL*->----.\n\nenvL = npc.zeros([W.get_leg('wL').conj(), Bs[0].get_leg('vL').conj(), Bs[0].get_leg('vL')], labels=['wR', 'vR', 'vR*'])\nenvL[0, :, :] = npc.diag(1.0, envL.legs[1])\nenvR = npc.zeros(\n    [W.get_leg('wR').conj(), Bs[-1].get_leg('vR').conj(), Bs[-1].get_leg('vR')], labels=['wL', 'vL', 'vL*']\n)\nenvR[-1, :, :] = npc.diag(1.0, envR.legs[1])\n\nprint('4) contract MPS and MPO to calculate the energy <psi|H|psi>')\ncontr = envL\nfor i in range(L):\n    # contr labels: wR, vR, vR*\n    contr = npc.tensordot(contr, Bs[i], axes=('vR', 'vL'))\n    # wR, vR*, vR, p\n    contr = npc.tensordot(contr, Ws[i], axes=(['p', 'wR'], ['p*', 'wL']))\n    # vR*, vR, wR, p\n    contr = npc.tensordot(contr, Bs[i].conj(), axes=(['p', 'vR*'], ['p*', 'vL*']))\n    # vR, wR, vR*\n    # note that the order of the legs changed, but that's no problem with labels:\n    # the arrays are automatically transposed as necessary\nE = npc.inner(contr, envR, axes=(['vR', 'wR', 'vR*'], ['vL', 'wL', 'vL*']))\nprint('E =', E)\n\nprint('5) calculate two-site hamiltonian ``H2`` from the MPO')\n# label left, right physical legs with p, q\nW0 = W.replace_labels(['p', 'p*'], ['p0', 'p0*'])\nW1 = W.replace_labels(['p', 'p*'], ['p1', 'p1*'])\nH2 = npc.tensordot(W0, W1, axes=('wR', 'wL')).itranspose(['wL', 'wR', 'p0', 'p1', 'p0*', 'p1*'])\nH2 = H2[0, -1]  # (If H has single-site terms, it's not that simple anymore)\nprint('H2 labels:', H2.get_leg_labels())\n\nprint('6) calculate exp(H2) by diagonalization of H2')\n# diagonalization requires to view H2 as a matrix\nH2 = H2.combine_legs([('p0', 'p1'), ('p0*', 'p1*')], qconj=[+1, -1])\nprint('labels after combine_legs:', H2.get_leg_labels())\nE2, U2 = npc.eigh(H2)\nprint('Eigenvalues of H2:', E2)\nU_expE2 = U2.scale_axis(np.exp(-1.0j * dt * E2), axis=1)  # scale_axis ~= apply an diagonal matrix\nexp_H2 = npc.tensordot(U_expE2, U2.conj(), axes=(1, 1))\nexp_H2.iset_leg_labels(H2.get_leg_labels())\nexp_H2 = exp_H2.split_legs()  # by default split all legs which are `LegPipe`\n# (this restores the originial labels ['p0', 'p1', 'p0*', 'p1*'] of `H2` in `exp_H2`)\n\nprint('7) apply exp(H2) to even/odd bonds of the MPS and truncate with svd')\n# (this implements one time step of first order TEBD)\nfor even_odd in [0, 1]:\n    for i in range(even_odd, L - 1, 2):\n        B_L = Bs[i].scale_axis(Ss[i], 'vL').ireplace_label('p', 'p0')\n        B_R = Bs[i + 1].replace_label('p', 'p1')\n        theta = npc.tensordot(B_L, B_R, axes=('vR', 'vL'))\n        theta = npc.tensordot(exp_H2, theta, axes=(['p0*', 'p1*'], ['p0', 'p1']))\n        # view as matrix for SVD\n        theta = theta.combine_legs([('vL', 'p0'), ('p1', 'vR')], new_axes=[0, 1], qconj=[+1, -1])\n        # now theta has labels '(vL.p0)', '(p1.vR)'\n        U, S, V = npc.svd(theta, inner_labels=['vR', 'vL'])\n        # truncate\n        keep = S > cutoff\n        S = S[keep]\n        invsq = np.linalg.norm(S)\n        Ss[i + 1] = S / invsq\n        U = U.iscale_axis(S / invsq, 'vR')\n        Bs[i] = U.split_legs('(vL.p0)').iscale_axis(Ss[i] ** (-1), 'vL').ireplace_label('p0', 'p')\n        Bs[i + 1] = V.split_legs('(p1.vR)').ireplace_label('p1', 'p')\nprint('finished')",
    "search_text": "example.a_np_conserved # example source: a_np_conserved.py\n\"\"\"an example code to demonstrate the usage of :class:`~tenpy.linalg.np_conserved.array`.\n\nthis example includes the following steps:\n1) create arrays for an neel mps\n2) create an mpo representing the nearest-neighbour afm heisenberg hamiltonian\n3) define 'environments' left and right\n4) contract mps and mpo to calculate the energy\n5) extract two-site hamiltonian ``h2`` from the mpo\n6) calculate ``exp(-1.j*dt*h2)`` by diagonalization of h2\n7) apply ``exp(h2)`` to two sites of the mps and truncate with svd\n\nnote that this example uses only np_conserved, but no other modules.\ncompare it to the example `b_mps.py`,\nwhich does the same steps using a few predefined classes like mps and mpo.\n\"\"\"\n# copyright (c) tenpy developers, apache license\n\nimport numpy as np\n\nimport tenpy.linalg.np_conserved as npc\n\n# model parameters\njxx, jz = 1.0, 1.0\nl = 20\ndt = 0.1\ncutoff = 1.0e-10\nprint(f'jxx={jxx}, jz={jz}, l={l:d}')\n\nprint('1) create arrays for an neel mps')\n\n#  vl ->--b-->- vr\n#         |\n#         ^\n#         |\n#         p\n\n# create a chargeinfo to specify the nature of the charge\nchinfo = npc.chargeinfo([1], ['2*sz'])  # the second argument is just a descriptive name\n\n# create legcharges on physical leg and even/odd bonds\np_leg = npc.legcharge.from_qflat(chinfo, [[1], [-1]])  # charges for up, down\nv_leg_even = npc.legcharge.from_qflat(chinfo, [[0]])\nv_leg_odd = npc.legcharge.from_qflat(chinfo, [[1]])\n\nb_even = npc.zeros([v_leg_even, v_leg_odd.conj(), p_leg], labels=['vl', 'vr', 'p'])  # virtual left/right, physical\nb_odd = npc.zeros([v_leg_odd, v_leg_even.conj(), p_leg], labels=['vl', 'vr', 'p'])\nb_even[0, 0, 0] = 1.0  # up\nb_odd[0, 0, 1] = 1.0  # down\n\nbs = [b_even, b_odd] * (l // 2) + [b_even] * (l % 2)  # (right-canonical)\nss = [np.ones(1)] * l  # ss[i] are singular values between bs[i-1] and bs[i]\n\n# side remark:\n# an mps is expected to have non-zero entries everywhere compatible with the charges.\n# in general, we recommend to use `sort_legcharge` (or `as_completely_blocked`)\n# to ensure complete blocking. (but the code will also work, if you don't do it.)\n# the drawback is that this might introduce permutations in the indices of single legs,\n# which you have to keep in mind when converting dense numpy arrays to and from npc.arrays.\n\nprint('2) create an mpo representing the afm heisenberg hamiltonian')\n\n#         p*\n#         |\n#         ^\n#         |\n#  wl ->--w-->- wr\n#         |\n#         ^\n#         |\n#         p\n\n# create physical spin-1/2 operators sz, s+, s-\nsz = npc.array.from_ndarray([[0.5, 0.0], [0.0, -0.5]], [p_leg, p_leg.conj()], labels=['p', 'p*'])\nsp = npc.array.from_ndarray([[0.0, 1.0], [0.0, 0.0]], [p_leg, p_leg.conj()], labels=['p', 'p*'])\nsm = npc.array.from_ndarray([[0.0, 0.0], [1.0, 0.0]], [p_leg, p_leg.conj()], labels=['p', 'p*'])\nid = npc.eye_like(sz, labels=sz.get_leg_labels())  # identity\n\nmpo_leg = npc.legcharge.from_qflat(chinfo, [[0], [2], [-2], [0], [0]])\n\nw_grid = [[id,   sp,   sm,   sz,   none          ],\n          [none, none, none, none, 0.5 * jxx * sm],\n          [none, none, none, none, 0.5 * jxx * sp],\n          [none, none, none, none, jz * sz       ],\n          [none, none, none, none, id            ]]  # fmt: skip\n\nw = npc.grid_outer(w_grid, [mpo_leg, mpo_leg.conj()], grid_labels=['wl', 'wr'])\n# wl/wr = virtual left/right of the mpo\nws = [w] * l\n\nprint(\"3) define 'environments' left and right\")\n\n#  .---->- vr     vl ->----.\n#  |                       |\n#  envl->- wr     wl ->-envr\n#  |                       |\n#  .---->- vr*    vl*->----.\n\nenvl = npc.zeros([w.get_leg('wl').conj(), bs[0].get_leg('vl').conj(), bs[0].get_leg('vl')], labels=['wr', 'vr', 'vr*'])\nenvl[0, :, :] = npc.diag(1.0, envl.legs[1])\nenvr = npc.zeros(\n    [w.get_leg('wr').conj(), bs[-1].get_leg('vr').conj(), bs[-1].get_leg('vr')], labels=['wl', 'vl', 'vl*']\n)\nenvr[-1, :, :] = npc.diag(1.0, envr.legs[1])\n\nprint('4) contract mps and mpo to calculate the energy <psi|h|psi>')\ncontr = envl\nfor i in range(l):\n    # contr labels: wr, vr, vr*\n    contr = npc.tensordot(contr, bs[i], axes=('vr', 'vl'))\n    # wr, vr*, vr, p\n    contr = npc.tensordot(contr, ws[i], axes=(['p', 'wr'], ['p*', 'wl']))\n    # vr*, vr, wr, p\n    contr = npc.tensordot(contr, bs[i].conj(), axes=(['p', 'vr*'], ['p*', 'vl*']))\n    # vr, wr, vr*\n    # note that the order of the legs changed, but that's no problem with labels:\n    # the arrays are automatically transposed as necessary\ne = npc.inner(contr, envr, axes=(['vr', 'wr', 'vr*'], ['vl', 'wl', 'vl*']))\nprint('e =', e)\n\nprint('5) calculate two-site hamiltonian ``h2`` from the mpo')\n# label left, right physical legs with p, q\nw0 = w.replace_labels(['p', 'p*'], ['p0', 'p0*'])\nw1 = w.replace_labels(['p', 'p*'], ['p1', 'p1*'])\nh2 = npc.tensordot(w0, w1, axes=('wr', 'wl')).itranspose(['wl', 'wr', 'p0', 'p1', 'p0*', 'p1*'])\nh2 = h2[0, -1]  # (if h has single-site terms, it's not that simple anymore)\nprint('h2 labels:', h2.get_leg_labels())\n\nprint('6) calculate exp(h2) by diagonalization of h2')\n# diagonalization requires to view h2 as a matrix\nh2 = h2.combine_legs([('p0', 'p1'), ('p0*', 'p1*')], qconj=[+1, -1])\nprint('labels after combine_legs:', h2.get_leg_labels())\ne2, u2 = npc.eigh(h2)\nprint('eigenvalues of h2:', e2)\nu_expe2 = u2.scale_axis(np.exp(-1.0j * dt * e2), axis=1)  # scale_axis ~= apply an diagonal matrix\nexp_h2 = npc.tensordot(u_expe2, u2.conj(), axes=(1, 1))\nexp_h2.iset_leg_labels(h2.get_leg_labels())\nexp_h2 = exp_h2.split_legs()  # by default split all legs which are `legpipe`\n# (this restores the originial labels ['p0', 'p1', 'p0*', 'p1*'] of `h2` in `exp_h2`)\n\nprint('7) apply exp(h2) to even/odd bonds of the mps and truncate with svd')\n# (this implements one time step of first order tebd)\nfor even_odd in [0, 1]:\n    for i in range(even_odd, l - 1, 2):\n        b_l = bs[i].scale_axis(ss[i], 'vl').ireplace_label('p', 'p0')\n        b_r = bs[i + 1].replace_label('p', 'p1')\n        theta = npc.tensordot(b_l, b_r, axes=('vr', 'vl'))\n        theta = npc.tensordot(exp_h2, theta, axes=(['p0*', 'p1*'], ['p0', 'p1']))\n        # view as matrix for svd\n        theta = theta.combine_legs([('vl', 'p0'), ('p1', 'vr')], new_axes=[0, 1], qconj=[+1, -1])\n        # now theta has labels '(vl.p0)', '(p1.vr)'\n        u, s, v = npc.svd(theta, inner_labels=['vr', 'vl'])\n        # truncate\n        keep = s > cutoff\n        s = s[keep]\n        invsq = np.linalg.norm(s)\n        ss[i + 1] = s / invsq\n        u = u.iscale_axis(s / invsq, 'vr')\n        bs[i] = u.split_legs('(vl.p0)').iscale_axis(ss[i] ** (-1), 'vl').ireplace_label('p0', 'p')\n        bs[i + 1] = v.split_legs('(p1.vr)').ireplace_label('p1', 'p')\nprint('finished') example a np conserved",
    "tokens": 2351
  },
  {
    "category": "examples",
    "name": "example.v1_publication_tfi_cylinder",
    "content": "# Example Source: tfi_cylinder.py\n\"\"\"An example determining the phase diagram of the 2D transverse field Ising model.\"\"\"\n\n# Copyright (C) TeNPy Developers, Apache license\nimport argparse\nimport os\nimport pickle\n\nimport numpy as np\n\n#\nimport tenpy\n\n\ndef main():\n    \"\"\"Main function that is executed if this script is called.\"\"\"\n    tenpy.show_config()\n\n    # arg-parsing\n    parser = argparse.ArgumentParser(\n        description='Runs a phase diagrams sweep for the TFIM, i.e. DMRG for a grid of values g.'\n    )\n    parser.add_argument(\n        '--plot',\n        metavar='FOLDER',\n        type=str,\n        default=None,\n        help='Plot results in the given folder instead of running the simulation',\n    )\n    parser.add_argument(\n        '-o', type=str, default=None, help='Folder for output. Defaults to a subfolder of playground in the repo root.'\n    )\n    parser.add_argument('--conserve', type=str, default='None', help='What should be conserved')\n    parser.add_argument('--chi', type=int, default=8, help='Bond dimension')\n    parser.add_argument('--Ly', type=int, default=4, help='Cylinder circumference')\n    parser.add_argument(\n        '--num_g_points', type=int, default=101, help='Resolution of the phase diagram. Recommend round number plus 1.'\n    )\n    args = parser.parse_args()\n\n    if args.plot:\n        make_plot(folder=args.plot)\n        return\n\n    outfolder = args.o\n    # default outfolder\n    if outfolder is None:\n        # use /path/to/repo_root/playground/tfi_cylinder\n        package_folder = os.path.dirname(tenpy.__file__)  # parent folder of tenpy/__init__.py\n        repo_root = os.path.abspath(os.path.join(package_folder, os.pardir))\n        playground = os.path.join(repo_root, 'playground')\n        assert os.path.exists(playground), 'Need to clone the github repo for default outfolder behavior.'\n        outfolder = os.path.join(playground, 'tfi_cylinder')\n        if not os.path.exists(outfolder):\n            os.mkdir(outfolder)\n\n    g_list = np.linspace(2, 4, args.num_g_points, endpoint=True)\n    logfile = os.path.join(outfolder, f'tfi_2D_conserve_{args.conserve}_Ly_{args.Ly}_chi_{args.chi}.log')\n    file = os.path.join(outfolder, f'tfi_2D_conserve_{args.conserve}_Ly_{args.Ly}_chi_{args.chi}.pkl')\n    tenpy.setup_logging(filename=logfile, to_stdout='ERROR', to_file='INFO')\n\n    res = sweep_phase_diagram(g_list, conserve=args.conserve, chi=args.chi, Ly=args.Ly)\n\n    with open(file, 'wb') as f:\n        pickle.dump(res, f)\n    print(f'Wrote results to {file}')\n\n\ndef sweep_phase_diagram(g_list, conserve, chi: int, Ly: int):\n    \"\"\"Perform a sweep through the phase diagram.\n\n    Do DMRG at each g point, than use the resulting state as an initial guess for the next g.\n\n    Parameters\n    ----------\n    g_list : iterable of float\n        A grid of g values to simulate at\n    conserve : {'best', 'None'}\n        What symmetry to conserve, if any\n    chi : int\n        The maximum bond dimension.\n    Ly : int\n        The cylinder circumference\n\n    Returns\n    -------\n    A dictionary with the parameters repeated and with observables.\n\n    \"\"\"\n    psi = None\n    g_list = g_list\n    energy_list = []\n    entropies = []\n    mag_z_list = []\n    mag_x_list = []\n    corr_xx_list = []\n    corr_length_list = []\n\n    for g in g_list:\n        print(f'Optimizing at {g=}...')\n        # re-use the psi from the previous g as initial guess\n        psi, energy, entropy, mag_z, mag_x, corr_xx, corr_length = single_run(\n            g, Ly, conserve=conserve, chi_max=chi, psi=psi\n        )\n        energy_list.append(energy)\n        entropies.append(entropy)\n        mag_z_list.append(mag_z)\n        mag_x_list.append(mag_x)\n        corr_xx_list.append(corr_xx)\n        corr_length_list.append(corr_length)\n\n    return dict(\n        g_list=g_list,\n        chi=chi,\n        Ly=Ly,\n        conserve=conserve,\n        energy_list=energy_list,\n        entropies=entropies,\n        mag_z_list=mag_z_list,\n        mag_x_list=mag_x_list,\n        corr_xx_list=corr_xx_list,\n        corr_length_list=corr_length_list,\n    )\n\n\ndef single_run(g: float, Ly: int, conserve, chi_max: int, psi=None):\n    \"\"\"Perform a single DMRG run, at a single point in the phase diagram.\n\n    Parameters\n    ----------\n    g : float\n        The model parameter.\n    conserve : {'best', 'None'}\n        What symmetry to conserve, if any\n    chi_max : int\n        The maximum bond dimension.\n    Ly : int\n        The cylinder circumference\n    psi : MPS, optional\n        An initial guess\n\n    Returns\n    -------\n    psi : MPS\n        The groundstate approximation\n    energy : float\n        Its energy\n    entropy : float\n        Its bipartite von Neumann entanglement entropy for a cut between unit cells.\n    mag_z, mag_x : float\n        magnetization in z and x directions respectively, averaged over a unit cell.\n    corr_xx : float\n        Correlation function over a horizontal distance of 10 unit cells\n    correlation_length : float\n        The correlation length of the MPS in units of horizontal lattice sites.\n\n    \"\"\"\n    # 2) Initialize the model\n    # For a full list of options see\n    # https://tenpy.readthedocs.io/en/latest/reference/tenpy.models.spins.SpinModel.html\n    model_params = dict(\n        lattice='Square',  # select the lattice from predefined classes in tenpy.models.lattice\n        bc_y='cylinder',  # y boundary conditions: infinite cylinder\n        bc_MPS='infinite',  # use iMPS, fixes x boundary conditions\n        J=1,\n        g=g,\n        Lx=2,  # size in x direction *of a unit cell*, system is infinite in x direction\n        Ly=Ly,  # size in y direction, i.e. circumference of the cylinder\n        conserve=conserve,  # 'best' or None\n    )\n    model = tenpy.TFIModel(model_params)\n\n    # 3) Initialize an MPS (initial guess). Note that this selects the charge sector.\n    if psi is None:\n        psi = tenpy.MPS.from_lat_product_state(model.lat, [[['up'], ['down']]])\n\n    # 4) Initialize / Configure the DMRG engine\n    # For a full list of options see\n    # https://tenpy.readthedocs.io/en/latest/reference/tenpy.algorithms.dmrg.TwoSiteDMRGEngine.html\n    dmrg_params = dict(\n        mixer=True,  # enable the mixer\n        trunc_params=dict(\n            chi_max=chi_max,  # maximum bond dimension\n            svd_min=1e-10,  # threshold for discarding small singular values\n        ),\n        combine=True,\n        min_sweeps=10,\n    )\n    engine = tenpy.TwoSiteDMRGEngine(psi, model, dmrg_params)\n\n    # 5) Run DMRG\n    energy, psi = engine.run()\n\n    # 6) Extract observables\n    mag_z = np.average(psi.expectation_value('Sigmaz'))\n    mag_x = np.average(psi.expectation_value('Sigmax'))\n    corr_xx = psi.correlation_function('Sigmax', 'Sigmax', [0], [10 * model.lat.N_sites]).item()\n    # See note in MPS.correlation_length for the units and why we need to divide\n    correlation_length = psi.correlation_length() / model.lat.N_sites_per_ring\n    entropy = psi.entanglement_entropy()[0]\n\n    return psi, energy, entropy, mag_z, mag_x, corr_xx, correlation_length\n\n\ndef make_plot(folder):\n    \"\"\"Make the production plots.\n\n    Expect multiple ``.pkl`` files generated by :func:`sweep_phase_diagram` in the `folder`.\n    \"\"\"\n    print()\n\n    results_None = {}\n    results_best = {}\n    for fn in os.listdir(folder):\n        if not str(fn).startswith('tfi_2D'):\n            continue\n        if not str(fn).endswith('.pkl'):\n            continue\n        _, rest = fn.split('tfi_2D_conserve_')\n        conserve, rest = rest.split('_Ly_')\n        Ly, rest = rest.split('_chi_')\n        chi, _ = rest.split('.pkl')\n        Ly = int(Ly)\n        chi = int(chi)\n        with open(os.path.join(folder, fn), 'rb') as f:\n            res = pickle.load(f)\n        if conserve == 'best':\n            results_best[Ly, chi] = res\n        else:\n            assert conserve == 'None'\n            results_None[Ly, chi] = res\n\n\n    linewidth = 5.90666\n    mpl.rcParams.update({'font.size': 10})\n    mpl.rcParams.update({'legend.fontsize': 8})\n    mpl.rcParams.update({'legend.title_fontsize': 8})\n\n    for conserve, results in zip(['best', 'None'], [results_best, results_None]):\n        _g_lists = [res['g_list'] for res in results.values()]\n        g_list = _g_lists[0]\n        for other in _g_lists[1:]:\n            assert np.allclose(other, g_list)\n\n        fig_width = linewidth\n        aspect = 0.7\n        for ax in axs[1]:\n            ax.set_xlabel('$g/J$')\n            ax.set_xlim(min(g_list), max(g_list))\n\n        # define line styles\n        min_chi = 2\n        max_chi = 500\n        plot_styles = {\n            (Ly, chi): dict(\n                label=f'${Ly},~{chi}$',\n                color=mpl.colormaps['Reds' if Ly == 8 else 'Blues'](np.log(chi / min_chi) / np.log(max_chi / min_chi)),\n                ls={20: '-', 50: '--', 200: '-.'}[chi],\n                lw={4: 1.5, 8: 2}[Ly],\n            )\n            for Ly, chi in results\n        }  # plot_styles[Ly, chi] == kwargs_for_plot_function\n\n        sorted_keys = [(Ly, chi) for Ly, chi in sorted(results.keys()) if Ly != 6]\n\n        # subplot: <Z> magnetization\n        axs[0, 0].set_ylabel(r'$\\langle \\sigma^z \\rangle$')\n        for key in sorted_keys:\n            axs[0, 0].plot(g_list, results[key]['mag_z_list'], **plot_styles[key])\n\n        # subplot: S_vN entropy\n        axs[0, 1].set_ylabel(r'$S_{\\text{vN}} ~/~ \\mathrm{log} 2$')\n        for key in sorted_keys:\n            axs[0, 1].plot(g_list, results[key]['entropies'] / np.log(2), **plot_styles[key])\n\n        # subplot: <X> magnetization\n        axs[1, 0].set_ylabel(r'$\\langle \\sigma^x \\rangle$')\n        for key in sorted_keys:\n            axs[1, 0].plot(g_list, np.abs(results[key]['mag_x_list']), **plot_styles[key])\n\n        # subplot: <XX> correlations\n        axs[1, 1].set_ylabel(r'$\\langle \\sigma^x_i \\sigma^x_j \\rangle$')\n        for key in sorted_keys:\n            axs[1, 1].plot(g_list, results[key]['corr_xx_list'], **plot_styles[key])\n\n        axs[1, 1].legend(title=('     $L_y,~\\\\chi$'))\n        fig.suptitle(f'conserve=\"{conserve}\"', y=1.02)\n        fig.tight_layout(pad=0.1)\n        file = os.path.join(folder, f'dmrg_conserve_{conserve}.pdf')\n        print(f'saved plot to {file}')\n\n\nif __name__ == '__main__':\n    main()",
    "search_text": "example.v1_publication_tfi_cylinder # example source: tfi_cylinder.py\n\"\"\"an example determining the phase diagram of the 2d transverse field ising model.\"\"\"\n\n# copyright (c) tenpy developers, apache license\nimport argparse\nimport os\nimport pickle\n\nimport numpy as np\n\n#\nimport tenpy\n\n\ndef main():\n    \"\"\"main function that is executed if this script is called.\"\"\"\n    tenpy.show_config()\n\n    # arg-parsing\n    parser = argparse.argumentparser(\n        description='runs a phase diagrams sweep for the tfim, i.e. dmrg for a grid of values g.'\n    )\n    parser.add_argument(\n        '--plot',\n        metavar='folder',\n        type=str,\n        default=none,\n        help='plot results in the given folder instead of running the simulation',\n    )\n    parser.add_argument(\n        '-o', type=str, default=none, help='folder for output. defaults to a subfolder of playground in the repo root.'\n    )\n    parser.add_argument('--conserve', type=str, default='none', help='what should be conserved')\n    parser.add_argument('--chi', type=int, default=8, help='bond dimension')\n    parser.add_argument('--ly', type=int, default=4, help='cylinder circumference')\n    parser.add_argument(\n        '--num_g_points', type=int, default=101, help='resolution of the phase diagram. recommend round number plus 1.'\n    )\n    args = parser.parse_args()\n\n    if args.plot:\n        make_plot(folder=args.plot)\n        return\n\n    outfolder = args.o\n    # default outfolder\n    if outfolder is none:\n        # use /path/to/repo_root/playground/tfi_cylinder\n        package_folder = os.path.dirname(tenpy.__file__)  # parent folder of tenpy/__init__.py\n        repo_root = os.path.abspath(os.path.join(package_folder, os.pardir))\n        playground = os.path.join(repo_root, 'playground')\n        assert os.path.exists(playground), 'need to clone the github repo for default outfolder behavior.'\n        outfolder = os.path.join(playground, 'tfi_cylinder')\n        if not os.path.exists(outfolder):\n            os.mkdir(outfolder)\n\n    g_list = np.linspace(2, 4, args.num_g_points, endpoint=true)\n    logfile = os.path.join(outfolder, f'tfi_2d_conserve_{args.conserve}_ly_{args.ly}_chi_{args.chi}.log')\n    file = os.path.join(outfolder, f'tfi_2d_conserve_{args.conserve}_ly_{args.ly}_chi_{args.chi}.pkl')\n    tenpy.setup_logging(filename=logfile, to_stdout='error', to_file='info')\n\n    res = sweep_phase_diagram(g_list, conserve=args.conserve, chi=args.chi, ly=args.ly)\n\n    with open(file, 'wb') as f:\n        pickle.dump(res, f)\n    print(f'wrote results to {file}')\n\n\ndef sweep_phase_diagram(g_list, conserve, chi: int, ly: int):\n    \"\"\"perform a sweep through the phase diagram.\n\n    do dmrg at each g point, than use the resulting state as an initial guess for the next g.\n\n    parameters\n    ----------\n    g_list : iterable of float\n        a grid of g values to simulate at\n    conserve : {'best', 'none'}\n        what symmetry to conserve, if any\n    chi : int\n        the maximum bond dimension.\n    ly : int\n        the cylinder circumference\n\n    returns\n    -------\n    a dictionary with the parameters repeated and with observables.\n\n    \"\"\"\n    psi = none\n    g_list = g_list\n    energy_list = []\n    entropies = []\n    mag_z_list = []\n    mag_x_list = []\n    corr_xx_list = []\n    corr_length_list = []\n\n    for g in g_list:\n        print(f'optimizing at {g=}...')\n        # re-use the psi from the previous g as initial guess\n        psi, energy, entropy, mag_z, mag_x, corr_xx, corr_length = single_run(\n            g, ly, conserve=conserve, chi_max=chi, psi=psi\n        )\n        energy_list.append(energy)\n        entropies.append(entropy)\n        mag_z_list.append(mag_z)\n        mag_x_list.append(mag_x)\n        corr_xx_list.append(corr_xx)\n        corr_length_list.append(corr_length)\n\n    return dict(\n        g_list=g_list,\n        chi=chi,\n        ly=ly,\n        conserve=conserve,\n        energy_list=energy_list,\n        entropies=entropies,\n        mag_z_list=mag_z_list,\n        mag_x_list=mag_x_list,\n        corr_xx_list=corr_xx_list,\n        corr_length_list=corr_length_list,\n    )\n\n\ndef single_run(g: float, ly: int, conserve, chi_max: int, psi=none):\n    \"\"\"perform a single dmrg run, at a single point in the phase diagram.\n\n    parameters\n    ----------\n    g : float\n        the model parameter.\n    conserve : {'best', 'none'}\n        what symmetry to conserve, if any\n    chi_max : int\n        the maximum bond dimension.\n    ly : int\n        the cylinder circumference\n    psi : mps, optional\n        an initial guess\n\n    returns\n    -------\n    psi : mps\n        the groundstate approximation\n    energy : float\n        its energy\n    entropy : float\n        its bipartite von neumann entanglement entropy for a cut between unit cells.\n    mag_z, mag_x : float\n        magnetization in z and x directions respectively, averaged over a unit cell.\n    corr_xx : float\n        correlation function over a horizontal distance of 10 unit cells\n    correlation_length : float\n        the correlation length of the mps in units of horizontal lattice sites.\n\n    \"\"\"\n    # 2) initialize the model\n    # for a full list of options see\n    # https://tenpy.readthedocs.io/en/latest/reference/tenpy.models.spins.spinmodel.html\n    model_params = dict(\n        lattice='square',  # select the lattice from predefined classes in tenpy.models.lattice\n        bc_y='cylinder',  # y boundary conditions: infinite cylinder\n        bc_mps='infinite',  # use imps, fixes x boundary conditions\n        j=1,\n        g=g,\n        lx=2,  # size in x direction *of a unit cell*, system is infinite in x direction\n        ly=ly,  # size in y direction, i.e. circumference of the cylinder\n        conserve=conserve,  # 'best' or none\n    )\n    model = tenpy.tfimodel(model_params)\n\n    # 3) initialize an mps (initial guess). note that this selects the charge sector.\n    if psi is none:\n        psi = tenpy.mps.from_lat_product_state(model.lat, [[['up'], ['down']]])\n\n    # 4) initialize / configure the dmrg engine\n    # for a full list of options see\n    # https://tenpy.readthedocs.io/en/latest/reference/tenpy.algorithms.dmrg.twositedmrgengine.html\n    dmrg_params = dict(\n        mixer=true,  # enable the mixer\n        trunc_params=dict(\n            chi_max=chi_max,  # maximum bond dimension\n            svd_min=1e-10,  # threshold for discarding small singular values\n        ),\n        combine=true,\n        min_sweeps=10,\n    )\n    engine = tenpy.twositedmrgengine(psi, model, dmrg_params)\n\n    # 5) run dmrg\n    energy, psi = engine.run()\n\n    # 6) extract observables\n    mag_z = np.average(psi.expectation_value('sigmaz'))\n    mag_x = np.average(psi.expectation_value('sigmax'))\n    corr_xx = psi.correlation_function('sigmax', 'sigmax', [0], [10 * model.lat.n_sites]).item()\n    # see note in mps.correlation_length for the units and why we need to divide\n    correlation_length = psi.correlation_length() / model.lat.n_sites_per_ring\n    entropy = psi.entanglement_entropy()[0]\n\n    return psi, energy, entropy, mag_z, mag_x, corr_xx, correlation_length\n\n\ndef make_plot(folder):\n    \"\"\"make the production plots.\n\n    expect multiple ``.pkl`` files generated by :func:`sweep_phase_diagram` in the `folder`.\n    \"\"\"\n    print()\n\n    results_none = {}\n    results_best = {}\n    for fn in os.listdir(folder):\n        if not str(fn).startswith('tfi_2d'):\n            continue\n        if not str(fn).endswith('.pkl'):\n            continue\n        _, rest = fn.split('tfi_2d_conserve_')\n        conserve, rest = rest.split('_ly_')\n        ly, rest = rest.split('_chi_')\n        chi, _ = rest.split('.pkl')\n        ly = int(ly)\n        chi = int(chi)\n        with open(os.path.join(folder, fn), 'rb') as f:\n            res = pickle.load(f)\n        if conserve == 'best':\n            results_best[ly, chi] = res\n        else:\n            assert conserve == 'none'\n            results_none[ly, chi] = res\n\n\n    linewidth = 5.90666\n    mpl.rcparams.update({'font.size': 10})\n    mpl.rcparams.update({'legend.fontsize': 8})\n    mpl.rcparams.update({'legend.title_fontsize': 8})\n\n    for conserve, results in zip(['best', 'none'], [results_best, results_none]):\n        _g_lists = [res['g_list'] for res in results.values()]\n        g_list = _g_lists[0]\n        for other in _g_lists[1:]:\n            assert np.allclose(other, g_list)\n\n        fig_width = linewidth\n        aspect = 0.7\n        for ax in axs[1]:\n            ax.set_xlabel('$g/j$')\n            ax.set_xlim(min(g_list), max(g_list))\n\n        # define line styles\n        min_chi = 2\n        max_chi = 500\n        plot_styles = {\n            (ly, chi): dict(\n                label=f'${ly},~{chi}$',\n                color=mpl.colormaps['reds' if ly == 8 else 'blues'](np.log(chi / min_chi) / np.log(max_chi / min_chi)),\n                ls={20: '-', 50: '--', 200: '-.'}[chi],\n                lw={4: 1.5, 8: 2}[ly],\n            )\n            for ly, chi in results\n        }  # plot_styles[ly, chi] == kwargs_for_plot_function\n\n        sorted_keys = [(ly, chi) for ly, chi in sorted(results.keys()) if ly != 6]\n\n        # subplot: <z> magnetization\n        axs[0, 0].set_ylabel(r'$\\langle \\sigma^z \\rangle$')\n        for key in sorted_keys:\n            axs[0, 0].plot(g_list, results[key]['mag_z_list'], **plot_styles[key])\n\n        # subplot: s_vn entropy\n        axs[0, 1].set_ylabel(r'$s_{\\text{vn}} ~/~ \\mathrm{log} 2$')\n        for key in sorted_keys:\n            axs[0, 1].plot(g_list, results[key]['entropies'] / np.log(2), **plot_styles[key])\n\n        # subplot: <x> magnetization\n        axs[1, 0].set_ylabel(r'$\\langle \\sigma^x \\rangle$')\n        for key in sorted_keys:\n            axs[1, 0].plot(g_list, np.abs(results[key]['mag_x_list']), **plot_styles[key])\n\n        # subplot: <xx> correlations\n        axs[1, 1].set_ylabel(r'$\\langle \\sigma^x_i \\sigma^x_j \\rangle$')\n        for key in sorted_keys:\n            axs[1, 1].plot(g_list, results[key]['corr_xx_list'], **plot_styles[key])\n\n        axs[1, 1].legend(title=('     $l_y,~\\\\chi$'))\n        fig.suptitle(f'conserve=\"{conserve}\"', y=1.02)\n        fig.tight_layout(pad=0.1)\n        file = os.path.join(folder, f'dmrg_conserve_{conserve}.pdf')\n        print(f'saved plot to {file}')\n\n\nif __name__ == '__main__':\n    main() example v1 publication tfi cylinder",
    "tokens": 2678
  },
  {
    "category": "examples",
    "name": "example.v1_publication_heisenberg_tebd",
    "content": "# Example Source: heisenberg_tebd.py\n\"\"\"An example simulating the dynamics of the Neel state under Heisenberg evolution, using TEBD.\"\"\"\n\n# Copyright (C) TeNPy Developers, Apache license\nimport argparse\nimport os\nimport pickle\n\nimport numpy as np\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\n\nimport tenpy\n\nmodel_params = dict(\n    L=50,\n    Jx=1,\n    Jy=1,\n    Jz=1,\n)\nmodel = tenpy.SpinChain(model_params)\n\nengine_params = dict(\n    order=2,\n    dt=0.02,\n    N_steps=5,\n    trunc_params=dict(\n        chi_max=None,  # to be set in loop\n        svd_min=1e-10,\n    ),\n)\ndt_measure = engine_params['dt'] * engine_params['N_steps']\n\n\ndef main():\n    parser = argparse.ArgumentParser(description='Either run simulation at fixed chi, or plot results.')\n    parser.add_argument('--chi', type=int, default=50, help='MPS bond dimension. Default 50.')\n    parser.add_argument('--outfolder', default='./', help='Folder to write results to. Default is CWD.')\n    parser.add_argument(\n        '--plot',\n        type=str,\n        metavar='FOLDER',\n        default=None,\n        help='Plot results in the given folder instead of running the simulation.',\n    )\n    args = parser.parse_args()\n\n    if args.plot is not None:\n        plot(folder=args.plot)\n        return\n\n    results = run(chi=args.chi)\n    with open(os.path.join(args.outfolder, f'heisenberg_tebd_chi_{args.chi}.pkl'), 'wb') as f:\n        pickle.dump(results, f)\n\n\ndef run(chi: int):\n    psi = tenpy.MPS.from_lat_product_state(model.lat, [['up'], ['down']])\n    # Selects Sz=0 sector\n\n    engine_params['trunc_params'].update(chi_max=chi)\n    engine = tenpy.TEBDEngine(psi, model, engine_params)\n    # engine = tenpy.TDVPEngine(psi, model, engine_params)\n\n    t = [0]\n    S = [psi.entanglement_entropy()]\n    mag_z = [psi.expectation_value('Sz')]\n    err = [0]\n\n    for n in range(200):\n        print(f'n={n}')\n        engine.run()\n        t.append(engine.evolved_time)\n        S.append(psi.entanglement_entropy())\n        mag_z.append(psi.expectation_value('Sz'))\n        err.append(engine.trunc_err.eps)\n\n    t = np.array(t)\n    S = np.array(S)\n    mag_z = np.array(mag_z)\n    err = np.array(err)\n    imbalance = (0.5 * np.average(mag_z[:, ::2] - mag_z[:, 1::2], axis=1),)\n    return dict(t=t, S=S, mag_z=mag_z, imbalance=imbalance, err=err, chi=chi)\n\n\ndef plot(folder):\n    outfile = os.path.join(folder, 'heisenberg_tebd.pdf')\n    results = {}\n    for fn in os.listdir(folder):\n        if not fn.startswith('heisenberg_tebd_'):\n            continue\n        if not fn.endswith('.pkl'):\n            continue\n        _, rest = fn.split('heisenberg_tebd_chi_')\n        chi, _ = rest.split('.pkl')\n        chi = int(chi)\n        with open(os.path.join(folder, fn), 'rb') as f:\n            res = pickle.load(f)\n        results[chi] = res\n\n    fontsize = 10\n    linewidth = 5.90666  # inches\n    L = model_params['L']\n    mpl.rcParams.update({'font.size': fontsize})\n    mpl.rcParams.update({'legend.fontsize': 8})\n    mpl.rcParams.update({'legend.title_fontsize': 8})\n    chis = sorted(results.keys())\n    max_chi = max(chis)\n\n    t_max = 15\n    t_mask = results[max_chi]['t'] <= t_max\n\n    assert len(chis) == 5\n    plot_styles = {\n        (chi, which): dict(\n            color=c, label=rf'$\\chi={chi}$', ls=ls, lw=2 if chi == max_chi else (1 if chi == min(chis) else 1.5)\n        )\n        for chi, c, ls in zip(\n            chis, ['tab:blue', 'tab:orange', 'tab:green', 'tab:purple', 'tab:red'], ['-', ':', '--', '-.', '-']\n        )\n        for which in [None, 'S', 'Imb', 'err']\n    }\n\n    aspect = 0.7\n\n    # magnetization profile\n    ax_mag.set_xlabel(r'$\\langle S^z_i \\rangle(t)$')\n    ax_mag.set_xlabel(r'$t$')\n    ax_mag.set_ylabel(r'Site $i$')\n    ax_mag.set_yticks([0, 12, 24, 36, 49])\n    ax_mag.xaxis.set_major_formatter(mpl.ticker.FuncFormatter(lambda x, pos: str(int(dt_measure * int(x)))))\n    im = ax_mag.pcolor(results[max_chi]['mag_z'].T[:, t_mask], cmap='inferno', edgecolor='face')\n    # cmap candidates: viridis, inferno, coolwarm, bwr, RdBu,\n    divider = make_axes_locatable(ax_mag)\n    cax = divider.append_axes('right', size='5%', pad=0.05)\n    cbar.ax.set_title(r'$\\langle S_i^z\\rangle(t)$', fontsize=fontsize)\n\n    # subplot: S_vN entropy\n    ax_S.set_ylabel(r'$S_{\\text{vN}}$')\n    ax_S.set_xlabel('$t$')\n    for chi in chis:\n        ax_S.plot(results[chi]['t'][t_mask], results[chi]['S'][t_mask, L // 2], **plot_styles[chi, 'S'])\n\n    # subplot: imbalance\n    ax_Imb.set_ylabel(r'$\\mathcal{I}$')\n    ax_Imb.set_xlabel('$t$')\n    for chi in chis:\n        ax_Imb.plot(results[chi]['t'][t_mask], results[chi]['imbalance'][0][t_mask], **plot_styles[chi, 'Imb'])\n    ax_Imb.legend()\n\n    # subplot: truncation error\n    ax_err.set_ylabel(r'$\\varepsilon_\\text{trunc}$')\n    ax_err.set_xlabel('$t$')\n    for chi in chis:\n        ax_err.semilogy(results[chi]['t'][t_mask], results[chi]['err'][t_mask], **plot_styles[chi, 'err'])\n\n    fig.tight_layout(pad=0.1)\n    print(f'saved to {outfile}')\n\n\nif __name__ == '__main__':\n    main()",
    "search_text": "example.v1_publication_heisenberg_tebd # example source: heisenberg_tebd.py\n\"\"\"an example simulating the dynamics of the neel state under heisenberg evolution, using tebd.\"\"\"\n\n# copyright (c) tenpy developers, apache license\nimport argparse\nimport os\nimport pickle\n\nimport numpy as np\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\n\nimport tenpy\n\nmodel_params = dict(\n    l=50,\n    jx=1,\n    jy=1,\n    jz=1,\n)\nmodel = tenpy.spinchain(model_params)\n\nengine_params = dict(\n    order=2,\n    dt=0.02,\n    n_steps=5,\n    trunc_params=dict(\n        chi_max=none,  # to be set in loop\n        svd_min=1e-10,\n    ),\n)\ndt_measure = engine_params['dt'] * engine_params['n_steps']\n\n\ndef main():\n    parser = argparse.argumentparser(description='either run simulation at fixed chi, or plot results.')\n    parser.add_argument('--chi', type=int, default=50, help='mps bond dimension. default 50.')\n    parser.add_argument('--outfolder', default='./', help='folder to write results to. default is cwd.')\n    parser.add_argument(\n        '--plot',\n        type=str,\n        metavar='folder',\n        default=none,\n        help='plot results in the given folder instead of running the simulation.',\n    )\n    args = parser.parse_args()\n\n    if args.plot is not none:\n        plot(folder=args.plot)\n        return\n\n    results = run(chi=args.chi)\n    with open(os.path.join(args.outfolder, f'heisenberg_tebd_chi_{args.chi}.pkl'), 'wb') as f:\n        pickle.dump(results, f)\n\n\ndef run(chi: int):\n    psi = tenpy.mps.from_lat_product_state(model.lat, [['up'], ['down']])\n    # selects sz=0 sector\n\n    engine_params['trunc_params'].update(chi_max=chi)\n    engine = tenpy.tebdengine(psi, model, engine_params)\n    # engine = tenpy.tdvpengine(psi, model, engine_params)\n\n    t = [0]\n    s = [psi.entanglement_entropy()]\n    mag_z = [psi.expectation_value('sz')]\n    err = [0]\n\n    for n in range(200):\n        print(f'n={n}')\n        engine.run()\n        t.append(engine.evolved_time)\n        s.append(psi.entanglement_entropy())\n        mag_z.append(psi.expectation_value('sz'))\n        err.append(engine.trunc_err.eps)\n\n    t = np.array(t)\n    s = np.array(s)\n    mag_z = np.array(mag_z)\n    err = np.array(err)\n    imbalance = (0.5 * np.average(mag_z[:, ::2] - mag_z[:, 1::2], axis=1),)\n    return dict(t=t, s=s, mag_z=mag_z, imbalance=imbalance, err=err, chi=chi)\n\n\ndef plot(folder):\n    outfile = os.path.join(folder, 'heisenberg_tebd.pdf')\n    results = {}\n    for fn in os.listdir(folder):\n        if not fn.startswith('heisenberg_tebd_'):\n            continue\n        if not fn.endswith('.pkl'):\n            continue\n        _, rest = fn.split('heisenberg_tebd_chi_')\n        chi, _ = rest.split('.pkl')\n        chi = int(chi)\n        with open(os.path.join(folder, fn), 'rb') as f:\n            res = pickle.load(f)\n        results[chi] = res\n\n    fontsize = 10\n    linewidth = 5.90666  # inches\n    l = model_params['l']\n    mpl.rcparams.update({'font.size': fontsize})\n    mpl.rcparams.update({'legend.fontsize': 8})\n    mpl.rcparams.update({'legend.title_fontsize': 8})\n    chis = sorted(results.keys())\n    max_chi = max(chis)\n\n    t_max = 15\n    t_mask = results[max_chi]['t'] <= t_max\n\n    assert len(chis) == 5\n    plot_styles = {\n        (chi, which): dict(\n            color=c, label=rf'$\\chi={chi}$', ls=ls, lw=2 if chi == max_chi else (1 if chi == min(chis) else 1.5)\n        )\n        for chi, c, ls in zip(\n            chis, ['tab:blue', 'tab:orange', 'tab:green', 'tab:purple', 'tab:red'], ['-', ':', '--', '-.', '-']\n        )\n        for which in [none, 's', 'imb', 'err']\n    }\n\n    aspect = 0.7\n\n    # magnetization profile\n    ax_mag.set_xlabel(r'$\\langle s^z_i \\rangle(t)$')\n    ax_mag.set_xlabel(r'$t$')\n    ax_mag.set_ylabel(r'site $i$')\n    ax_mag.set_yticks([0, 12, 24, 36, 49])\n    ax_mag.xaxis.set_major_formatter(mpl.ticker.funcformatter(lambda x, pos: str(int(dt_measure * int(x)))))\n    im = ax_mag.pcolor(results[max_chi]['mag_z'].t[:, t_mask], cmap='inferno', edgecolor='face')\n    # cmap candidates: viridis, inferno, coolwarm, bwr, rdbu,\n    divider = make_axes_locatable(ax_mag)\n    cax = divider.append_axes('right', size='5%', pad=0.05)\n    cbar.ax.set_title(r'$\\langle s_i^z\\rangle(t)$', fontsize=fontsize)\n\n    # subplot: s_vn entropy\n    ax_s.set_ylabel(r'$s_{\\text{vn}}$')\n    ax_s.set_xlabel('$t$')\n    for chi in chis:\n        ax_s.plot(results[chi]['t'][t_mask], results[chi]['s'][t_mask, l // 2], **plot_styles[chi, 's'])\n\n    # subplot: imbalance\n    ax_imb.set_ylabel(r'$\\mathcal{i}$')\n    ax_imb.set_xlabel('$t$')\n    for chi in chis:\n        ax_imb.plot(results[chi]['t'][t_mask], results[chi]['imbalance'][0][t_mask], **plot_styles[chi, 'imb'])\n    ax_imb.legend()\n\n    # subplot: truncation error\n    ax_err.set_ylabel(r'$\\varepsilon_\\text{trunc}$')\n    ax_err.set_xlabel('$t$')\n    for chi in chis:\n        ax_err.semilogy(results[chi]['t'][t_mask], results[chi]['err'][t_mask], **plot_styles[chi, 'err'])\n\n    fig.tight_layout(pad=0.1)\n    print(f'saved to {outfile}')\n\n\nif __name__ == '__main__':\n    main() example v1 publication heisenberg tebd",
    "tokens": 1469
  },
  {
    "category": "examples",
    "name": "example.advanced_tfi_segment",
    "content": "# Example Source: tfi_segment.py\n\"\"\"Examples using segment boundary conditions\n\nThis code shows the general structure of DMRG with segment boundary conditions, which allows\nto find topologically non-trivial excitations on a \"finite\" segment between two different\ndegenerate ground states.\n\nFor production, you should probably use the\n:class:`~tenpy.simulations.GroundStateSearch.OrthogonalExcitations` class,\nbut this example might be helpful to see the general idea.\n\"\"\"\n# Copyright (C) TeNPy Developers, Apache license\n\nimport numpy as np\n\nimport tenpy.linalg.np_conserved as npc\nfrom tenpy.algorithms import dmrg\nfrom tenpy.models.tf_ising import TFIChain\nfrom tenpy.networks.mps import MPS\nfrom tenpy.tools.params import Config\n\n\ndef calc_infinite_groundstates(dmrg_params, g=0.1):\n    L = 2\n    model_params = dict(L=L, J=1.0, g=g, bc_MPS='infinite', conserve=None, verbose=0)\n\n    model = TFIChain(model_params)\n    plus_x = np.array([1.0, 1.0]) / np.sqrt(2)\n    minus_x = np.array([1.0, -1.0]) / np.sqrt(2)\n    psi_plus = MPS.from_product_state(\n        model.lat.mps_sites(), [plus_x] * L, model.lat.bc_MPS, unit_cell_width=model.lat.mps_unit_cell_width\n    )\n    psi_minus = MPS.from_product_state(\n        model.lat.mps_sites(), [minus_x] * L, model.lat.bc_MPS, unit_cell_width=model.lat.mps_unit_cell_width\n    )\n\n    engine_plus = dmrg.TwoSiteDMRGEngine(psi_plus, model, dmrg_params)\n    engine_plus.run()\n    print('<Sx> =', psi_plus.expectation_value('Sigmax'))\n    engine_minus = dmrg.TwoSiteDMRGEngine(psi_minus, model, dmrg_params)\n    engine_minus.run()\n    print('<Sx> =', psi_minus.expectation_value('Sigmax'))\n\n    data_plus = {'psi': psi_plus}\n    data_plus.update(**engine_plus.env.get_initialization_data())\n    data_minus = {'psi': psi_minus}\n    data_minus.update(**engine_minus.env.get_initialization_data())\n\n    return model, data_plus, data_minus\n\n\ndef prepare_segment(model, data_L, data_R, repeat_L=20, repeat_R=20):\n    psi_L = data_L['psi'].copy()\n    psi_R = data_R['psi'].copy()\n    psi_L.convert_form('B')\n    psi_R.convert_form('B')\n    psi_L.enlarge_mps_unit_cell(repeat_L)\n    psi_R.enlarge_mps_unit_cell(repeat_R)\n    psi_L.bc = 'segment'\n    psi_R.bc = 'segment'\n\n    model.enlarge_mps_unit_cell(repeat_L + repeat_R)\n    model.lat.bc_MPS = 'segment'\n    model.H_MPO.bc = 'segment'\n\n    init_env_data = {\n        'init_LP': data_L['init_LP'],\n        'age_LP': data_L['age_LP'],\n        'init_RP': data_R['init_RP'],\n        'age_RP': data_R['age_RP'],\n    }\n    Bs_L = [psi_L.get_B(i) for i in range(psi_L.L)]\n    Bs_R = [psi_R.get_B(i) for i in range(psi_R.L)]\n\n    joint = npc.Array.from_func(\n        np.ones,\n        [Bs_L[-1].get_leg('vR').conj(), Bs_R[0].get_leg('vL').conj()],\n        psi_L.dtype,\n        qtotal=None,\n        labels=['vL', 'vR'],\n    )\n    Bs_L[-1] = npc.tensordot(Bs_L[-1], joint, axes=['vR', 'vL'])\n    S = psi_L._S[:-1] + psi_R._S\n\n    psi = MPS(psi_L.sites + psi_R.sites, Bs_L + Bs_R, S, 'segment', unit_cell_width=model.lat.mps_unit_cell_width)\n    # UL, UR = psi.canonical_form_finite()\n\n    return psi, model, init_env_data\n\n\ndef calc_segment_groundstate(psi, model, dmrg_params):\n    engine = dmrg.TwoSiteDMRGEngine(psi, model, dmrg_params)\n    E, psi = engine.run()\n    return psi\n\n\ndef plot(psi, filename):\n    x = np.arange(psi.L)\n    meas = psi.expectation_value('Sigmax')\n    ax.plot(x, meas)\n    ax.set_ylabel('<sigma_x>')\n    ax.set_xlabel('$x$')\n    print('saved to ' + filename)\n\n\nif __name__ == '__main__':\n    dmrg_params = Config(\n        {\n            'trunc_params': {'chi_max': 50, 'svd_min': 1.0e-10, 'trunc_cut': None},\n            'update_env': 0,\n            'start_env': 2,\n            'max_E_err': 1.0e-6,\n            'max_S_err': 1.0e-5,\n            'max_sweeps': 100,\n            'verbose': 1,\n            'mixer': False,\n        },\n        'DMRG',\n    )\n\n    model, psi_plus, psi_minus = calc_infinite_groundstates(dmrg_params)\n    psi, model, init_env_data = prepare_segment(model, psi_plus, psi_minus)\n    dmrg_params['init_env_data'] = init_env_data\n    results = calc_segment_groundstate(psi, model, dmrg_params)\n    plot(results, 'tfi_segment.pdf')",
    "search_text": "example.advanced_tfi_segment # example source: tfi_segment.py\n\"\"\"examples using segment boundary conditions\n\nthis code shows the general structure of dmrg with segment boundary conditions, which allows\nto find topologically non-trivial excitations on a \"finite\" segment between two different\ndegenerate ground states.\n\nfor production, you should probably use the\n:class:`~tenpy.simulations.groundstatesearch.orthogonalexcitations` class,\nbut this example might be helpful to see the general idea.\n\"\"\"\n# copyright (c) tenpy developers, apache license\n\nimport numpy as np\n\nimport tenpy.linalg.np_conserved as npc\nfrom tenpy.algorithms import dmrg\nfrom tenpy.models.tf_ising import tfichain\nfrom tenpy.networks.mps import mps\nfrom tenpy.tools.params import config\n\n\ndef calc_infinite_groundstates(dmrg_params, g=0.1):\n    l = 2\n    model_params = dict(l=l, j=1.0, g=g, bc_mps='infinite', conserve=none, verbose=0)\n\n    model = tfichain(model_params)\n    plus_x = np.array([1.0, 1.0]) / np.sqrt(2)\n    minus_x = np.array([1.0, -1.0]) / np.sqrt(2)\n    psi_plus = mps.from_product_state(\n        model.lat.mps_sites(), [plus_x] * l, model.lat.bc_mps, unit_cell_width=model.lat.mps_unit_cell_width\n    )\n    psi_minus = mps.from_product_state(\n        model.lat.mps_sites(), [minus_x] * l, model.lat.bc_mps, unit_cell_width=model.lat.mps_unit_cell_width\n    )\n\n    engine_plus = dmrg.twositedmrgengine(psi_plus, model, dmrg_params)\n    engine_plus.run()\n    print('<sx> =', psi_plus.expectation_value('sigmax'))\n    engine_minus = dmrg.twositedmrgengine(psi_minus, model, dmrg_params)\n    engine_minus.run()\n    print('<sx> =', psi_minus.expectation_value('sigmax'))\n\n    data_plus = {'psi': psi_plus}\n    data_plus.update(**engine_plus.env.get_initialization_data())\n    data_minus = {'psi': psi_minus}\n    data_minus.update(**engine_minus.env.get_initialization_data())\n\n    return model, data_plus, data_minus\n\n\ndef prepare_segment(model, data_l, data_r, repeat_l=20, repeat_r=20):\n    psi_l = data_l['psi'].copy()\n    psi_r = data_r['psi'].copy()\n    psi_l.convert_form('b')\n    psi_r.convert_form('b')\n    psi_l.enlarge_mps_unit_cell(repeat_l)\n    psi_r.enlarge_mps_unit_cell(repeat_r)\n    psi_l.bc = 'segment'\n    psi_r.bc = 'segment'\n\n    model.enlarge_mps_unit_cell(repeat_l + repeat_r)\n    model.lat.bc_mps = 'segment'\n    model.h_mpo.bc = 'segment'\n\n    init_env_data = {\n        'init_lp': data_l['init_lp'],\n        'age_lp': data_l['age_lp'],\n        'init_rp': data_r['init_rp'],\n        'age_rp': data_r['age_rp'],\n    }\n    bs_l = [psi_l.get_b(i) for i in range(psi_l.l)]\n    bs_r = [psi_r.get_b(i) for i in range(psi_r.l)]\n\n    joint = npc.array.from_func(\n        np.ones,\n        [bs_l[-1].get_leg('vr').conj(), bs_r[0].get_leg('vl').conj()],\n        psi_l.dtype,\n        qtotal=none,\n        labels=['vl', 'vr'],\n    )\n    bs_l[-1] = npc.tensordot(bs_l[-1], joint, axes=['vr', 'vl'])\n    s = psi_l._s[:-1] + psi_r._s\n\n    psi = mps(psi_l.sites + psi_r.sites, bs_l + bs_r, s, 'segment', unit_cell_width=model.lat.mps_unit_cell_width)\n    # ul, ur = psi.canonical_form_finite()\n\n    return psi, model, init_env_data\n\n\ndef calc_segment_groundstate(psi, model, dmrg_params):\n    engine = dmrg.twositedmrgengine(psi, model, dmrg_params)\n    e, psi = engine.run()\n    return psi\n\n\ndef plot(psi, filename):\n    x = np.arange(psi.l)\n    meas = psi.expectation_value('sigmax')\n    ax.plot(x, meas)\n    ax.set_ylabel('<sigma_x>')\n    ax.set_xlabel('$x$')\n    print('saved to ' + filename)\n\n\nif __name__ == '__main__':\n    dmrg_params = config(\n        {\n            'trunc_params': {'chi_max': 50, 'svd_min': 1.0e-10, 'trunc_cut': none},\n            'update_env': 0,\n            'start_env': 2,\n            'max_e_err': 1.0e-6,\n            'max_s_err': 1.0e-5,\n            'max_sweeps': 100,\n            'verbose': 1,\n            'mixer': false,\n        },\n        'dmrg',\n    )\n\n    model, psi_plus, psi_minus = calc_infinite_groundstates(dmrg_params)\n    psi, model, init_env_data = prepare_segment(model, psi_plus, psi_minus)\n    dmrg_params['init_env_data'] = init_env_data\n    results = calc_segment_groundstate(psi, model, dmrg_params)\n    plot(results, 'tfi_segment.pdf') example advanced tfi segment",
    "tokens": 1208
  },
  {
    "category": "examples",
    "name": "example.advanced_vumps_and_plane_wave",
    "content": "# Example Source: vumps_and_plane_wave.py\n\"\"\"Excitations of the transverse field Ising model.\n\nThis example uses VUMPS to find the ground state of the transverse field Ising model and uses the\nplane wave excitation ansatz to compute the first excited states.\n\"\"\"\n# Copyright (C) TeNPy Developers, Apache license\n\nimport numpy as np\n\nfrom tenpy.algorithms import plane_wave_excitation, vumps\nfrom tenpy.models.tf_ising import TFIChain\nfrom tenpy.networks import mps\n\n\ndef tfi_vumps(g=1.5):\n    model_params = dict(L=2, J=1.0, g=g, bc_MPS='infinite', conserve='parity')\n    M = TFIChain(model_params)\n    psi = mps.MPS.from_product_state(M.lat.mps_sites(), [0, 0], bc='infinite')\n    vumps_pars = {\n        'combine': False,\n        'N_sweeps_check': 1,\n        'mixer': False,\n        'trunc_params': {\n            'chi_max': 32,\n            'svd_min': 1.0e-14,\n        },\n        'min_sweeps': 30,\n        'max_sweeps': 50,\n        'max_split_err': 1e-8,  # different criteria than DMRG\n        'max_E_err': 1.0e-12,\n        'max_S_err': 1.0e-8,\n    }\n\n    eng = vumps.TwoSiteVUMPSEngine(psi, M, vumps_pars)\n    E, psi = eng.run()\n    print(f'ground state energy: {E:.5f}')\n\n    # to directly continue with plane wave excitations, return the uniform MPS\n    uniform_psi = eng.psi\n\n    return E, uniform_psi, M\n\n\ndef tfi_excitations(psi_gs, M):\n    pw_params = {\n        'lanczos_params': {\n            'N_max': 50,\n        },\n    }\n    eng_pw = plane_wave_excitation.PlaneWaveExcitationEngine(psi_gs, M, pw_params)\n\n    momenta = np.arange(0, np.pi, np.pi / 8)  # compute for some momenta\n    qtotal_change = [1]  # look for excitations in other parity sector\n    num_ev = 1  # we only compute the lowest dispersion mode\n\n    dispersions = []\n    for p in momenta:\n        Es, _, _ = eng_pw.run(p, qtotal_change, num_ev=num_ev)\n        dispersions.append(Es)\n        print(f'excitation energy for momentum {p / np.pi:.2f} Pi: {Es[0]:.5f}')\n    return momenta, np.array(dispersions)\n\n\ndef tfi_dispersion(k, g):\n    # exact dispersion for two site unit cell\n    return np.min(\n        [2 * np.sqrt(g**2 - 2 * g * np.cos(k) + 1), 2 * np.sqrt(g**2 - 2 * g * np.cos(k + np.pi) + 1)], axis=0\n    )\n\n\nif __name__ == '__main__':\n    E, psi, M = tfi_vumps()\n    momenta, dispersions = tfi_excitations(psi, M)\n\n    # plot and compare to exact results\n",
    "search_text": "example.advanced_vumps_and_plane_wave # example source: vumps_and_plane_wave.py\n\"\"\"excitations of the transverse field ising model.\n\nthis example uses vumps to find the ground state of the transverse field ising model and uses the\nplane wave excitation ansatz to compute the first excited states.\n\"\"\"\n# copyright (c) tenpy developers, apache license\n\nimport numpy as np\n\nfrom tenpy.algorithms import plane_wave_excitation, vumps\nfrom tenpy.models.tf_ising import tfichain\nfrom tenpy.networks import mps\n\n\ndef tfi_vumps(g=1.5):\n    model_params = dict(l=2, j=1.0, g=g, bc_mps='infinite', conserve='parity')\n    m = tfichain(model_params)\n    psi = mps.mps.from_product_state(m.lat.mps_sites(), [0, 0], bc='infinite')\n    vumps_pars = {\n        'combine': false,\n        'n_sweeps_check': 1,\n        'mixer': false,\n        'trunc_params': {\n            'chi_max': 32,\n            'svd_min': 1.0e-14,\n        },\n        'min_sweeps': 30,\n        'max_sweeps': 50,\n        'max_split_err': 1e-8,  # different criteria than dmrg\n        'max_e_err': 1.0e-12,\n        'max_s_err': 1.0e-8,\n    }\n\n    eng = vumps.twositevumpsengine(psi, m, vumps_pars)\n    e, psi = eng.run()\n    print(f'ground state energy: {e:.5f}')\n\n    # to directly continue with plane wave excitations, return the uniform mps\n    uniform_psi = eng.psi\n\n    return e, uniform_psi, m\n\n\ndef tfi_excitations(psi_gs, m):\n    pw_params = {\n        'lanczos_params': {\n            'n_max': 50,\n        },\n    }\n    eng_pw = plane_wave_excitation.planewaveexcitationengine(psi_gs, m, pw_params)\n\n    momenta = np.arange(0, np.pi, np.pi / 8)  # compute for some momenta\n    qtotal_change = [1]  # look for excitations in other parity sector\n    num_ev = 1  # we only compute the lowest dispersion mode\n\n    dispersions = []\n    for p in momenta:\n        es, _, _ = eng_pw.run(p, qtotal_change, num_ev=num_ev)\n        dispersions.append(es)\n        print(f'excitation energy for momentum {p / np.pi:.2f} pi: {es[0]:.5f}')\n    return momenta, np.array(dispersions)\n\n\ndef tfi_dispersion(k, g):\n    # exact dispersion for two site unit cell\n    return np.min(\n        [2 * np.sqrt(g**2 - 2 * g * np.cos(k) + 1), 2 * np.sqrt(g**2 - 2 * g * np.cos(k + np.pi) + 1)], axis=0\n    )\n\n\nif __name__ == '__main__':\n    e, psi, m = tfi_vumps()\n    momenta, dispersions = tfi_excitations(psi, m)\n\n    # plot and compare to exact results\n example advanced vumps and plane wave",
    "tokens": 720
  },
  {
    "category": "examples",
    "name": "example.advanced_xxz_corr_length",
    "content": "# Example Source: xxz_corr_length.py\n\"\"\"Calculate the correlation length of the transverse field Ising model for various h_z.\n\nThis example uses DMRG to find the ground state of the transverse field Ising model when tuning\nthrough the phase transition by changing the field `hz`. It uses\n:meth:`~tenpy.networks.mps.MPS.correlation_length` to extract the correlation length of the ground\nstate, and plots it vs. hz in the end.\n\"\"\"\n# Copyright (C) TeNPy Developers, Apache license\n\nimport numpy as np\n\nfrom tenpy.algorithms import dmrg\nfrom tenpy.models.spins import SpinChain\nfrom tenpy.networks.mps import MPS\n\n\ndef run(Jzs):\n    L = 2\n    model_params = dict(L=L, Jx=1.0, Jy=1.0, Jz=Jzs[0], bc_MPS='infinite', conserve='Sz')\n    chi = 300\n    dmrg_params = {\n        'trunc_params': {'chi_max': chi, 'svd_min': 1.0e-10, 'trunc_cut': None},\n        'update_env': 20,\n        'start_env': 20,\n        'max_E_err': 0.0001,\n        'max_S_err': 0.0001,\n        'mixer': False,\n    }\n\n    M = SpinChain(model_params)\n    psi = MPS.from_product_state(\n        M.lat.mps_sites(), (['up', 'down'] * L)[:L], M.lat.bc_MPS, unit_cell_width=M.lat.mps_unit_cell_width\n    )\n\n    engine = dmrg.TwoSiteDMRGEngine(psi, M, dmrg_params)\n    np.set_printoptions(linewidth=120)\n    corr_length = []\n    for Jz in Jzs:\n        print('-' * 80)\n        print(f'{Jz=:.4f}')\n        print('-' * 80)\n        model_params['Jz'] = Jz\n        M = SpinChain(model_params)\n        engine.init_env(model=M)  # (re)initialize DMRG environment with new model\n        # this uses the result from the previous DMRG as first initial guess\n        engine.run()\n        # psi is modified by engine.run() and now represents the ground state for the current `Jz`.\n        corr_length.append(psi.correlation_length(tol_ev0=1.0e-3))\n        print('corr. length', corr_length[-1])\n        print('<Sz>', psi.expectation_value('Sz'))\n        dmrg_params['start_env'] = 0  # (some of) the parameters are read out again\n    corr_length = np.array(corr_length)\n    results = {\n        'model_params': model_params,\n        'dmrg_params': dmrg_params,\n        'Jzs': Jzs,\n        'corr_length': corr_length,\n        'eval_transfermatrix': np.exp(-1.0 / corr_length),\n    }\n    return results\n\n\ndef plot(results, filename):\n    corr_length = results['corr_length']\n    Jzs = results['Jzs']\n    print('saved to ' + filename)\n\n\nif __name__ == '__main__':\n    filename = 'xxz_corrlength.pkl'\n    import os.path\n    import pickle\n\n    if not os.path.exists(filename):\n        results = run(list(np.arange(4.0, 1.5, -0.25)) + list(np.arange(1.5, 0.8, -0.05)))\n        with open(filename, 'wb') as f:\n            pickle.dump(results, f)\n    else:\n        print('just load the data')\n        with open(filename, 'rb') as f:\n            results = pickle.load(f)\n    plot(results, filename[:-4] + '.pdf')",
    "search_text": "example.advanced_xxz_corr_length # example source: xxz_corr_length.py\n\"\"\"calculate the correlation length of the transverse field ising model for various h_z.\n\nthis example uses dmrg to find the ground state of the transverse field ising model when tuning\nthrough the phase transition by changing the field `hz`. it uses\n:meth:`~tenpy.networks.mps.mps.correlation_length` to extract the correlation length of the ground\nstate, and plots it vs. hz in the end.\n\"\"\"\n# copyright (c) tenpy developers, apache license\n\nimport numpy as np\n\nfrom tenpy.algorithms import dmrg\nfrom tenpy.models.spins import spinchain\nfrom tenpy.networks.mps import mps\n\n\ndef run(jzs):\n    l = 2\n    model_params = dict(l=l, jx=1.0, jy=1.0, jz=jzs[0], bc_mps='infinite', conserve='sz')\n    chi = 300\n    dmrg_params = {\n        'trunc_params': {'chi_max': chi, 'svd_min': 1.0e-10, 'trunc_cut': none},\n        'update_env': 20,\n        'start_env': 20,\n        'max_e_err': 0.0001,\n        'max_s_err': 0.0001,\n        'mixer': false,\n    }\n\n    m = spinchain(model_params)\n    psi = mps.from_product_state(\n        m.lat.mps_sites(), (['up', 'down'] * l)[:l], m.lat.bc_mps, unit_cell_width=m.lat.mps_unit_cell_width\n    )\n\n    engine = dmrg.twositedmrgengine(psi, m, dmrg_params)\n    np.set_printoptions(linewidth=120)\n    corr_length = []\n    for jz in jzs:\n        print('-' * 80)\n        print(f'{jz=:.4f}')\n        print('-' * 80)\n        model_params['jz'] = jz\n        m = spinchain(model_params)\n        engine.init_env(model=m)  # (re)initialize dmrg environment with new model\n        # this uses the result from the previous dmrg as first initial guess\n        engine.run()\n        # psi is modified by engine.run() and now represents the ground state for the current `jz`.\n        corr_length.append(psi.correlation_length(tol_ev0=1.0e-3))\n        print('corr. length', corr_length[-1])\n        print('<sz>', psi.expectation_value('sz'))\n        dmrg_params['start_env'] = 0  # (some of) the parameters are read out again\n    corr_length = np.array(corr_length)\n    results = {\n        'model_params': model_params,\n        'dmrg_params': dmrg_params,\n        'jzs': jzs,\n        'corr_length': corr_length,\n        'eval_transfermatrix': np.exp(-1.0 / corr_length),\n    }\n    return results\n\n\ndef plot(results, filename):\n    corr_length = results['corr_length']\n    jzs = results['jzs']\n    print('saved to ' + filename)\n\n\nif __name__ == '__main__':\n    filename = 'xxz_corrlength.pkl'\n    import os.path\n    import pickle\n\n    if not os.path.exists(filename):\n        results = run(list(np.arange(4.0, 1.5, -0.25)) + list(np.arange(1.5, 0.8, -0.05)))\n        with open(filename, 'wb') as f:\n            pickle.dump(results, f)\n    else:\n        print('just load the data')\n        with open(filename, 'rb') as f:\n            results = pickle.load(f)\n    plot(results, filename[:-4] + '.pdf') example advanced xxz corr length",
    "tokens": 809
  },
  {
    "category": "examples",
    "name": "example.advanced_mpo_exponential_decay",
    "content": "# Example Source: mpo_exponential_decay.py\n\"\"\"Demonstration of the mpo.MPO.from_grids method.\n\nWe construct a MPO model for a spin 1/2 Heisenberg chain with an infinite number of\n2-sites interactions, with strength that decays exponentially with the distance between the sites.\n\nThis can also be achieved via :meth:`~tenpy.models.model.CouplingModel.add_exponentially_decaying_coupling`.\n\nWe run the iDMRG algorithm to find the ground state and energy density of the\nsystem in the thermodynamic limit.\n\"\"\"\n# Copyright (C) TeNPy Developers, Apache license\n\nimport numpy as np\n\nfrom tenpy.algorithms import dmrg\nfrom tenpy.models.lattice import Chain\nfrom tenpy.models.model import MPOModel\nfrom tenpy.networks.mpo import MPO\nfrom tenpy.networks.mps import MPS\nfrom tenpy.networks.site import SpinHalfSite\nfrom tenpy.tools.params import asConfig\n\n\nclass ExponentiallyDecayingHeisenberg(MPOModel):\n    r\"\"\"Spin-1/2 Heisenberg Chain with exponentially decaying interactions.\n\n    The Hamiltonian reads:\n\n    .. math ::\n\n        H = \\sum_i \\sum_{j>i} \\exp(-\\frac{|j-i-1|}{\\mathtt{xi}}) (\n                  \\mathtt{Jxx}/2 (S^{+}_i S^{-}_j + S^{-}_i S^{+}_j)\n                + \\mathtt{Jz} S^z_i S^z_j                        ) \\\\\n            - \\sum_i \\mathtt{hz} S^z_i\n\n    All parameters are collected in a single dictionary `model_params`.\n\n    Parameters\n    ----------\n    L : int\n        Length of the chain.\n    Jxx, Jz, hz, xi: float\n        Coupling parameters as defined for the Hamiltonian above.\n    bc_MPS : {'finite' | 'infinite'}\n        MPS boundary conditions.\n    conserve : 'Sz' | 'parity' | None\n        What should be conserved. See :class:`~tenpy.networks.Site.SpinHalfSite`.\n    sort_charge : bool\n        Whether to sort by charges of physical legs. `True` by default.\n\n    \"\"\"\n\n    def __init__(self, model_params):\n        # model parameters\n        model_params = asConfig(model_params, 'ExponentiallyDecayingHeisenberg')\n        L = model_params.get('L', 2)\n        xi = model_params.get('xi', 0.5)\n        Jxx = model_params.get('Jxx', 1.0)\n        Jz = model_params.get('Jz', 1.5)\n        hz = model_params.get('hz', 0.0)\n        conserve = model_params.get('conserve', 'Sz')\n        sort_charge = model_params.get('sort_charge', True)\n        if xi == 0.0:\n            g = 0.0\n        elif xi == np.inf:\n            g = 1.0\n        else:\n            g = np.exp(-1 / (xi))\n\n        # Define the sites and the lattice, which in this case is a simple uniform chain\n        # of spin 1/2 sites\n        site = SpinHalfSite(conserve=conserve, sort_charge=sort_charge)\n        lat = Chain(L, site, bc_MPS='infinite', bc='periodic')\n\n        # The operators that appear in the Hamiltonian. Standard spin operators are\n        # already defined for the spin 1/2 site, but it is also possible to add new\n        # operators using the add_op method\n        Sz, Sp, Sm, Id = site.Sz, site.Sp, site.Sm, site.Id\n\n        # fmt: off\n        # The grid (list of lists) that defines the MPO. It is possible to define the\n        # operators in the grid in the following ways:\n        # 1) NPC arrays, defined above:\n        grid = [[Id,   Sp,   Sm,   Sz,   -hz*Sz    ],\n                [None, g*Id, None, None, 0.5*Jxx*Sm],\n                [None, None, g*Id, None, 0.5*Jxx*Sp],\n                [None, None, None, g*Id, Jz*Sz     ],\n                [None, None, None, None, Id        ]]\n        # 2) In the form [(\"OpName\", strength)], where \"OpName\" is the name of the\n        # operator (e.g. \"Sm\" for Sm) and \"strength\" is a number that multiplies it.\n        grid = [[[(\"Id\", 1)], [(\"Sp\",1)], [(\"Sm\",1)], [(\"Sz\",1)], [(\"Sz\", -hz)]    ],\n                [None       , [(\"Id\",g)], None      , None      , [(\"Sm\", 0.5*Jxx)]],\n                [None       , None      , [(\"Id\",g)], None      , [(\"Sp\", 0.5*Jxx)]],\n                [None       , None      , None      , [(\"Id\",g)], [(\"Sz\",Jz)]      ],\n                [None       , None      , None      , None      , [(\"Id\",1)]       ]]\n        # 3) It is also possible to write a single \"OpName\", equivalent to\n        # [(\"OpName\", 1)].\n        grid = [[\"Id\"       , \"Sp\"      , \"Sm\"      , \"Sz\"      , [(\"Sz\", -hz)]    ],\n                [None       , [(\"Id\",g)], None      , None      , [(\"Sm\", 0.5*Jxx)]],\n                [None       , None      , [(\"Id\",g)], None      , [(\"Sp\", 0.5*Jxx)]],\n                [None       , None      , None      , [(\"Id\",g)], [(\"Sz\",Jz)]      ],\n                [None       , None      , None      , None      , \"Id\"             ]]\n        # fmt: on\n        grids = [grid] * L\n\n        # Generate the MPO from the grid. Note that it is not necessary to specify\n        # the physical legs and their charges, since the from_grids method can extract\n        # this information from the position of the operators inside the grid.\n        H = MPO.from_grids(\n            lat.mps_sites(), grids, bc='infinite', IdL=0, IdR=-1, mps_unit_cell_width=lat.mps_unit_cell_width\n        )\n        MPOModel.__init__(self, lat, H)\n\n\ndef example_run_dmrg():\n    \"\"\"Use iDMRG to extract information about the ground state of the system.\"\"\"\n    model_params = dict(L=2, Jxx=1, Jz=1.5, xi=0.8)\n    model = ExponentiallyDecayingHeisenberg(model_params)\n    psi = MPS.from_product_state(\n        model.lat.mps_sites(), ['up', 'down'], bc='infinite', unit_cell_width=model.lat.mps_unit_cell_width\n    )\n    dmrg_params = {\n        'mixer': True,\n        'chi_list': {0: 100},\n        'trunc_params': {'svd_min': 1.0e-10},\n    }\n    results = dmrg.run(psi, model, dmrg_params)\n    print('Energy per site: ', results['E'])\n    print('<Sz>: ', psi.expectation_value('Sz'))\n\n\nif __name__ == '__main__':\n    import logging\n\n    logging.basicConfig(level=logging.INFO)\n    example_run_dmrg()",
    "search_text": "example.advanced_mpo_exponential_decay # example source: mpo_exponential_decay.py\n\"\"\"demonstration of the mpo.mpo.from_grids method.\n\nwe construct a mpo model for a spin 1/2 heisenberg chain with an infinite number of\n2-sites interactions, with strength that decays exponentially with the distance between the sites.\n\nthis can also be achieved via :meth:`~tenpy.models.model.couplingmodel.add_exponentially_decaying_coupling`.\n\nwe run the idmrg algorithm to find the ground state and energy density of the\nsystem in the thermodynamic limit.\n\"\"\"\n# copyright (c) tenpy developers, apache license\n\nimport numpy as np\n\nfrom tenpy.algorithms import dmrg\nfrom tenpy.models.lattice import chain\nfrom tenpy.models.model import mpomodel\nfrom tenpy.networks.mpo import mpo\nfrom tenpy.networks.mps import mps\nfrom tenpy.networks.site import spinhalfsite\nfrom tenpy.tools.params import asconfig\n\n\nclass exponentiallydecayingheisenberg(mpomodel):\n    r\"\"\"spin-1/2 heisenberg chain with exponentially decaying interactions.\n\n    the hamiltonian reads:\n\n    .. math ::\n\n        h = \\sum_i \\sum_{j>i} \\exp(-\\frac{|j-i-1|}{\\mathtt{xi}}) (\n                  \\mathtt{jxx}/2 (s^{+}_i s^{-}_j + s^{-}_i s^{+}_j)\n                + \\mathtt{jz} s^z_i s^z_j                        ) \\\\\n            - \\sum_i \\mathtt{hz} s^z_i\n\n    all parameters are collected in a single dictionary `model_params`.\n\n    parameters\n    ----------\n    l : int\n        length of the chain.\n    jxx, jz, hz, xi: float\n        coupling parameters as defined for the hamiltonian above.\n    bc_mps : {'finite' | 'infinite'}\n        mps boundary conditions.\n    conserve : 'sz' | 'parity' | none\n        what should be conserved. see :class:`~tenpy.networks.site.spinhalfsite`.\n    sort_charge : bool\n        whether to sort by charges of physical legs. `true` by default.\n\n    \"\"\"\n\n    def __init__(self, model_params):\n        # model parameters\n        model_params = asconfig(model_params, 'exponentiallydecayingheisenberg')\n        l = model_params.get('l', 2)\n        xi = model_params.get('xi', 0.5)\n        jxx = model_params.get('jxx', 1.0)\n        jz = model_params.get('jz', 1.5)\n        hz = model_params.get('hz', 0.0)\n        conserve = model_params.get('conserve', 'sz')\n        sort_charge = model_params.get('sort_charge', true)\n        if xi == 0.0:\n            g = 0.0\n        elif xi == np.inf:\n            g = 1.0\n        else:\n            g = np.exp(-1 / (xi))\n\n        # define the sites and the lattice, which in this case is a simple uniform chain\n        # of spin 1/2 sites\n        site = spinhalfsite(conserve=conserve, sort_charge=sort_charge)\n        lat = chain(l, site, bc_mps='infinite', bc='periodic')\n\n        # the operators that appear in the hamiltonian. standard spin operators are\n        # already defined for the spin 1/2 site, but it is also possible to add new\n        # operators using the add_op method\n        sz, sp, sm, id = site.sz, site.sp, site.sm, site.id\n\n        # fmt: off\n        # the grid (list of lists) that defines the mpo. it is possible to define the\n        # operators in the grid in the following ways:\n        # 1) npc arrays, defined above:\n        grid = [[id,   sp,   sm,   sz,   -hz*sz    ],\n                [none, g*id, none, none, 0.5*jxx*sm],\n                [none, none, g*id, none, 0.5*jxx*sp],\n                [none, none, none, g*id, jz*sz     ],\n                [none, none, none, none, id        ]]\n        # 2) in the form [(\"opname\", strength)], where \"opname\" is the name of the\n        # operator (e.g. \"sm\" for sm) and \"strength\" is a number that multiplies it.\n        grid = [[[(\"id\", 1)], [(\"sp\",1)], [(\"sm\",1)], [(\"sz\",1)], [(\"sz\", -hz)]    ],\n                [none       , [(\"id\",g)], none      , none      , [(\"sm\", 0.5*jxx)]],\n                [none       , none      , [(\"id\",g)], none      , [(\"sp\", 0.5*jxx)]],\n                [none       , none      , none      , [(\"id\",g)], [(\"sz\",jz)]      ],\n                [none       , none      , none      , none      , [(\"id\",1)]       ]]\n        # 3) it is also possible to write a single \"opname\", equivalent to\n        # [(\"opname\", 1)].\n        grid = [[\"id\"       , \"sp\"      , \"sm\"      , \"sz\"      , [(\"sz\", -hz)]    ],\n                [none       , [(\"id\",g)], none      , none      , [(\"sm\", 0.5*jxx)]],\n                [none       , none      , [(\"id\",g)], none      , [(\"sp\", 0.5*jxx)]],\n                [none       , none      , none      , [(\"id\",g)], [(\"sz\",jz)]      ],\n                [none       , none      , none      , none      , \"id\"             ]]\n        # fmt: on\n        grids = [grid] * l\n\n        # generate the mpo from the grid. note that it is not necessary to specify\n        # the physical legs and their charges, since the from_grids method can extract\n        # this information from the position of the operators inside the grid.\n        h = mpo.from_grids(\n            lat.mps_sites(), grids, bc='infinite', idl=0, idr=-1, mps_unit_cell_width=lat.mps_unit_cell_width\n        )\n        mpomodel.__init__(self, lat, h)\n\n\ndef example_run_dmrg():\n    \"\"\"use idmrg to extract information about the ground state of the system.\"\"\"\n    model_params = dict(l=2, jxx=1, jz=1.5, xi=0.8)\n    model = exponentiallydecayingheisenberg(model_params)\n    psi = mps.from_product_state(\n        model.lat.mps_sites(), ['up', 'down'], bc='infinite', unit_cell_width=model.lat.mps_unit_cell_width\n    )\n    dmrg_params = {\n        'mixer': true,\n        'chi_list': {0: 100},\n        'trunc_params': {'svd_min': 1.0e-10},\n    }\n    results = dmrg.run(psi, model, dmrg_params)\n    print('energy per site: ', results['e'])\n    print('<sz>: ', psi.expectation_value('sz'))\n\n\nif __name__ == '__main__':\n    import logging\n\n    logging.basicconfig(level=logging.info)\n    example_run_dmrg() example advanced mpo exponential decay",
    "tokens": 1621
  },
  {
    "category": "examples",
    "name": "example.advanced_tfi_phase_transition",
    "content": "# Example Source: tfi_phase_transition.py\n\"\"\"Tuning through the phase transition of the transverse field Ising model.\n\nThis example uses DMRG to find the ground state of the transverse field Ising model when tuning\nthrough the phase transition by changing the field `g`.\nIt plots a few observables in the end.\n\"\"\"\n# Copyright (C) TeNPy Developers, Apache license\n\nimport numpy as np\n\nfrom tenpy.algorithms import dmrg\nfrom tenpy.models.tf_ising import TFIChain\nfrom tenpy.networks.mps import MPS\n\n\ndef run(gs):\n    print('running for gs = ', gs)\n    L = 2\n    model_params = dict(L=L, J=1.0, g=gs[0], bc_MPS='infinite', conserve=None)\n    chi = 100\n    dmrg_params = {\n        'trunc_params': {'chi_max': chi, 'svd_min': 1.0e-10, 'trunc_cut': None},\n        'update_env': 5,\n        'start_env': 5,\n        'max_E_err': 0.0001,\n        'max_S_err': 0.0001,\n        'max_sweeps': 100,  # NOTE: this is not enough to fully converge at the critical point!\n        'mixer': False,\n    }\n\n    M = TFIChain(model_params)\n    psi = MPS.from_product_state(\n        M.lat.mps_sites(), (['up', 'down'] * L)[:L], M.lat.bc_MPS, unit_cell_width=M.lat.mps_unit_cell_width\n    )\n\n    engine = dmrg.TwoSiteDMRGEngine(psi, M, dmrg_params)\n    np.set_printoptions(linewidth=120)\n\n    corr_length = []\n    fidelity = []\n    Sz = []\n    E = []\n    S = []\n    SxSx = []\n    old_psi = None\n    for g in gs:\n        print('-' * 80)\n        print('g =', g)\n        print('-' * 80)\n        model_params['g'] = g\n        M = TFIChain(model_params)\n        engine.init_env(model=M)  # (re)initialize DMRG environment with new model\n        # this uses the result from the previous DMRG as first initial guess\n        E0, psi = engine.run()\n        E.append(E0)\n        # psi is modified by engine.run() and now represents the ground state for the current `g`.\n        S.append(psi.entanglement_entropy()[0])\n        corr_length.append(psi.correlation_length(tol_ev0=1.0e-3))\n        print('corr. length', corr_length[-1])\n        Sz.append(psi.expectation_value('Sigmaz'))\n        print('<Sigmaz>', Sz[-1])\n        SxSx.append(psi.correlation_function('Sigmax', 'Sigmax', [0], 20)[0, :])\n        print('<Sigmax_0 Sigmax_i>', SxSx[-1])\n        if old_psi is not None:\n            fidelity.append(np.abs(old_psi.overlap(psi, understood_infinite=True)))\n            print('fidelity', fidelity[-1])\n        old_psi = psi.copy()\n        dmrg_params['start_env'] = 0  # (some of) the parameters are read out again\n    results = {\n        'model_params': model_params,\n        'dmrg_params': dmrg_params,\n        'gs': gs,\n        'corr_length': np.array(corr_length),\n        'fidelity': np.array(fidelity),\n        'Sz': np.array(Sz),\n        'E': np.array(E),\n        'S': np.array(S),\n        'SxSx': np.array(SxSx),\n        'eval_transfermatrix': np.exp(-1.0 / np.array(corr_length)),\n    }\n    return results\n\n\ndef plot(results, filename):\n    gs = np.array(results['gs'])\n    for ax, key in zip(axes.flatten(), ['E', 'S', 'SxSx', 'Sz', 'eval_transfermatrix', 'fidelity']):\n        if key == 'fidelity':\n            ax.plot(0.5 * (gs[1:] + gs[:-1]), np.abs(results[key]), 'ro-')\n        elif key == 'SxSx':\n            SxSx = results[key]\n            max_j = SxSx.shape[1]\n            for j in range(1, max_j):\n                label = f'j= {j:d}' if j in [1, max_j - 1] else None\n                ax.plot(gs, SxSx[:, j], label=label, color=cm(j / max_j))\n            ax.legend()\n        else:\n            ax.plot(gs, results[key], 'ro-')\n        ax.set_xlabel('$g/J$')\n        ax.set_ylabel(key)\n        ax.set_xlim(min(gs), max(gs))\n    print('saved to ' + filename)\n\n\nif __name__ == '__main__':\n    filename = 'tfi_phase_transition.pkl'\n    import os.path\n    import pickle\n\n    if not os.path.exists(filename):\n        gs = sorted(set(np.linspace(0.5, 1.5, 11)).union(set(np.linspace(0.95, 1.05, 11))))[::-1]\n        results = run(gs)\n        with open(filename, 'wb') as f:\n            pickle.dump(results, f)\n    else:\n        print('just load the data')\n        with open(filename, 'rb') as f:\n            results = pickle.load(f)\n    plot(results, filename[:-4] + '.pdf')",
    "search_text": "example.advanced_tfi_phase_transition # example source: tfi_phase_transition.py\n\"\"\"tuning through the phase transition of the transverse field ising model.\n\nthis example uses dmrg to find the ground state of the transverse field ising model when tuning\nthrough the phase transition by changing the field `g`.\nit plots a few observables in the end.\n\"\"\"\n# copyright (c) tenpy developers, apache license\n\nimport numpy as np\n\nfrom tenpy.algorithms import dmrg\nfrom tenpy.models.tf_ising import tfichain\nfrom tenpy.networks.mps import mps\n\n\ndef run(gs):\n    print('running for gs = ', gs)\n    l = 2\n    model_params = dict(l=l, j=1.0, g=gs[0], bc_mps='infinite', conserve=none)\n    chi = 100\n    dmrg_params = {\n        'trunc_params': {'chi_max': chi, 'svd_min': 1.0e-10, 'trunc_cut': none},\n        'update_env': 5,\n        'start_env': 5,\n        'max_e_err': 0.0001,\n        'max_s_err': 0.0001,\n        'max_sweeps': 100,  # note: this is not enough to fully converge at the critical point!\n        'mixer': false,\n    }\n\n    m = tfichain(model_params)\n    psi = mps.from_product_state(\n        m.lat.mps_sites(), (['up', 'down'] * l)[:l], m.lat.bc_mps, unit_cell_width=m.lat.mps_unit_cell_width\n    )\n\n    engine = dmrg.twositedmrgengine(psi, m, dmrg_params)\n    np.set_printoptions(linewidth=120)\n\n    corr_length = []\n    fidelity = []\n    sz = []\n    e = []\n    s = []\n    sxsx = []\n    old_psi = none\n    for g in gs:\n        print('-' * 80)\n        print('g =', g)\n        print('-' * 80)\n        model_params['g'] = g\n        m = tfichain(model_params)\n        engine.init_env(model=m)  # (re)initialize dmrg environment with new model\n        # this uses the result from the previous dmrg as first initial guess\n        e0, psi = engine.run()\n        e.append(e0)\n        # psi is modified by engine.run() and now represents the ground state for the current `g`.\n        s.append(psi.entanglement_entropy()[0])\n        corr_length.append(psi.correlation_length(tol_ev0=1.0e-3))\n        print('corr. length', corr_length[-1])\n        sz.append(psi.expectation_value('sigmaz'))\n        print('<sigmaz>', sz[-1])\n        sxsx.append(psi.correlation_function('sigmax', 'sigmax', [0], 20)[0, :])\n        print('<sigmax_0 sigmax_i>', sxsx[-1])\n        if old_psi is not none:\n            fidelity.append(np.abs(old_psi.overlap(psi, understood_infinite=true)))\n            print('fidelity', fidelity[-1])\n        old_psi = psi.copy()\n        dmrg_params['start_env'] = 0  # (some of) the parameters are read out again\n    results = {\n        'model_params': model_params,\n        'dmrg_params': dmrg_params,\n        'gs': gs,\n        'corr_length': np.array(corr_length),\n        'fidelity': np.array(fidelity),\n        'sz': np.array(sz),\n        'e': np.array(e),\n        's': np.array(s),\n        'sxsx': np.array(sxsx),\n        'eval_transfermatrix': np.exp(-1.0 / np.array(corr_length)),\n    }\n    return results\n\n\ndef plot(results, filename):\n    gs = np.array(results['gs'])\n    for ax, key in zip(axes.flatten(), ['e', 's', 'sxsx', 'sz', 'eval_transfermatrix', 'fidelity']):\n        if key == 'fidelity':\n            ax.plot(0.5 * (gs[1:] + gs[:-1]), np.abs(results[key]), 'ro-')\n        elif key == 'sxsx':\n            sxsx = results[key]\n            max_j = sxsx.shape[1]\n            for j in range(1, max_j):\n                label = f'j= {j:d}' if j in [1, max_j - 1] else none\n                ax.plot(gs, sxsx[:, j], label=label, color=cm(j / max_j))\n            ax.legend()\n        else:\n            ax.plot(gs, results[key], 'ro-')\n        ax.set_xlabel('$g/j$')\n        ax.set_ylabel(key)\n        ax.set_xlim(min(gs), max(gs))\n    print('saved to ' + filename)\n\n\nif __name__ == '__main__':\n    filename = 'tfi_phase_transition.pkl'\n    import os.path\n    import pickle\n\n    if not os.path.exists(filename):\n        gs = sorted(set(np.linspace(0.5, 1.5, 11)).union(set(np.linspace(0.95, 1.05, 11))))[::-1]\n        results = run(gs)\n        with open(filename, 'wb') as f:\n            pickle.dump(results, f)\n    else:\n        print('just load the data')\n        with open(filename, 'rb') as f:\n            results = pickle.load(f)\n    plot(results, filename[:-4] + '.pdf') example advanced tfi phase transition",
    "tokens": 1197
  },
  {
    "category": "examples",
    "name": "example.advanced_central_charge_ising",
    "content": "# Example Source: central_charge_ising.py\n\"\"\"Example to extract the central charge from the entanglement scaling.\n\nThis example code evaluate the central charge of the transverse field Ising model using iDMRG.\nThe expected value for the central charge c = 1/2. The code always recycle the environment from\nthe previous simulation, which can be seen at the \"age\".\n\nFor the theoretical background why :math:`S = c/6 log(xi)`, see :cite:`pollmann2009`.\n\"\"\"\n# Copyright (C) TeNPy Developers, Apache license\n\nimport time\n\nimport numpy as np\n\nimport tenpy\nfrom tenpy.algorithms import dmrg\nfrom tenpy.models.tf_ising import TFIChain\nfrom tenpy.networks.mps import MPS\n\n\ndef example_DMRG_tf_ising_infinite_S_xi_scaling(g):\n    model_params = dict(L=2, J=1.0, g=g, bc_MPS='infinite', conserve='best')\n    M = TFIChain(model_params)\n    product_state = ['up'] * M.lat.N_sites\n    psi = MPS.from_product_state(\n        M.lat.mps_sites(), product_state, bc=M.lat.bc_MPS, unit_cell_width=M.lat.mps_unit_cell_width\n    )\n    dmrg_params = {\n        'start_env': 10,\n        'mixer': False,\n        #  'mixer_params': {'amplitude': 1.e-3, 'decay': 5., 'disable_after': 50},\n        'trunc_params': {'chi_max': 5, 'svd_min': 1.0e-10},\n        'max_E_err': 1.0e-9,\n        'max_S_err': 1.0e-6,\n        'update_env': 0,\n    }\n\n    chi_list = np.arange(7, 31, 2)\n    s_list = []\n    xi_list = []\n    eng = dmrg.TwoSiteDMRGEngine(psi, M, dmrg_params)\n\n    for chi in chi_list:\n        t0 = time.time()\n\n        eng.reset_stats()\n        # necessary if you for example have a fixed number of sweeps, if you don't set this you\n        # option your simulation stops after initial number of sweeps!\n\n        eng.trunc_params['chi_max'] = chi\n        ##   DMRG Calculation    ##\n        print('Start iDMRG CALCULATION')\n        eng.run()\n        eng.options['mixer'] = None\n        psi.canonical_form()\n\n        ##   Calculating bond entropy and correlation length  ##\n        s_list.append(psi.entanglement_entropy()[0])\n        # the bond 0 is between MPS unit cells and hence sensible even for 2D lattices.\n        xi_list.append(psi.correlation_length())\n\n        print(chi, time.time() - t0, np.mean(psi.expectation_value(M.H_bond)), s_list[-1], xi_list[-1], flush=True)\n        tenpy.tools.optimization.optimize(3)  # quite some speedup for small chi\n\n        print('SETTING NEW BOND DIMENSION')\n\n    return s_list, xi_list\n\n\ndef fit_plot_central_charge(s_list, xi_list, filename):\n    \"\"\"Plot routine in order to determine the cental charge.\"\"\"\n    from scipy.optimize import curve_fit\n\n    def fitFunc(Xi, c, a):\n        return (c / 6) * np.log(Xi) + a\n\n    Xi = np.array(xi_list)\n    S = np.array(s_list)\n    LXi = np.log(Xi)  # Logarithm of the correlation length xi\n\n    fitParams, fitCovariances = curve_fit(fitFunc, Xi, S)\n\n    # Plot fitting parameter and covariances\n    print('c =', fitParams[0], 'a =', fitParams[1])\n    print('Covariance Matrix', fitCovariances)\n\n    # plot the data as blue circles\n        LXi, S, fmt='o', c='blue', ms=5.5, markerfacecolor='white', markeredgecolor='blue', markeredgewidth=1.4\n    )\n    # plot the fitted line\n\n\n\nif __name__ == '__main__':\n    import logging\n\n    logging.basicConfig(level=logging.INFO)\n    s_list, xi_list = example_DMRG_tf_ising_infinite_S_xi_scaling(g=1)\n    fit_plot_central_charge(s_list, xi_list, 'central_charge_ising.pdf')",
    "search_text": "example.advanced_central_charge_ising # example source: central_charge_ising.py\n\"\"\"example to extract the central charge from the entanglement scaling.\n\nthis example code evaluate the central charge of the transverse field ising model using idmrg.\nthe expected value for the central charge c = 1/2. the code always recycle the environment from\nthe previous simulation, which can be seen at the \"age\".\n\nfor the theoretical background why :math:`s = c/6 log(xi)`, see :cite:`pollmann2009`.\n\"\"\"\n# copyright (c) tenpy developers, apache license\n\nimport time\n\nimport numpy as np\n\nimport tenpy\nfrom tenpy.algorithms import dmrg\nfrom tenpy.models.tf_ising import tfichain\nfrom tenpy.networks.mps import mps\n\n\ndef example_dmrg_tf_ising_infinite_s_xi_scaling(g):\n    model_params = dict(l=2, j=1.0, g=g, bc_mps='infinite', conserve='best')\n    m = tfichain(model_params)\n    product_state = ['up'] * m.lat.n_sites\n    psi = mps.from_product_state(\n        m.lat.mps_sites(), product_state, bc=m.lat.bc_mps, unit_cell_width=m.lat.mps_unit_cell_width\n    )\n    dmrg_params = {\n        'start_env': 10,\n        'mixer': false,\n        #  'mixer_params': {'amplitude': 1.e-3, 'decay': 5., 'disable_after': 50},\n        'trunc_params': {'chi_max': 5, 'svd_min': 1.0e-10},\n        'max_e_err': 1.0e-9,\n        'max_s_err': 1.0e-6,\n        'update_env': 0,\n    }\n\n    chi_list = np.arange(7, 31, 2)\n    s_list = []\n    xi_list = []\n    eng = dmrg.twositedmrgengine(psi, m, dmrg_params)\n\n    for chi in chi_list:\n        t0 = time.time()\n\n        eng.reset_stats()\n        # necessary if you for example have a fixed number of sweeps, if you don't set this you\n        # option your simulation stops after initial number of sweeps!\n\n        eng.trunc_params['chi_max'] = chi\n        ##   dmrg calculation    ##\n        print('start idmrg calculation')\n        eng.run()\n        eng.options['mixer'] = none\n        psi.canonical_form()\n\n        ##   calculating bond entropy and correlation length  ##\n        s_list.append(psi.entanglement_entropy()[0])\n        # the bond 0 is between mps unit cells and hence sensible even for 2d lattices.\n        xi_list.append(psi.correlation_length())\n\n        print(chi, time.time() - t0, np.mean(psi.expectation_value(m.h_bond)), s_list[-1], xi_list[-1], flush=true)\n        tenpy.tools.optimization.optimize(3)  # quite some speedup for small chi\n\n        print('setting new bond dimension')\n\n    return s_list, xi_list\n\n\ndef fit_plot_central_charge(s_list, xi_list, filename):\n    \"\"\"plot routine in order to determine the cental charge.\"\"\"\n    from scipy.optimize import curve_fit\n\n    def fitfunc(xi, c, a):\n        return (c / 6) * np.log(xi) + a\n\n    xi = np.array(xi_list)\n    s = np.array(s_list)\n    lxi = np.log(xi)  # logarithm of the correlation length xi\n\n    fitparams, fitcovariances = curve_fit(fitfunc, xi, s)\n\n    # plot fitting parameter and covariances\n    print('c =', fitparams[0], 'a =', fitparams[1])\n    print('covariance matrix', fitcovariances)\n\n    # plot the data as blue circles\n        lxi, s, fmt='o', c='blue', ms=5.5, markerfacecolor='white', markeredgecolor='blue', markeredgewidth=1.4\n    )\n    # plot the fitted line\n\n\n\nif __name__ == '__main__':\n    import logging\n\n    logging.basicconfig(level=logging.info)\n    s_list, xi_list = example_dmrg_tf_ising_infinite_s_xi_scaling(g=1)\n    fit_plot_central_charge(s_list, xi_list, 'central_charge_ising.pdf') example advanced central charge ising",
    "tokens": 949
  },
  {
    "category": "examples",
    "name": "example.chern_insulators_haldane_FCI",
    "content": "# Example Source: haldane_FCI.py\n\"\"\"Hardcore boson Haldane model - minimal FCI example\n\nBased on Eq.1 of [Grushin2015]_ with:\n- bosons instead of fermions\n- mu=0, V=0 (only infinite onsite repulsion, via hardcore constraint)\n- 1/2 filling of the lowest band (i.e. 1/4 total filling)\n\"\"\"\n\n# Copyright (C) TeNPy Developers, Apache license\n\nimport warnings\n\nimport numpy as np\n\nfrom tenpy.algorithms import dmrg\nfrom tenpy.models.haldane import BosonicHaldaneModel\nfrom tenpy.networks.mps import MPS\n\n\ndef plot_model(model_params, phi_ext=0.1):\n    model_params['phi_ext'] = phi_ext\n    M = BosonicHaldaneModel(model_params)\n\n    M.lat.plot_sites(ax)\n    M.coupling_terms['t1 Bd_i B_j'].plot_coupling_terms(ax, M.lat)\n    M.coupling_terms['t2 Bd_i B_j'].plot_coupling_terms(ax, M.lat, text='{op_j!s} {strength_angle:.2f}', text_pos=0.9)\n    print(M.coupling_terms['t1 Bd_i B_j'].to_TermList())\n    ax.set_aspect(1.0)\n\n\ndef run(model_params, phi_ext=np.linspace(0, 2.0, 7)):\n    data = dict(phi_ext=phi_ext, QL=[], ent_spectrum=[])\n\n    dmrg_params = {\n        'mixer': True,  # setting this to True helps to escape local minima\n        'mixer_params': {'amplitude': 1.0e-5, 'decay': 1.2, 'disable_after': 30},\n        'trunc_params': {\n            'svd_min': 1.0e-10,\n        },\n        'lanczos_params': {'N_min': 5, 'N_max': 20},\n        'chi_list': {0: 9, 10: 49, 20: 100},\n        'max_E_err': 1.0e-10,\n        'max_S_err': 1.0e-6,\n        'max_sweeps': 150,\n    }\n\n    prod_state = [1]\n    if 2 * model_params['Lx'] * model_params['Ly'] % 4 != 0:\n        warnings.warn('Total filling factor = 1/4 cannot be achieved with this unit cell geometry.')\n    for i in range(1, 2 * model_params['Lx'] * model_params['Ly']):\n        if i % 4 == 0:\n            prod_state.append(1)\n        else:\n            prod_state.append(0)\n\n    print(prod_state)\n\n    eng = None\n\n    for phi in phi_ext:\n        print('=' * 100)\n        print('phi_ext = ', phi)\n\n        model_params['phi_ext'] = phi\n\n        if eng is None:  # first time in the loop\n            M = BosonicHaldaneModel(model_params)\n            psi = MPS.from_product_state(\n                M.lat.mps_sites(), prod_state, bc=M.lat.bc_MPS, unit_cell_width=M.lat.mps_unit_cell_width\n            )\n            eng = dmrg.TwoSiteDMRGEngine(psi, M, dmrg_params)\n        else:\n            del eng.options['chi_list']\n            M = BosonicHaldaneModel(model_params)\n            eng.init_env(model=M)\n\n        E, psi = eng.run()\n\n        data['QL'].append(psi.average_charge(bond=0)[0])\n        data['ent_spectrum'].append(psi.entanglement_spectrum(by_charge=True)[0])\n\n    return data\n\n\ndef plot_results(data):\n\n    ax.plot(data['phi_ext'], data['QL'], marker='o')\n    ax.set_xlabel(r'$\\Phi_y / 2 \\pi$')\n    ax.set_ylabel(r'$ \\langle Q^L(\\Phi_y) \\rangle$')\n\n    colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k']\n    color_by_charge = {}\n    for phi_ext, spectrum in zip(data['phi_ext'], data['ent_spectrum']):\n        for q, s in spectrum:\n            q = q[0]\n            label = ''\n            if q not in color_by_charge:\n                label = f'{q:d}'\n                color_by_charge[q] = colors[len(color_by_charge) % len(colors)]\n            color = color_by_charge[q]\n            ax.plot(phi_ext * np.ones(s.shape), s, linestyle='', marker='_', color=color, label=label)\n    ax.set_xlabel(r'$\\Phi_y / 2 \\pi$')\n    ax.set_ylabel(r'$ \\epsilon_\\alpha $')\n    ax.set_ylim(0.0, 8.0)\n    ax.legend(loc='upper right')\n\n\nif __name__ == '__main__':\n    t1_value = -1\n\n    phi = np.arccos(3 * np.sqrt(3 / 43))\n    t2_value = (np.sqrt(129) / 36) * t1_value * np.exp(1j * phi)  # optimal band flatness\n\n    model_params = dict(\n        conserve='N',\n        t1=t1_value,\n        t2=t2_value,\n        mu=0,\n        V=0,\n        bc_MPS='infinite',\n        order='default',\n        Lx=1,\n        Ly=4,\n        bc_y='cylinder',\n    )\n\n    # plot_model(model_params)\n    data = run(model_params)\n    plot_results(data)",
    "search_text": "example.chern_insulators_haldane_fci # example source: haldane_fci.py\n\"\"\"hardcore boson haldane model - minimal fci example\n\nbased on eq.1 of [grushin2015]_ with:\n- bosons instead of fermions\n- mu=0, v=0 (only infinite onsite repulsion, via hardcore constraint)\n- 1/2 filling of the lowest band (i.e. 1/4 total filling)\n\"\"\"\n\n# copyright (c) tenpy developers, apache license\n\nimport warnings\n\nimport numpy as np\n\nfrom tenpy.algorithms import dmrg\nfrom tenpy.models.haldane import bosonichaldanemodel\nfrom tenpy.networks.mps import mps\n\n\ndef plot_model(model_params, phi_ext=0.1):\n    model_params['phi_ext'] = phi_ext\n    m = bosonichaldanemodel(model_params)\n\n    m.lat.plot_sites(ax)\n    m.coupling_terms['t1 bd_i b_j'].plot_coupling_terms(ax, m.lat)\n    m.coupling_terms['t2 bd_i b_j'].plot_coupling_terms(ax, m.lat, text='{op_j!s} {strength_angle:.2f}', text_pos=0.9)\n    print(m.coupling_terms['t1 bd_i b_j'].to_termlist())\n    ax.set_aspect(1.0)\n\n\ndef run(model_params, phi_ext=np.linspace(0, 2.0, 7)):\n    data = dict(phi_ext=phi_ext, ql=[], ent_spectrum=[])\n\n    dmrg_params = {\n        'mixer': true,  # setting this to true helps to escape local minima\n        'mixer_params': {'amplitude': 1.0e-5, 'decay': 1.2, 'disable_after': 30},\n        'trunc_params': {\n            'svd_min': 1.0e-10,\n        },\n        'lanczos_params': {'n_min': 5, 'n_max': 20},\n        'chi_list': {0: 9, 10: 49, 20: 100},\n        'max_e_err': 1.0e-10,\n        'max_s_err': 1.0e-6,\n        'max_sweeps': 150,\n    }\n\n    prod_state = [1]\n    if 2 * model_params['lx'] * model_params['ly'] % 4 != 0:\n        warnings.warn('total filling factor = 1/4 cannot be achieved with this unit cell geometry.')\n    for i in range(1, 2 * model_params['lx'] * model_params['ly']):\n        if i % 4 == 0:\n            prod_state.append(1)\n        else:\n            prod_state.append(0)\n\n    print(prod_state)\n\n    eng = none\n\n    for phi in phi_ext:\n        print('=' * 100)\n        print('phi_ext = ', phi)\n\n        model_params['phi_ext'] = phi\n\n        if eng is none:  # first time in the loop\n            m = bosonichaldanemodel(model_params)\n            psi = mps.from_product_state(\n                m.lat.mps_sites(), prod_state, bc=m.lat.bc_mps, unit_cell_width=m.lat.mps_unit_cell_width\n            )\n            eng = dmrg.twositedmrgengine(psi, m, dmrg_params)\n        else:\n            del eng.options['chi_list']\n            m = bosonichaldanemodel(model_params)\n            eng.init_env(model=m)\n\n        e, psi = eng.run()\n\n        data['ql'].append(psi.average_charge(bond=0)[0])\n        data['ent_spectrum'].append(psi.entanglement_spectrum(by_charge=true)[0])\n\n    return data\n\n\ndef plot_results(data):\n\n    ax.plot(data['phi_ext'], data['ql'], marker='o')\n    ax.set_xlabel(r'$\\phi_y / 2 \\pi$')\n    ax.set_ylabel(r'$ \\langle q^l(\\phi_y) \\rangle$')\n\n    colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k']\n    color_by_charge = {}\n    for phi_ext, spectrum in zip(data['phi_ext'], data['ent_spectrum']):\n        for q, s in spectrum:\n            q = q[0]\n            label = ''\n            if q not in color_by_charge:\n                label = f'{q:d}'\n                color_by_charge[q] = colors[len(color_by_charge) % len(colors)]\n            color = color_by_charge[q]\n            ax.plot(phi_ext * np.ones(s.shape), s, linestyle='', marker='_', color=color, label=label)\n    ax.set_xlabel(r'$\\phi_y / 2 \\pi$')\n    ax.set_ylabel(r'$ \\epsilon_\\alpha $')\n    ax.set_ylim(0.0, 8.0)\n    ax.legend(loc='upper right')\n\n\nif __name__ == '__main__':\n    t1_value = -1\n\n    phi = np.arccos(3 * np.sqrt(3 / 43))\n    t2_value = (np.sqrt(129) / 36) * t1_value * np.exp(1j * phi)  # optimal band flatness\n\n    model_params = dict(\n        conserve='n',\n        t1=t1_value,\n        t2=t2_value,\n        mu=0,\n        v=0,\n        bc_mps='infinite',\n        order='default',\n        lx=1,\n        ly=4,\n        bc_y='cylinder',\n    )\n\n    # plot_model(model_params)\n    data = run(model_params)\n    plot_results(data) example chern insulators haldane fci",
    "tokens": 1190
  },
  {
    "category": "examples",
    "name": "example.chern_insulators_chiral_pi_flux",
    "content": "# Example Source: chiral_pi_flux.py\n\"\"\"Chiral pi flux model - Chern insulator example\n\nBased on the model in [Neupert2011]_\n\"\"\"\n\n# Copyright (C) TeNPy Developers, Apache license\n\nimport numpy as np\n\nfrom tenpy.algorithms import dmrg\nfrom tenpy.models import lattice\nfrom tenpy.models.model import CouplingMPOModel\nfrom tenpy.networks import site\nfrom tenpy.networks.mps import MPS\nfrom tenpy.networks.site import FermionSite\n\n\nclass BipartiteSquare(lattice.Lattice):\n    def __init__(self, Lx, Ly, siteA, **kwargs):\n        basis = np.array(([2, 0.0], [0, 2]))\n\n        pos = np.array(([0, 0], [1, 0], [0, 1], [1, 1]))\n\n        kwargs.setdefault('order', 'default')\n        kwargs.setdefault('bc', 'periodic')\n        kwargs.setdefault('bc_MPS', 'infinite')\n        kwargs.setdefault('basis', basis)\n        kwargs.setdefault('positions', pos)\n\n        super().__init__([Lx, Ly], [siteA, siteA, siteA, siteA], **kwargs)\n\n        self.NN = [\n            (0, 1, np.array([0, 0])),\n            (1, 3, np.array([0, 0])),\n            (3, 2, np.array([0, 0])),\n            (2, 0, np.array([0, 0])),\n            (2, 0, np.array([0, 1])),\n            (1, 3, np.array([0, -1])),\n            (0, 1, np.array([-1, 0])),\n            (3, 2, np.array([1, 0])),\n        ]\n        self.nNNdashed = [\n            (0, 3, np.array([0, 0])),\n            (2, 1, np.array([0, 0])),\n            (3, 0, np.array([1, 1])),\n            (1, 2, np.array([1, -1])),\n        ]\n        self.nNNdotted = [\n            (1, 2, np.array([1, 0])),\n            (3, 0, np.array([1, 0])),\n            (2, 1, np.array([0, 1])),\n            (3, 0, np.array([0, 1])),\n        ]\n\n\nclass FermionicPiFluxModel(CouplingMPOModel):\n    def init_sites(self, model_params):\n        conserve = model_params.get('conserve', 'N')\n        site = FermionSite(conserve=conserve)\n        return site\n\n    def init_lattice(self, model_params):\n        Lx = model_params.get('Lx', 1)\n        Ly = model_params.get('Ly', 3)\n        fs = self.init_sites(model_params)\n        lat = BipartiteSquare(Lx, Ly, fs)\n        return lat\n\n    def init_terms(self, model_params):\n        t = np.asarray(model_params.get('t', -1.0))\n        V = np.asarray(model_params.get('V', 0.0))\n        mu = np.asarray(model_params.get('mu', 0.0))\n        phi_ext = 2 * np.pi * model_params.get('phi_ext', 0.0)\n\n        t1 = t * np.exp(1j * np.pi / 4)\n        t2 = t / np.sqrt(2)\n\n        self.add_onsite(mu, 0, 'N', category='mu N')\n        self.add_onsite(-mu, 1, 'N', category='mu N')\n\n        for u1, u2, dx in self.lat.NN:\n            t1_phi = self.coupling_strength_add_ext_flux(t1, dx, [0, phi_ext])\n            self.add_coupling(t1_phi, u1, 'Cd', u2, 'C', dx, 'JW', category='t1 Cd_i C_j', plus_hc=True)\n            self.add_coupling(V, u1, 'N', u2, 'N', dx, category='V N_i N_j')\n\n        for u1, u2, dx in self.lat.nNNdashed:\n            t2_phi = self.coupling_strength_add_ext_flux(t2, dx, [0, phi_ext])\n            self.add_coupling(t2_phi, u1, 'Cd', u2, 'C', dx, 'JW', category='t2 Cd_i C_j', plus_hc=True)\n\n        for u1, u2, dx in self.lat.nNNdotted:\n            t2_phi = self.coupling_strength_add_ext_flux(t2, dx, [0, phi_ext])\n            self.add_coupling(-t2_phi, u1, 'Cd', u2, 'C', dx, 'JW', category='-t2 Cd_i C_j', plus_hc=True)\n\n\ndef plot_lattice():\n\n    fs = site.FermionSite()\n    lat = BipartiteSquare(3, 3, fs, basis=[[2, 0], [0, 2]])\n    lat.plot_sites(ax)\n    lat.plot_coupling(ax, lat.NN, linestyle='-', color='green')\n    lat.plot_coupling(ax, lat.nNNdashed, linestyle='--', color='black')\n    lat.plot_coupling(ax, lat.nNNdotted, linestyle='--', color='red')\n    ax.set_aspect('equal')\n\n\ndef run(phi_ext=np.linspace(0, 1.0, 7)):\n    data = dict(phi_ext=phi_ext, QL=[], ent_spectrum=[])\n\n    model_params = dict(conserve='N', t=-1, V=0, mu=0, Lx=1, Ly=3)\n\n    dmrg_params = {\n        'mixer': True,  # setting this to True helps to escape local minima\n        'mixer_params': {'amplitude': 1.0e-5, 'decay': 1.2, 'disable_after': 30},\n        'trunc_params': {\n            'svd_min': 1.0e-10,\n        },\n        'lanczos_params': {'N_min': 5, 'N_max': 20},\n        'chi_list': {0: 9, 10: 49, 20: 100},\n        'max_E_err': 1.0e-10,\n        'max_S_err': 1.0e-6,\n        'max_sweeps': 150,\n    }\n\n    prod_state = ['empty', 'full'] * (model_params['Lx'] * model_params['Ly'] * 2)\n\n    eng = None\n\n    for phi in phi_ext:\n        print('=' * 100)\n        print('phi_ext = ', phi)\n\n        model_params['phi_ext'] = phi\n\n        if eng is None:  # first time in the loop\n            M = FermionicPiFluxModel(model_params)\n            psi = MPS.from_product_state(\n                M.lat.mps_sites(), prod_state, bc=M.lat.bc_MPS, unit_cell_width=M.lat.mps_unit_cell_width\n            )\n            eng = dmrg.TwoSiteDMRGEngine(psi, M, dmrg_params)\n        else:\n            del eng.options['chi_list']\n            M = FermionicPiFluxModel(model_params)\n            eng.init_env(model=M)\n\n        E, psi = eng.run()\n\n        data['QL'].append(psi.average_charge(bond=0)[0])\n        data['ent_spectrum'].append(psi.entanglement_spectrum(by_charge=True)[0])\n\n    return data\n\n\ndef plot_results(data):\n\n    ax.plot(data['phi_ext'], data['QL'], marker='o')\n    ax.set_xlabel(r'$\\Phi_y / 2 \\pi$')\n    ax.set_ylabel(r'$ \\langle Q^L(\\Phi_y) \\rangle$')\n\n    colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k']\n    color_by_charge = {}\n    for phi_ext, spectrum in zip(data['phi_ext'], data['ent_spectrum']):\n        for q, s in spectrum:\n            q = q[0]\n            label = ''\n            if q not in color_by_charge:\n                label = f'{q:d}'\n                color_by_charge[q] = colors[len(color_by_charge) % len(colors)]\n            color = color_by_charge[q]\n            ax.plot(phi_ext * np.ones(s.shape), s, linestyle='', marker='_', color=color, label=label)\n    ax.set_xlabel(r'$\\Phi_y / 2 \\pi$')\n    ax.set_ylabel(r'$ \\epsilon_\\alpha $')\n    ax.set_ylim(0.0, 8.0)\n    ax.legend(loc='upper right')\n\n\nif __name__ == '__main__':\n    # plot_lattice()\n    data = run()\n    plot_results(data)",
    "search_text": "example.chern_insulators_chiral_pi_flux # example source: chiral_pi_flux.py\n\"\"\"chiral pi flux model - chern insulator example\n\nbased on the model in [neupert2011]_\n\"\"\"\n\n# copyright (c) tenpy developers, apache license\n\nimport numpy as np\n\nfrom tenpy.algorithms import dmrg\nfrom tenpy.models import lattice\nfrom tenpy.models.model import couplingmpomodel\nfrom tenpy.networks import site\nfrom tenpy.networks.mps import mps\nfrom tenpy.networks.site import fermionsite\n\n\nclass bipartitesquare(lattice.lattice):\n    def __init__(self, lx, ly, sitea, **kwargs):\n        basis = np.array(([2, 0.0], [0, 2]))\n\n        pos = np.array(([0, 0], [1, 0], [0, 1], [1, 1]))\n\n        kwargs.setdefault('order', 'default')\n        kwargs.setdefault('bc', 'periodic')\n        kwargs.setdefault('bc_mps', 'infinite')\n        kwargs.setdefault('basis', basis)\n        kwargs.setdefault('positions', pos)\n\n        super().__init__([lx, ly], [sitea, sitea, sitea, sitea], **kwargs)\n\n        self.nn = [\n            (0, 1, np.array([0, 0])),\n            (1, 3, np.array([0, 0])),\n            (3, 2, np.array([0, 0])),\n            (2, 0, np.array([0, 0])),\n            (2, 0, np.array([0, 1])),\n            (1, 3, np.array([0, -1])),\n            (0, 1, np.array([-1, 0])),\n            (3, 2, np.array([1, 0])),\n        ]\n        self.nnndashed = [\n            (0, 3, np.array([0, 0])),\n            (2, 1, np.array([0, 0])),\n            (3, 0, np.array([1, 1])),\n            (1, 2, np.array([1, -1])),\n        ]\n        self.nnndotted = [\n            (1, 2, np.array([1, 0])),\n            (3, 0, np.array([1, 0])),\n            (2, 1, np.array([0, 1])),\n            (3, 0, np.array([0, 1])),\n        ]\n\n\nclass fermionicpifluxmodel(couplingmpomodel):\n    def init_sites(self, model_params):\n        conserve = model_params.get('conserve', 'n')\n        site = fermionsite(conserve=conserve)\n        return site\n\n    def init_lattice(self, model_params):\n        lx = model_params.get('lx', 1)\n        ly = model_params.get('ly', 3)\n        fs = self.init_sites(model_params)\n        lat = bipartitesquare(lx, ly, fs)\n        return lat\n\n    def init_terms(self, model_params):\n        t = np.asarray(model_params.get('t', -1.0))\n        v = np.asarray(model_params.get('v', 0.0))\n        mu = np.asarray(model_params.get('mu', 0.0))\n        phi_ext = 2 * np.pi * model_params.get('phi_ext', 0.0)\n\n        t1 = t * np.exp(1j * np.pi / 4)\n        t2 = t / np.sqrt(2)\n\n        self.add_onsite(mu, 0, 'n', category='mu n')\n        self.add_onsite(-mu, 1, 'n', category='mu n')\n\n        for u1, u2, dx in self.lat.nn:\n            t1_phi = self.coupling_strength_add_ext_flux(t1, dx, [0, phi_ext])\n            self.add_coupling(t1_phi, u1, 'cd', u2, 'c', dx, 'jw', category='t1 cd_i c_j', plus_hc=true)\n            self.add_coupling(v, u1, 'n', u2, 'n', dx, category='v n_i n_j')\n\n        for u1, u2, dx in self.lat.nnndashed:\n            t2_phi = self.coupling_strength_add_ext_flux(t2, dx, [0, phi_ext])\n            self.add_coupling(t2_phi, u1, 'cd', u2, 'c', dx, 'jw', category='t2 cd_i c_j', plus_hc=true)\n\n        for u1, u2, dx in self.lat.nnndotted:\n            t2_phi = self.coupling_strength_add_ext_flux(t2, dx, [0, phi_ext])\n            self.add_coupling(-t2_phi, u1, 'cd', u2, 'c', dx, 'jw', category='-t2 cd_i c_j', plus_hc=true)\n\n\ndef plot_lattice():\n\n    fs = site.fermionsite()\n    lat = bipartitesquare(3, 3, fs, basis=[[2, 0], [0, 2]])\n    lat.plot_sites(ax)\n    lat.plot_coupling(ax, lat.nn, linestyle='-', color='green')\n    lat.plot_coupling(ax, lat.nnndashed, linestyle='--', color='black')\n    lat.plot_coupling(ax, lat.nnndotted, linestyle='--', color='red')\n    ax.set_aspect('equal')\n\n\ndef run(phi_ext=np.linspace(0, 1.0, 7)):\n    data = dict(phi_ext=phi_ext, ql=[], ent_spectrum=[])\n\n    model_params = dict(conserve='n', t=-1, v=0, mu=0, lx=1, ly=3)\n\n    dmrg_params = {\n        'mixer': true,  # setting this to true helps to escape local minima\n        'mixer_params': {'amplitude': 1.0e-5, 'decay': 1.2, 'disable_after': 30},\n        'trunc_params': {\n            'svd_min': 1.0e-10,\n        },\n        'lanczos_params': {'n_min': 5, 'n_max': 20},\n        'chi_list': {0: 9, 10: 49, 20: 100},\n        'max_e_err': 1.0e-10,\n        'max_s_err': 1.0e-6,\n        'max_sweeps': 150,\n    }\n\n    prod_state = ['empty', 'full'] * (model_params['lx'] * model_params['ly'] * 2)\n\n    eng = none\n\n    for phi in phi_ext:\n        print('=' * 100)\n        print('phi_ext = ', phi)\n\n        model_params['phi_ext'] = phi\n\n        if eng is none:  # first time in the loop\n            m = fermionicpifluxmodel(model_params)\n            psi = mps.from_product_state(\n                m.lat.mps_sites(), prod_state, bc=m.lat.bc_mps, unit_cell_width=m.lat.mps_unit_cell_width\n            )\n            eng = dmrg.twositedmrgengine(psi, m, dmrg_params)\n        else:\n            del eng.options['chi_list']\n            m = fermionicpifluxmodel(model_params)\n            eng.init_env(model=m)\n\n        e, psi = eng.run()\n\n        data['ql'].append(psi.average_charge(bond=0)[0])\n        data['ent_spectrum'].append(psi.entanglement_spectrum(by_charge=true)[0])\n\n    return data\n\n\ndef plot_results(data):\n\n    ax.plot(data['phi_ext'], data['ql'], marker='o')\n    ax.set_xlabel(r'$\\phi_y / 2 \\pi$')\n    ax.set_ylabel(r'$ \\langle q^l(\\phi_y) \\rangle$')\n\n    colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k']\n    color_by_charge = {}\n    for phi_ext, spectrum in zip(data['phi_ext'], data['ent_spectrum']):\n        for q, s in spectrum:\n            q = q[0]\n            label = ''\n            if q not in color_by_charge:\n                label = f'{q:d}'\n                color_by_charge[q] = colors[len(color_by_charge) % len(colors)]\n            color = color_by_charge[q]\n            ax.plot(phi_ext * np.ones(s.shape), s, linestyle='', marker='_', color=color, label=label)\n    ax.set_xlabel(r'$\\phi_y / 2 \\pi$')\n    ax.set_ylabel(r'$ \\epsilon_\\alpha $')\n    ax.set_ylim(0.0, 8.0)\n    ax.legend(loc='upper right')\n\n\nif __name__ == '__main__':\n    # plot_lattice()\n    data = run()\n    plot_results(data) example chern insulators chiral pi flux",
    "tokens": 1901
  },
  {
    "category": "examples",
    "name": "example.chern_insulators_haldane_C3",
    "content": "# Example Source: haldane_C3.py\n\"\"\"Generalized (C=3) Haldane model - Chern insulator example\n\nBased on the model in [Yang2012]_\n\"\"\"\n\n# Copyright (C) TeNPy Developers, Apache license\n\nimport numpy as np\n\nfrom tenpy.algorithms import dmrg\nfrom tenpy.models import lattice\nfrom tenpy.models.model import CouplingMPOModel\nfrom tenpy.networks import site\nfrom tenpy.networks.mps import MPS\nfrom tenpy.networks.site import FermionSite, GroupedSite\n\n\nclass TripartiteTriangular(lattice.Lattice):\n    def __init__(self, Lx, Ly, siteA, **kwargs):\n        basis = np.array(([3.0, 0.0], [0.5, 0.5 * np.sqrt(3)]))\n        pos = np.array(([0.0, 0.0], [1.0, 0.0], [2.0, 0.0]))\n        kwargs.setdefault('order', 'default')\n        kwargs.setdefault('bc', 'periodic')\n        kwargs.setdefault('bc_MPS', 'infinite')\n        kwargs.setdefault('basis', basis)\n        kwargs.setdefault('positions', pos)\n\n        super().__init__([Lx, Ly], [siteA, siteA, siteA], **kwargs)\n\n        self.NN = [\n            (0, 2, np.array([-1, 1])),\n            (0, 1, np.array([0, 0])),\n            (0, 0, np.array([0, -1])),\n            (1, 0, np.array([0, 1])),\n            (1, 2, np.array([0, 0])),\n            (1, 1, np.array([0, -1])),\n            (2, 1, np.array([0, 1])),\n            (2, 0, np.array([1, 0])),\n            (2, 2, np.array([0, -1])),\n        ]\n\n        self.nNNA = [\n            (0, 2, np.array([-1, 2])),\n            (0, 2, np.array([0, -1])),\n            (0, 2, np.array([-1, -1])),\n            (1, 0, np.array([0, 2])),\n            (1, 0, np.array([1, -1])),\n            (1, 0, np.array([0, -1])),\n            (2, 1, np.array([0, 2])),\n            (2, 1, np.array([1, -1])),\n            (2, 1, np.array([0, -1])),\n        ]\n\n        self.nNNB = [\n            (0, 1, np.array([0, 1])),\n            (0, 1, np.array([-1, 1])),\n            (0, 1, np.array([0, -2])),\n            (1, 2, np.array([0, 1])),\n            (1, 2, np.array([-1, 1])),\n            (1, 2, np.array([0, -2])),\n            (2, 0, np.array([1, 1])),\n            (2, 0, np.array([0, 1])),\n            (2, 0, np.array([1, -2])),\n        ]\n\n        self.nnNN = [\n            (0, 1, np.array([-1, 2])),\n            (0, 2, np.array([0, 0])),\n            (0, 0, np.array([0, -2])),\n            (1, 2, np.array([-1, 2])),\n            (1, 0, np.array([1, 0])),\n            (1, 1, np.array([0, -2])),\n            (2, 0, np.array([0, 2])),\n            (2, 1, np.array([1, 0])),\n            (2, 2, np.array([0, -2])),\n        ]\n\n\nclass FermionicC3HaldaneModel(CouplingMPOModel):\n    def init_sites(self, model_params):\n        conserve = model_params.get('conserve', 'N')\n        fs = FermionSite(conserve=conserve)\n        gs = GroupedSite([fs, fs], labels=['A', 'B'], charges='same')\n        gs.add_op('Ntot', gs.NA + gs.NB, False)\n        return gs\n\n    def init_lattice(self, model_params):\n        Lx = model_params.get('Lx', 1)\n        Ly = model_params.get('Ly', 3)\n        fs = self.init_sites(model_params)\n        lat = TripartiteTriangular(Lx, Ly, fs)\n        return lat\n\n    def init_terms(self, model_params):\n        t = np.asarray(model_params.get('t', -1.0))\n        V = np.asarray(model_params.get('V', 0))\n        phi_ext = 2 * np.pi * model_params.get('phi_ext', 0.0)\n\n        t1 = t\n        t2 = 0.39 * t * 1j\n        t3 = -0.34 * t\n\n        for u1, u2, dx in self.lat.NN:\n            t1_phi = self.coupling_strength_add_ext_flux(t1, dx, [0, phi_ext])\n            self.add_coupling(t1_phi, u1, 'CdA', u2, 'CB', dx, 'JW')\n            self.add_coupling(np.conj(t1_phi), u2, 'CdB', u1, 'CA', -dx, 'JW')\n            self.add_coupling(V, u1, 'Ntot', u2, 'Ntot', dx)\n\n        for u1, u2, dx in self.lat.nNNA:\n            t2_phi = self.coupling_strength_add_ext_flux(t2, dx, [0, phi_ext])\n            self.add_coupling(t2_phi, u1, 'CdA', u2, 'CA', dx, 'JW')\n            self.add_coupling(np.conj(t2_phi), u2, 'CdA', u1, 'CA', -dx, 'JW')\n\n        for u1, u2, dx in self.lat.nNNB:\n            t2_phi = self.coupling_strength_add_ext_flux(t2, dx, [0, phi_ext])\n            self.add_coupling(t2_phi, u1, 'CdB', u2, 'CB', dx, 'JW')\n            self.add_coupling(np.conj(t2_phi), u2, 'CdB', u1, 'CB', -dx, 'JW')\n\n        for u1, u2, dx in self.lat.nnNN:\n            t3_phi = self.coupling_strength_add_ext_flux(t3, dx, [0, phi_ext])\n            self.add_coupling(t3_phi, u1, 'CdA', u2, 'CB', dx, 'JW')\n            self.add_coupling(np.conj(t3_phi), u2, 'CdB', u1, 'CA', -dx, 'JW')\n\n\ndef plot_lattice():\n\n    fs = site.FermionSite()\n    lat = TripartiteTriangular(3, 3, fs)\n    lat.plot_sites(ax)\n    lat.plot_coupling(ax, lat.NN, linestyle='--', color='green')\n    lat.plot_coupling(ax, lat.nNNA, linestyle='--', color='red')\n    lat.plot_coupling(ax, lat.nNNB, linestyle='--', color='blue')\n    lat.plot_coupling(ax, lat.nnNN, linestyle='--', color='black')\n    ax.set_aspect('equal')\n\n\ndef run(phi_ext=np.linspace(0, 1.0, 7)):\n    data = dict(phi_ext=phi_ext, QL=[], ent_spectrum=[])\n\n    model_params = dict(conserve='N', t=-1, V=0, Lx=1, Ly=3)\n\n    dmrg_params = {\n        'mixer': True,  # setting this to True helps to escape local minima\n        'mixer_params': {'amplitude': 1.0e-5, 'decay': 1.2, 'disable_after': 30},\n        'trunc_params': {\n            'svd_min': 1.0e-10,\n        },\n        'lanczos_params': {'N_min': 5, 'N_max': 20},\n        'chi_list': {0: 9, 10: 49, 20: 100},\n        'max_E_err': 1.0e-10,\n        'max_S_err': 1.0e-6,\n        'max_sweeps': 150,\n    }\n\n    prod_state = ['full_A empty_B', 'empty_A full_B', 'full_A empty_B'] * (model_params['Lx'] * model_params['Ly'])\n\n    eng = None\n\n    for phi in phi_ext:\n        print('=' * 100)\n        print('phi_ext = ', phi)\n\n        model_params['phi_ext'] = phi\n\n        if eng is None:  # first time in the loop\n            M = FermionicC3HaldaneModel(model_params)\n            psi = MPS.from_product_state(\n                M.lat.mps_sites(), prod_state, bc=M.lat.bc_MPS, unit_cell_width=M.lat.mps_unit_cell_width\n            )\n            eng = dmrg.TwoSiteDMRGEngine(psi, M, dmrg_params)\n        else:\n            del eng.options['chi_list']\n            M = FermionicC3HaldaneModel(model_params)\n            eng.init_env(model=M)\n\n        E, psi = eng.run()\n\n        data['QL'].append(psi.average_charge(bond=0)[0])\n        data['ent_spectrum'].append(psi.entanglement_spectrum(by_charge=True)[0])\n\n    return data\n\n\ndef plot_results(data):\n\n    ax.plot(data['phi_ext'], data['QL'], marker='o')\n    ax.set_xlabel(r'$\\Phi_y / 2 \\pi$')\n    ax.set_ylabel(r'$ \\langle Q^L(\\Phi_y) \\rangle$')\n\n    colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k']\n    color_by_charge = {}\n    for phi_ext, spectrum in zip(data['phi_ext'], data['ent_spectrum']):\n        for q, s in spectrum:\n            q = q[0]\n            label = ''\n            if q not in color_by_charge:\n                label = f'{q:d}'\n                color_by_charge[q] = colors[len(color_by_charge) % len(colors)]\n            color = color_by_charge[q]\n            ax.plot(phi_ext * np.ones(s.shape), s, linestyle='', marker='_', color=color, label=label)\n    ax.set_xlabel(r'$\\Phi_y / 2 \\pi$')\n    ax.set_ylabel(r'$ \\epsilon_\\alpha $')\n    ax.set_ylim(0.0, 8.0)\n    ax.legend(loc='upper right')\n\n\nif __name__ == '__main__':\n    # plot_lattice()\n    data = run()\n    plot_results(data)",
    "search_text": "example.chern_insulators_haldane_c3 # example source: haldane_c3.py\n\"\"\"generalized (c=3) haldane model - chern insulator example\n\nbased on the model in [yang2012]_\n\"\"\"\n\n# copyright (c) tenpy developers, apache license\n\nimport numpy as np\n\nfrom tenpy.algorithms import dmrg\nfrom tenpy.models import lattice\nfrom tenpy.models.model import couplingmpomodel\nfrom tenpy.networks import site\nfrom tenpy.networks.mps import mps\nfrom tenpy.networks.site import fermionsite, groupedsite\n\n\nclass tripartitetriangular(lattice.lattice):\n    def __init__(self, lx, ly, sitea, **kwargs):\n        basis = np.array(([3.0, 0.0], [0.5, 0.5 * np.sqrt(3)]))\n        pos = np.array(([0.0, 0.0], [1.0, 0.0], [2.0, 0.0]))\n        kwargs.setdefault('order', 'default')\n        kwargs.setdefault('bc', 'periodic')\n        kwargs.setdefault('bc_mps', 'infinite')\n        kwargs.setdefault('basis', basis)\n        kwargs.setdefault('positions', pos)\n\n        super().__init__([lx, ly], [sitea, sitea, sitea], **kwargs)\n\n        self.nn = [\n            (0, 2, np.array([-1, 1])),\n            (0, 1, np.array([0, 0])),\n            (0, 0, np.array([0, -1])),\n            (1, 0, np.array([0, 1])),\n            (1, 2, np.array([0, 0])),\n            (1, 1, np.array([0, -1])),\n            (2, 1, np.array([0, 1])),\n            (2, 0, np.array([1, 0])),\n            (2, 2, np.array([0, -1])),\n        ]\n\n        self.nnna = [\n            (0, 2, np.array([-1, 2])),\n            (0, 2, np.array([0, -1])),\n            (0, 2, np.array([-1, -1])),\n            (1, 0, np.array([0, 2])),\n            (1, 0, np.array([1, -1])),\n            (1, 0, np.array([0, -1])),\n            (2, 1, np.array([0, 2])),\n            (2, 1, np.array([1, -1])),\n            (2, 1, np.array([0, -1])),\n        ]\n\n        self.nnnb = [\n            (0, 1, np.array([0, 1])),\n            (0, 1, np.array([-1, 1])),\n            (0, 1, np.array([0, -2])),\n            (1, 2, np.array([0, 1])),\n            (1, 2, np.array([-1, 1])),\n            (1, 2, np.array([0, -2])),\n            (2, 0, np.array([1, 1])),\n            (2, 0, np.array([0, 1])),\n            (2, 0, np.array([1, -2])),\n        ]\n\n        self.nnnn = [\n            (0, 1, np.array([-1, 2])),\n            (0, 2, np.array([0, 0])),\n            (0, 0, np.array([0, -2])),\n            (1, 2, np.array([-1, 2])),\n            (1, 0, np.array([1, 0])),\n            (1, 1, np.array([0, -2])),\n            (2, 0, np.array([0, 2])),\n            (2, 1, np.array([1, 0])),\n            (2, 2, np.array([0, -2])),\n        ]\n\n\nclass fermionicc3haldanemodel(couplingmpomodel):\n    def init_sites(self, model_params):\n        conserve = model_params.get('conserve', 'n')\n        fs = fermionsite(conserve=conserve)\n        gs = groupedsite([fs, fs], labels=['a', 'b'], charges='same')\n        gs.add_op('ntot', gs.na + gs.nb, false)\n        return gs\n\n    def init_lattice(self, model_params):\n        lx = model_params.get('lx', 1)\n        ly = model_params.get('ly', 3)\n        fs = self.init_sites(model_params)\n        lat = tripartitetriangular(lx, ly, fs)\n        return lat\n\n    def init_terms(self, model_params):\n        t = np.asarray(model_params.get('t', -1.0))\n        v = np.asarray(model_params.get('v', 0))\n        phi_ext = 2 * np.pi * model_params.get('phi_ext', 0.0)\n\n        t1 = t\n        t2 = 0.39 * t * 1j\n        t3 = -0.34 * t\n\n        for u1, u2, dx in self.lat.nn:\n            t1_phi = self.coupling_strength_add_ext_flux(t1, dx, [0, phi_ext])\n            self.add_coupling(t1_phi, u1, 'cda', u2, 'cb', dx, 'jw')\n            self.add_coupling(np.conj(t1_phi), u2, 'cdb', u1, 'ca', -dx, 'jw')\n            self.add_coupling(v, u1, 'ntot', u2, 'ntot', dx)\n\n        for u1, u2, dx in self.lat.nnna:\n            t2_phi = self.coupling_strength_add_ext_flux(t2, dx, [0, phi_ext])\n            self.add_coupling(t2_phi, u1, 'cda', u2, 'ca', dx, 'jw')\n            self.add_coupling(np.conj(t2_phi), u2, 'cda', u1, 'ca', -dx, 'jw')\n\n        for u1, u2, dx in self.lat.nnnb:\n            t2_phi = self.coupling_strength_add_ext_flux(t2, dx, [0, phi_ext])\n            self.add_coupling(t2_phi, u1, 'cdb', u2, 'cb', dx, 'jw')\n            self.add_coupling(np.conj(t2_phi), u2, 'cdb', u1, 'cb', -dx, 'jw')\n\n        for u1, u2, dx in self.lat.nnnn:\n            t3_phi = self.coupling_strength_add_ext_flux(t3, dx, [0, phi_ext])\n            self.add_coupling(t3_phi, u1, 'cda', u2, 'cb', dx, 'jw')\n            self.add_coupling(np.conj(t3_phi), u2, 'cdb', u1, 'ca', -dx, 'jw')\n\n\ndef plot_lattice():\n\n    fs = site.fermionsite()\n    lat = tripartitetriangular(3, 3, fs)\n    lat.plot_sites(ax)\n    lat.plot_coupling(ax, lat.nn, linestyle='--', color='green')\n    lat.plot_coupling(ax, lat.nnna, linestyle='--', color='red')\n    lat.plot_coupling(ax, lat.nnnb, linestyle='--', color='blue')\n    lat.plot_coupling(ax, lat.nnnn, linestyle='--', color='black')\n    ax.set_aspect('equal')\n\n\ndef run(phi_ext=np.linspace(0, 1.0, 7)):\n    data = dict(phi_ext=phi_ext, ql=[], ent_spectrum=[])\n\n    model_params = dict(conserve='n', t=-1, v=0, lx=1, ly=3)\n\n    dmrg_params = {\n        'mixer': true,  # setting this to true helps to escape local minima\n        'mixer_params': {'amplitude': 1.0e-5, 'decay': 1.2, 'disable_after': 30},\n        'trunc_params': {\n            'svd_min': 1.0e-10,\n        },\n        'lanczos_params': {'n_min': 5, 'n_max': 20},\n        'chi_list': {0: 9, 10: 49, 20: 100},\n        'max_e_err': 1.0e-10,\n        'max_s_err': 1.0e-6,\n        'max_sweeps': 150,\n    }\n\n    prod_state = ['full_a empty_b', 'empty_a full_b', 'full_a empty_b'] * (model_params['lx'] * model_params['ly'])\n\n    eng = none\n\n    for phi in phi_ext:\n        print('=' * 100)\n        print('phi_ext = ', phi)\n\n        model_params['phi_ext'] = phi\n\n        if eng is none:  # first time in the loop\n            m = fermionicc3haldanemodel(model_params)\n            psi = mps.from_product_state(\n                m.lat.mps_sites(), prod_state, bc=m.lat.bc_mps, unit_cell_width=m.lat.mps_unit_cell_width\n            )\n            eng = dmrg.twositedmrgengine(psi, m, dmrg_params)\n        else:\n            del eng.options['chi_list']\n            m = fermionicc3haldanemodel(model_params)\n            eng.init_env(model=m)\n\n        e, psi = eng.run()\n\n        data['ql'].append(psi.average_charge(bond=0)[0])\n        data['ent_spectrum'].append(psi.entanglement_spectrum(by_charge=true)[0])\n\n    return data\n\n\ndef plot_results(data):\n\n    ax.plot(data['phi_ext'], data['ql'], marker='o')\n    ax.set_xlabel(r'$\\phi_y / 2 \\pi$')\n    ax.set_ylabel(r'$ \\langle q^l(\\phi_y) \\rangle$')\n\n    colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k']\n    color_by_charge = {}\n    for phi_ext, spectrum in zip(data['phi_ext'], data['ent_spectrum']):\n        for q, s in spectrum:\n            q = q[0]\n            label = ''\n            if q not in color_by_charge:\n                label = f'{q:d}'\n                color_by_charge[q] = colors[len(color_by_charge) % len(colors)]\n            color = color_by_charge[q]\n            ax.plot(phi_ext * np.ones(s.shape), s, linestyle='', marker='_', color=color, label=label)\n    ax.set_xlabel(r'$\\phi_y / 2 \\pi$')\n    ax.set_ylabel(r'$ \\epsilon_\\alpha $')\n    ax.set_ylim(0.0, 8.0)\n    ax.legend(loc='upper right')\n\n\nif __name__ == '__main__':\n    # plot_lattice()\n    data = run()\n    plot_results(data) example chern insulators haldane c3",
    "tokens": 2383
  },
  {
    "category": "examples",
    "name": "example.chern_insulators_haldane",
    "content": "# Example Source: haldane.py\n\"\"\"Spinless fermion Haldane model - Chern insulator example\n\nReproduces Fig. 2.a,b) in [Grushin2015]_\n\"\"\"\n\n# Copyright (C) TeNPy Developers, Apache license\n\nimport numpy as np\n\nfrom tenpy.algorithms import dmrg\nfrom tenpy.models.haldane import FermionicHaldaneModel\nfrom tenpy.networks.mps import MPS\n\n\ndef plot_model(model_params, phi_ext=0.1):\n    model_params['phi_ext'] = phi_ext\n    M = FermionicHaldaneModel(model_params)\n\n    M.lat.plot_sites(ax)\n    M.coupling_terms['t1 Cd_i C_j'].plot_coupling_terms(ax, M.lat)\n    M.coupling_terms['t2 Cd_i C_j'].plot_coupling_terms(ax, M.lat, text='{op_j!s} {strength_angle:.2f}', text_pos=0.9)\n    print(M.coupling_terms['t1 Cd_i C_j'].to_TermList())\n    ax.set_aspect(1.0)\n\n\ndef run(model_params, phi_ext=np.linspace(0, 1.0, 7)):\n    data = dict(phi_ext=phi_ext, QL=[], ent_spectrum=[])\n\n    dmrg_params = {\n        'mixer': True,  # setting this to True helps to escape local minima\n        'mixer_params': {'amplitude': 1.0e-5, 'decay': 1.2, 'disable_after': 30},\n        'trunc_params': {\n            'svd_min': 1.0e-10,\n        },\n        'lanczos_params': {'N_min': 5, 'N_max': 20},\n        'chi_list': {0: 9, 10: 49, 20: 100},\n        'max_E_err': 1.0e-10,\n        'max_S_err': 1.0e-6,\n        'max_sweeps': 150,\n    }\n\n    prod_state = ['empty', 'full'] * (model_params['Lx'] * model_params['Ly'])\n\n    eng = None\n\n    for phi in phi_ext:\n        print('=' * 100)\n        print('phi_ext = ', phi)\n\n        model_params['phi_ext'] = phi\n\n        if eng is None:  # first time in the loop\n            M = FermionicHaldaneModel(model_params)\n            psi = MPS.from_product_state(\n                M.lat.mps_sites(), prod_state, bc=M.lat.bc_MPS, unit_cell_width=M.lat.mps_unit_cell_width\n            )\n            eng = dmrg.TwoSiteDMRGEngine(psi, M, dmrg_params)\n        else:\n            del eng.options['chi_list']\n            M = FermionicHaldaneModel(model_params)\n            eng.init_env(model=M)\n\n        E, psi = eng.run()\n\n        data['QL'].append(psi.average_charge(bond=0)[0])\n        data['ent_spectrum'].append(psi.entanglement_spectrum(by_charge=True)[0])\n\n    return data\n\n\ndef plot_results(data):\n\n    ax.plot(data['phi_ext'], data['QL'], marker='o')\n    ax.set_xlabel(r'$\\Phi_y / 2 \\pi$')\n    ax.set_ylabel(r'$ \\langle Q^L(\\Phi_y) \\rangle$')\n\n    colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k']\n    color_by_charge = {}\n    for phi_ext, spectrum in zip(data['phi_ext'], data['ent_spectrum']):\n        for q, s in spectrum:\n            q = q[0]\n            label = ''\n            if q not in color_by_charge:\n                label = f'{q:d}'\n                color_by_charge[q] = colors[len(color_by_charge) % len(colors)]\n            color = color_by_charge[q]\n            ax.plot(phi_ext * np.ones(s.shape), s, linestyle='', marker='_', color=color, label=label)\n    ax.set_xlabel(r'$\\Phi_y / 2 \\pi$')\n    ax.set_ylabel(r'$ \\epsilon_\\alpha $')\n    ax.set_ylim(0.0, 8.0)\n    ax.legend(loc='upper right')\n\n\nif __name__ == '__main__':\n    t1_value = -1\n\n    phi = np.arccos(3 * np.sqrt(3 / 43))\n    t2_value = (np.sqrt(129) / 36) * t1_value * np.exp(1j * phi)  # optimal band flatness\n\n    model_params = dict(\n        conserve='N',\n        t1=t1_value,\n        t2=t2_value,\n        mu=0,\n        V=0,\n        bc_MPS='infinite',\n        order='default',\n        Lx=1,\n        Ly=3,\n        bc_y='cylinder',\n    )\n\n    #  plot_model(model_params)\n    data = run(model_params)\n    plot_results(data)",
    "search_text": "example.chern_insulators_haldane # example source: haldane.py\n\"\"\"spinless fermion haldane model - chern insulator example\n\nreproduces fig. 2.a,b) in [grushin2015]_\n\"\"\"\n\n# copyright (c) tenpy developers, apache license\n\nimport numpy as np\n\nfrom tenpy.algorithms import dmrg\nfrom tenpy.models.haldane import fermionichaldanemodel\nfrom tenpy.networks.mps import mps\n\n\ndef plot_model(model_params, phi_ext=0.1):\n    model_params['phi_ext'] = phi_ext\n    m = fermionichaldanemodel(model_params)\n\n    m.lat.plot_sites(ax)\n    m.coupling_terms['t1 cd_i c_j'].plot_coupling_terms(ax, m.lat)\n    m.coupling_terms['t2 cd_i c_j'].plot_coupling_terms(ax, m.lat, text='{op_j!s} {strength_angle:.2f}', text_pos=0.9)\n    print(m.coupling_terms['t1 cd_i c_j'].to_termlist())\n    ax.set_aspect(1.0)\n\n\ndef run(model_params, phi_ext=np.linspace(0, 1.0, 7)):\n    data = dict(phi_ext=phi_ext, ql=[], ent_spectrum=[])\n\n    dmrg_params = {\n        'mixer': true,  # setting this to true helps to escape local minima\n        'mixer_params': {'amplitude': 1.0e-5, 'decay': 1.2, 'disable_after': 30},\n        'trunc_params': {\n            'svd_min': 1.0e-10,\n        },\n        'lanczos_params': {'n_min': 5, 'n_max': 20},\n        'chi_list': {0: 9, 10: 49, 20: 100},\n        'max_e_err': 1.0e-10,\n        'max_s_err': 1.0e-6,\n        'max_sweeps': 150,\n    }\n\n    prod_state = ['empty', 'full'] * (model_params['lx'] * model_params['ly'])\n\n    eng = none\n\n    for phi in phi_ext:\n        print('=' * 100)\n        print('phi_ext = ', phi)\n\n        model_params['phi_ext'] = phi\n\n        if eng is none:  # first time in the loop\n            m = fermionichaldanemodel(model_params)\n            psi = mps.from_product_state(\n                m.lat.mps_sites(), prod_state, bc=m.lat.bc_mps, unit_cell_width=m.lat.mps_unit_cell_width\n            )\n            eng = dmrg.twositedmrgengine(psi, m, dmrg_params)\n        else:\n            del eng.options['chi_list']\n            m = fermionichaldanemodel(model_params)\n            eng.init_env(model=m)\n\n        e, psi = eng.run()\n\n        data['ql'].append(psi.average_charge(bond=0)[0])\n        data['ent_spectrum'].append(psi.entanglement_spectrum(by_charge=true)[0])\n\n    return data\n\n\ndef plot_results(data):\n\n    ax.plot(data['phi_ext'], data['ql'], marker='o')\n    ax.set_xlabel(r'$\\phi_y / 2 \\pi$')\n    ax.set_ylabel(r'$ \\langle q^l(\\phi_y) \\rangle$')\n\n    colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k']\n    color_by_charge = {}\n    for phi_ext, spectrum in zip(data['phi_ext'], data['ent_spectrum']):\n        for q, s in spectrum:\n            q = q[0]\n            label = ''\n            if q not in color_by_charge:\n                label = f'{q:d}'\n                color_by_charge[q] = colors[len(color_by_charge) % len(colors)]\n            color = color_by_charge[q]\n            ax.plot(phi_ext * np.ones(s.shape), s, linestyle='', marker='_', color=color, label=label)\n    ax.set_xlabel(r'$\\phi_y / 2 \\pi$')\n    ax.set_ylabel(r'$ \\epsilon_\\alpha $')\n    ax.set_ylim(0.0, 8.0)\n    ax.legend(loc='upper right')\n\n\nif __name__ == '__main__':\n    t1_value = -1\n\n    phi = np.arccos(3 * np.sqrt(3 / 43))\n    t2_value = (np.sqrt(129) / 36) * t1_value * np.exp(1j * phi)  # optimal band flatness\n\n    model_params = dict(\n        conserve='n',\n        t1=t1_value,\n        t2=t2_value,\n        mu=0,\n        v=0,\n        bc_mps='infinite',\n        order='default',\n        lx=1,\n        ly=3,\n        bc_y='cylinder',\n    )\n\n    #  plot_model(model_params)\n    data = run(model_params)\n    plot_results(data) example chern insulators haldane",
    "tokens": 1058
  },
  {
    "category": "examples",
    "name": "example.userguide_g_dmrg_infinite",
    "content": "# Example Source: g_dmrg_infinite.py\n\"\"\"Call of infinite DMRG.\"\"\"\n\nfrom tenpy.algorithms import dmrg\nfrom tenpy.models.tf_ising import TFIChain\nfrom tenpy.networks.mps import MPS\n\nN = 2  # number of sites in unit cell\nmodel = TFIChain({'L': N, 'J': 1.0, 'g': 1.1, 'bc_MPS': 'infinite'})\nsites = model.lat.mps_sites()\npsi = MPS.from_product_state(sites, ['up'] * N, 'infinite', unit_cell_width=N)\ndmrg_params = {'trunc_params': {'chi_max': 100, 'svd_min': 1.0e-10}, 'mixer': True}\ninfo = dmrg.run(psi, model, dmrg_params)\nprint('E =', info['E'])\n# E = -1.342864022725017\nprint('max. bond dimension =', max(psi.chi))\n# max. bond dimension = 56\nprint('corr. length =', psi.correlation_length())\n# corr. length = 4.915809146764157",
    "search_text": "example.userguide_g_dmrg_infinite # example source: g_dmrg_infinite.py\n\"\"\"call of infinite dmrg.\"\"\"\n\nfrom tenpy.algorithms import dmrg\nfrom tenpy.models.tf_ising import tfichain\nfrom tenpy.networks.mps import mps\n\nn = 2  # number of sites in unit cell\nmodel = tfichain({'l': n, 'j': 1.0, 'g': 1.1, 'bc_mps': 'infinite'})\nsites = model.lat.mps_sites()\npsi = mps.from_product_state(sites, ['up'] * n, 'infinite', unit_cell_width=n)\ndmrg_params = {'trunc_params': {'chi_max': 100, 'svd_min': 1.0e-10}, 'mixer': true}\ninfo = dmrg.run(psi, model, dmrg_params)\nprint('e =', info['e'])\n# e = -1.342864022725017\nprint('max. bond dimension =', max(psi.chi))\n# max. bond dimension = 56\nprint('corr. length =', psi.correlation_length())\n# corr. length = 4.915809146764157 example userguide g dmrg infinite",
    "tokens": 248
  },
  {
    "category": "examples",
    "name": "example.userguide_e_model_2D",
    "content": "# Example Source: e_model_2D.py\n\"\"\"Initialization of the Heisenberg model on a kagome lattice.\"\"\"\n\nfrom tenpy.models.spins import SpinModel\n\nmodel_params = {\n    'S': 0.5,  # Spin 1/2\n    'lattice': 'Kagome',\n    'bc_MPS': 'infinite',\n    'bc_y': 'cylinder',\n    'Ly': 2,  # defines cylinder circumference\n    'conserve': 'Sz',  # use Sz conservation\n    'Jx': 1.0,\n    'Jy': 1.0,\n    'Jz': 1.0,  # Heisenberg coupling\n}\nmodel = SpinModel(model_params)",
    "search_text": "example.userguide_e_model_2d # example source: e_model_2d.py\n\"\"\"initialization of the heisenberg model on a kagome lattice.\"\"\"\n\nfrom tenpy.models.spins import spinmodel\n\nmodel_params = {\n    's': 0.5,  # spin 1/2\n    'lattice': 'kagome',\n    'bc_mps': 'infinite',\n    'bc_y': 'cylinder',\n    'ly': 2,  # defines cylinder circumference\n    'conserve': 'sz',  # use sz conservation\n    'jx': 1.0,\n    'jy': 1.0,\n    'jz': 1.0,  # heisenberg coupling\n}\nmodel = spinmodel(model_params) example userguide e model 2d",
    "tokens": 158
  },
  {
    "category": "examples",
    "name": "example.userguide_c_mps_mpo",
    "content": "# Example Source: c_mps_mpo.py\n\"\"\"Initialization of sites, MPS and MPO.\"\"\"\n\nfrom tenpy.networks.mpo import MPO\nfrom tenpy.networks.mps import MPS\nfrom tenpy.networks.site import SpinHalfSite\n\nspin = SpinHalfSite(conserve='Sz')\n\nN = 6  # number of sites\nsites = [spin] * N  # repeat entry of list N times\npstate = ['up', 'down'] * (N // 2)  # Neel state\npsi = MPS.from_product_state(sites, pstate, bc='finite', unit_cell_width=N)\nprint('<Sz> =', psi.expectation_value('Sz'))\n# <Sz> = [ 0.5 -0.5  0.5 -0.5  0.5 -0.5]\nprint('<Sp_i Sm_j> =', psi.correlation_function('Sp', 'Sm'), sep='\\n')\n# <Sp_i Sm_j> =\n# [[1. 0. 0. 0. 0. 0.]\n#  [0. 0. 0. 0. 0. 0.]\n#  [0. 0. 1. 0. 0. 0.]\n#  [0. 0. 0. 0. 0. 0.]\n#  [0. 0. 0. 0. 1. 0.]\n#  [0. 0. 0. 0. 0. 0.]]\n\n# define an MPO\nId, Sp, Sm, Sz = spin.Id, spin.Sp, spin.Sm, spin.Sz\nJ, Delta, hz = 1.0, 1.0, 0.2\nW_bulk = [\n    [Id, Sp, Sm, Sz, -hz * Sz],\n    [None, None, None, None, 0.5 * J * Sm],\n    [None, None, None, None, 0.5 * J * Sp],\n    [None, None, None, None, J * Delta * Sz],\n    [None, None, None, None, Id],\n]\nW_first = [W_bulk[0]]  # first row\nW_last = [[row[-1]] for row in W_bulk]  # last column\nWs = [W_first] + [W_bulk] * (N - 2) + [W_last]\nH = MPO.from_grids([spin] * N, Ws, bc='finite', IdL=0, IdR=-1, mps_unit_cell_width=N)\nprint('<psi|H|psi> =', H.expectation_value(psi))\n# <psi|H|psi> = -1.25",
    "search_text": "example.userguide_c_mps_mpo # example source: c_mps_mpo.py\n\"\"\"initialization of sites, mps and mpo.\"\"\"\n\nfrom tenpy.networks.mpo import mpo\nfrom tenpy.networks.mps import mps\nfrom tenpy.networks.site import spinhalfsite\n\nspin = spinhalfsite(conserve='sz')\n\nn = 6  # number of sites\nsites = [spin] * n  # repeat entry of list n times\npstate = ['up', 'down'] * (n // 2)  # neel state\npsi = mps.from_product_state(sites, pstate, bc='finite', unit_cell_width=n)\nprint('<sz> =', psi.expectation_value('sz'))\n# <sz> = [ 0.5 -0.5  0.5 -0.5  0.5 -0.5]\nprint('<sp_i sm_j> =', psi.correlation_function('sp', 'sm'), sep='\\n')\n# <sp_i sm_j> =\n# [[1. 0. 0. 0. 0. 0.]\n#  [0. 0. 0. 0. 0. 0.]\n#  [0. 0. 1. 0. 0. 0.]\n#  [0. 0. 0. 0. 0. 0.]\n#  [0. 0. 0. 0. 1. 0.]\n#  [0. 0. 0. 0. 0. 0.]]\n\n# define an mpo\nid, sp, sm, sz = spin.id, spin.sp, spin.sm, spin.sz\nj, delta, hz = 1.0, 1.0, 0.2\nw_bulk = [\n    [id, sp, sm, sz, -hz * sz],\n    [none, none, none, none, 0.5 * j * sm],\n    [none, none, none, none, 0.5 * j * sp],\n    [none, none, none, none, j * delta * sz],\n    [none, none, none, none, id],\n]\nw_first = [w_bulk[0]]  # first row\nw_last = [[row[-1]] for row in w_bulk]  # last column\nws = [w_first] + [w_bulk] * (n - 2) + [w_last]\nh = mpo.from_grids([spin] * n, ws, bc='finite', idl=0, idr=-1, mps_unit_cell_width=n)\nprint('<psi|h|psi> =', h.expectation_value(psi))\n# <psi|h|psi> = -1.25 example userguide c mps mpo",
    "tokens": 592
  },
  {
    "category": "examples",
    "name": "example.userguide_b_npc_arrays",
    "content": "# Example Source: b_npc_arrays.py\n\"\"\"Explicit definition of charges and spin-1/2 operators.\"\"\"\n\nimport tenpy.linalg.np_conserved as npc\n\n# consider spin-1/2 with Sz-conservation\nchinfo = npc.ChargeInfo([1])  # just a U(1) charge\n# charges for up, down state\np_leg = npc.LegCharge.from_qflat(chinfo, [[1], [-1]])\nSz = npc.Array.from_ndarray([[0.5, 0.0], [0.0, -0.5]], [p_leg, p_leg.conj()])\nSp = npc.Array.from_ndarray([[0.0, 1.0], [0.0, 0.0]], [p_leg, p_leg.conj()])\nSm = npc.Array.from_ndarray([[0.0, 0.0], [1.0, 0.0]], [p_leg, p_leg.conj()])\n\nHxy = 0.5 * (npc.outer(Sp, Sm) + npc.outer(Sm, Sp))\nHz = npc.outer(Sz, Sz)\nH = Hxy + Hz\n# here, H has 4 legs\nH.iset_leg_labels(['s1', 't1', 's2', 't2'])\nH = H.combine_legs([['s1', 's2'], ['t1', 't2']], qconj=[+1, -1])\n# here, H has 2 legs\nprint(H.legs[0].to_qflat().flatten())\n# prints [-2  0  0  2]\nE, U = npc.eigh(H)  # diagonalize blocks individually\nprint(E)\n# [ 0.25 -0.75  0.25  0.25]",
    "search_text": "example.userguide_b_npc_arrays # example source: b_npc_arrays.py\n\"\"\"explicit definition of charges and spin-1/2 operators.\"\"\"\n\nimport tenpy.linalg.np_conserved as npc\n\n# consider spin-1/2 with sz-conservation\nchinfo = npc.chargeinfo([1])  # just a u(1) charge\n# charges for up, down state\np_leg = npc.legcharge.from_qflat(chinfo, [[1], [-1]])\nsz = npc.array.from_ndarray([[0.5, 0.0], [0.0, -0.5]], [p_leg, p_leg.conj()])\nsp = npc.array.from_ndarray([[0.0, 1.0], [0.0, 0.0]], [p_leg, p_leg.conj()])\nsm = npc.array.from_ndarray([[0.0, 0.0], [1.0, 0.0]], [p_leg, p_leg.conj()])\n\nhxy = 0.5 * (npc.outer(sp, sm) + npc.outer(sm, sp))\nhz = npc.outer(sz, sz)\nh = hxy + hz\n# here, h has 4 legs\nh.iset_leg_labels(['s1', 't1', 's2', 't2'])\nh = h.combine_legs([['s1', 's2'], ['t1', 't2']], qconj=[+1, -1])\n# here, h has 2 legs\nprint(h.legs[0].to_qflat().flatten())\n# prints [-2  0  0  2]\ne, u = npc.eigh(h)  # diagonalize blocks individually\nprint(e)\n# [ 0.25 -0.75  0.25  0.25] example userguide b npc arrays",
    "tokens": 379
  },
  {
    "category": "examples",
    "name": "example.userguide_h_tebd_infinite",
    "content": "# Example Source: h_tebd_infinite.py\n\"\"\"Call of (infinite) TEBD.\"\"\"\n\nfrom tenpy.algorithms import tebd\nfrom tenpy.models.tf_ising import TFIChain\nfrom tenpy.networks.mps import MPS\n\nM = TFIChain({'L': 2, 'J': 1.0, 'g': 1.5, 'bc_MPS': 'infinite'})\npsi = MPS.from_product_state(M.lat.mps_sites(), [0] * 2, 'infinite', unit_cell_width=M.lat.mps_unit_cell_width)\ntebd_params = {\n    'order': 2,\n    'delta_tau_list': [0.1, 0.001, 1.0e-5],\n    'max_error_E': 1.0e-6,\n    'trunc_params': {'chi_max': 30, 'svd_min': 1.0e-10},\n}\neng = tebd.TEBDEngine(psi, M, tebd_params)\neng.run_GS()  # imaginary time evolution with TEBD\nprint('E =', sum(psi.expectation_value(M.H_bond)) / psi.L)\nprint('final bond dimensions: ', psi.chi)",
    "search_text": "example.userguide_h_tebd_infinite # example source: h_tebd_infinite.py\n\"\"\"call of (infinite) tebd.\"\"\"\n\nfrom tenpy.algorithms import tebd\nfrom tenpy.models.tf_ising import tfichain\nfrom tenpy.networks.mps import mps\n\nm = tfichain({'l': 2, 'j': 1.0, 'g': 1.5, 'bc_mps': 'infinite'})\npsi = mps.from_product_state(m.lat.mps_sites(), [0] * 2, 'infinite', unit_cell_width=m.lat.mps_unit_cell_width)\ntebd_params = {\n    'order': 2,\n    'delta_tau_list': [0.1, 0.001, 1.0e-5],\n    'max_error_e': 1.0e-6,\n    'trunc_params': {'chi_max': 30, 'svd_min': 1.0e-10},\n}\neng = tebd.tebdengine(psi, m, tebd_params)\neng.run_gs()  # imaginary time evolution with tebd\nprint('e =', sum(psi.expectation_value(m.h_bond)) / psi.l)\nprint('final bond dimensions: ', psi.chi) example userguide h tebd infinite",
    "tokens": 264
  },
  {
    "category": "examples",
    "name": "example.userguide_a_npc_arrays_triv",
    "content": "# Example Source: a_npc_arrays_triv.py\n\"\"\"Basic use of the `Array` class with trivial arrays.\"\"\"\n\nimport tenpy.linalg.np_conserved as npc\n\nM = npc.Array.from_ndarray_trivial([[0.0, 1.0], [1.0, 0.0]])\nv = npc.Array.from_ndarray_trivial([2.0, 4.0 + 1.0j])\nv[0] = 3.0  # set indiviual entries like in numpy\nprint('|v> =', v.to_ndarray())\n# |v> = [ 3.+0.j  4.+1.j]\n\nM_v = npc.tensordot(M, v, axes=[1, 0])\nprint('M|v> =', M_v.to_ndarray())\n# M|v> = [ 4.+1.j  3.+0.j]\nprint('<v|M|v> =', npc.inner(v.conj(), M_v, axes='range'))\n# <v|M|v> = (24+0j)",
    "search_text": "example.userguide_a_npc_arrays_triv # example source: a_npc_arrays_triv.py\n\"\"\"basic use of the `array` class with trivial arrays.\"\"\"\n\nimport tenpy.linalg.np_conserved as npc\n\nm = npc.array.from_ndarray_trivial([[0.0, 1.0], [1.0, 0.0]])\nv = npc.array.from_ndarray_trivial([2.0, 4.0 + 1.0j])\nv[0] = 3.0  # set indiviual entries like in numpy\nprint('|v> =', v.to_ndarray())\n# |v> = [ 3.+0.j  4.+1.j]\n\nm_v = npc.tensordot(m, v, axes=[1, 0])\nprint('m|v> =', m_v.to_ndarray())\n# m|v> = [ 4.+1.j  3.+0.j]\nprint('<v|m|v> =', npc.inner(v.conj(), m_v, axes='range'))\n# <v|m|v> = (24+0j) example userguide a npc arrays triv",
    "tokens": 226
  },
  {
    "category": "examples",
    "name": "example.userguide_d_model_1D",
    "content": "# Example Source: d_model_1D.py\n\"\"\"Definition of a model: the XXZ chain.\"\"\"\n\nfrom tenpy.models.lattice import Chain\nfrom tenpy.models.model import CouplingModel, MPOModel, NearestNeighborModel\nfrom tenpy.networks.site import SpinSite\n\n\nclass XXZChain(CouplingModel, NearestNeighborModel, MPOModel):\n    def __init__(self, L=2, S=0.5, J=1.0, Delta=1.0, hz=0.0):\n        spin = SpinSite(S=S, conserve='Sz')\n        # the lattice defines the geometry\n        lattice = Chain(L, spin, bc='open', bc_MPS='finite')\n        CouplingModel.__init__(self, lattice)\n        # add terms of the Hamiltonian\n        self.add_coupling(J * 0.5, 0, 'Sp', 0, 'Sm', 1)  # Sp_i Sm_{i+1}\n        self.add_coupling(J * 0.5, 0, 'Sp', 0, 'Sm', -1)  # Sp_i Sm_{i-1}\n        self.add_coupling(J * Delta, 0, 'Sz', 0, 'Sz', 1)\n        # (for site dependent prefactors, the strength can be an array)\n        self.add_onsite(-hz, 0, 'Sz')\n\n        # finish initialization\n        # generate MPO for DMRG\n        MPOModel.__init__(self, lattice, self.calc_H_MPO())\n        # generate H_bond for TEBD\n        NearestNeighborModel.__init__(self, lattice, self.calc_H_bond())",
    "search_text": "example.userguide_d_model_1d # example source: d_model_1d.py\n\"\"\"definition of a model: the xxz chain.\"\"\"\n\nfrom tenpy.models.lattice import chain\nfrom tenpy.models.model import couplingmodel, mpomodel, nearestneighbormodel\nfrom tenpy.networks.site import spinsite\n\n\nclass xxzchain(couplingmodel, nearestneighbormodel, mpomodel):\n    def __init__(self, l=2, s=0.5, j=1.0, delta=1.0, hz=0.0):\n        spin = spinsite(s=s, conserve='sz')\n        # the lattice defines the geometry\n        lattice = chain(l, spin, bc='open', bc_mps='finite')\n        couplingmodel.__init__(self, lattice)\n        # add terms of the hamiltonian\n        self.add_coupling(j * 0.5, 0, 'sp', 0, 'sm', 1)  # sp_i sm_{i+1}\n        self.add_coupling(j * 0.5, 0, 'sp', 0, 'sm', -1)  # sp_i sm_{i-1}\n        self.add_coupling(j * delta, 0, 'sz', 0, 'sz', 1)\n        # (for site dependent prefactors, the strength can be an array)\n        self.add_onsite(-hz, 0, 'sz')\n\n        # finish initialization\n        # generate mpo for dmrg\n        mpomodel.__init__(self, lattice, self.calc_h_mpo())\n        # generate h_bond for tebd\n        nearestneighbormodel.__init__(self, lattice, self.calc_h_bond()) example userguide d model 1d",
    "tokens": 362
  },
  {
    "category": "examples",
    "name": "example.userguide_f_dmrg_finite",
    "content": "# Example Source: f_dmrg_finite.py\n\"\"\"Call of (finite) DMRG.\"\"\"\n\nfrom tenpy.algorithms import dmrg\nfrom tenpy.models.tf_ising import TFIChain\nfrom tenpy.networks.mps import MPS\n\nN = 16  # number of sites\nmodel = TFIChain({'L': N, 'J': 1.0, 'g': 1.0, 'bc_MPS': 'finite'})\nsites = model.lat.mps_sites()\npsi = MPS.from_product_state(sites, ['up'] * N, 'finite', unit_cell_width=N)\ndmrg_params = {'trunc_params': {'chi_max': 100, 'svd_min': 1.0e-10}, 'mixer': True}\ninfo = dmrg.run(psi, model, dmrg_params)\nprint('E =', info['E'])\n# E = -20.01638790048513\nprint('max. bond dimension =', max(psi.chi))\n# max. bond dimension = 27",
    "search_text": "example.userguide_f_dmrg_finite # example source: f_dmrg_finite.py\n\"\"\"call of (finite) dmrg.\"\"\"\n\nfrom tenpy.algorithms import dmrg\nfrom tenpy.models.tf_ising import tfichain\nfrom tenpy.networks.mps import mps\n\nn = 16  # number of sites\nmodel = tfichain({'l': n, 'j': 1.0, 'g': 1.0, 'bc_mps': 'finite'})\nsites = model.lat.mps_sites()\npsi = mps.from_product_state(sites, ['up'] * n, 'finite', unit_cell_width=n)\ndmrg_params = {'trunc_params': {'chi_max': 100, 'svd_min': 1.0e-10}, 'mixer': true}\ninfo = dmrg.run(psi, model, dmrg_params)\nprint('e =', info['e'])\n# e = -20.01638790048513\nprint('max. bond dimension =', max(psi.chi))\n# max. bond dimension = 27 example userguide f dmrg finite",
    "tokens": 219
  },
  {
    "category": "api",
    "name": "tenpy.__init__.show_config",
    "content": "# API Function: tenpy.__init__.show_config\ndef show_config():\n    \"\"\"Print information about the version of tenpy and used libraries.\"\"\"",
    "search_text": "tenpy.__init__.show_config # api function: tenpy.__init__.show_config\ndef show_config():\n    \"\"\"print information about the version of tenpy and used libraries.\"\"\" function show_config",
    "tokens": 30
  },
  {
    "category": "api",
    "name": "tenpy.__init__.console_main",
    "content": "# API Function: tenpy.__init__.console_main\ndef console_main(*command_line_args):\n    \"\"\"Command line interface.\"\"\"",
    "search_text": "tenpy.__init__.console_main # api function: tenpy.__init__.console_main\ndef console_main(*command_line_args):\n    \"\"\"command line interface.\"\"\" function console_main",
    "tokens": 26
  },
  {
    "category": "api",
    "name": "tenpy.linalg.krylov_based.KrylovBased",
    "content": "# API Definition: tenpy.linalg.krylov_based.KrylovBased\nclass KrylovBased:\n    \"\"\"Base class for iterative algorithms building a Krylov basis with np_conserved arrays.\"\"\"\n    def __init__(self, H, psi0, options): pass\n    def run(self): pass\n    def iscale_prefactor(self, w, scale): pass\n    def iadd_prefactor_other(self, w, alpha, v): pass",
    "search_text": "tenpy.linalg.krylov_based.krylovbased # api definition: tenpy.linalg.krylov_based.krylovbased\nclass krylovbased:\n    \"\"\"base class for iterative algorithms building a krylov basis with np_conserved arrays.\"\"\"\n    def __init__(self, h, psi0, options): pass\n    def run(self): pass\n    def iscale_prefactor(self, w, scale): pass\n    def iadd_prefactor_other(self, w, alpha, v): pass class krylovbased tenpy.linalg.krylov_based",
    "tokens": 94
  },
  {
    "category": "api",
    "name": "tenpy.linalg.krylov_based.GMRES",
    "content": "# API Definition: tenpy.linalg.krylov_based.GMRES\nclass GMRES:\n    def __init__(self, A, x, b, options): pass\n    def run(self): pass\n    def arnoldi(self, k): pass\n    def apply_givens_rotation(self, k): pass\n    def givens_rotation(self, k): pass\n    def backsolve(self, k): pass\n    def reset(self): pass",
    "search_text": "tenpy.linalg.krylov_based.gmres # api definition: tenpy.linalg.krylov_based.gmres\nclass gmres:\n    def __init__(self, a, x, b, options): pass\n    def run(self): pass\n    def arnoldi(self, k): pass\n    def apply_givens_rotation(self, k): pass\n    def givens_rotation(self, k): pass\n    def backsolve(self, k): pass\n    def reset(self): pass class gmres tenpy.linalg.krylov_based",
    "tokens": 96
  },
  {
    "category": "api",
    "name": "tenpy.linalg.krylov_based.Arnoldi",
    "content": "# API Definition: tenpy.linalg.krylov_based.Arnoldi\nclass Arnoldi:\n    \"\"\"Arnoldi method for diagonalizing square, non-hermitian/symmetric matrices.\"\"\"\n    def __init__(self, H, psi0, options): pass\n    def run(self):\n        \"\"\"Find the ground state of self.H.\"\"\"",
    "search_text": "tenpy.linalg.krylov_based.arnoldi # api definition: tenpy.linalg.krylov_based.arnoldi\nclass arnoldi:\n    \"\"\"arnoldi method for diagonalizing square, non-hermitian/symmetric matrices.\"\"\"\n    def __init__(self, h, psi0, options): pass\n    def run(self):\n        \"\"\"find the ground state of self.h.\"\"\" class arnoldi tenpy.linalg.krylov_based",
    "tokens": 71
  },
  {
    "category": "api",
    "name": "tenpy.linalg.krylov_based.LanczosGroundState",
    "content": "# API Definition: tenpy.linalg.krylov_based.LanczosGroundState\nclass LanczosGroundState:\n    \"\"\"Lanczos algorithm to find the ground state.\"\"\"\n    def __init__(self, H, psi0, options): pass\n    def run(self):\n        \"\"\"Find the ground state of H.\"\"\"",
    "search_text": "tenpy.linalg.krylov_based.lanczosgroundstate # api definition: tenpy.linalg.krylov_based.lanczosgroundstate\nclass lanczosgroundstate:\n    \"\"\"lanczos algorithm to find the ground state.\"\"\"\n    def __init__(self, h, psi0, options): pass\n    def run(self):\n        \"\"\"find the ground state of h.\"\"\" class lanczosgroundstate tenpy.linalg.krylov_based",
    "tokens": 65
  },
  {
    "category": "api",
    "name": "tenpy.linalg.krylov_based.LanczosEvolution",
    "content": "# API Definition: tenpy.linalg.krylov_based.LanczosEvolution\nclass LanczosEvolution:\n    \"\"\"Calculate :math:`exp(delta H) |psi0>` using Lanczos.\"\"\"\n    def __init__(self, H, psi0, options): pass\n    def run(self, delta, normalize=None):\n        \"\"\"Calculate ``expm(delta H).dot(psi0)`` using Lanczos.\"\"\"",
    "search_text": "tenpy.linalg.krylov_based.lanczosevolution # api definition: tenpy.linalg.krylov_based.lanczosevolution\nclass lanczosevolution:\n    \"\"\"calculate :math:`exp(delta h) |psi0>` using lanczos.\"\"\"\n    def __init__(self, h, psi0, options): pass\n    def run(self, delta, normalize=none):\n        \"\"\"calculate ``expm(delta h).dot(psi0)`` using lanczos.\"\"\" class lanczosevolution tenpy.linalg.krylov_based",
    "tokens": 86
  },
  {
    "category": "api",
    "name": "tenpy.linalg.krylov_based.lanczos_arpack",
    "content": "# API Function: tenpy.linalg.krylov_based.lanczos_arpack\ndef lanczos_arpack(H, psi, options={}):\n    \"\"\"Use :func:`scipy.sparse.linalg.eigsh` to find the ground state of `H`.\"\"\"",
    "search_text": "tenpy.linalg.krylov_based.lanczos_arpack # api function: tenpy.linalg.krylov_based.lanczos_arpack\ndef lanczos_arpack(h, psi, options={}):\n    \"\"\"use :func:`scipy.sparse.linalg.eigsh` to find the ground state of `h`.\"\"\" function lanczos_arpack",
    "tokens": 53
  },
  {
    "category": "api",
    "name": "tenpy.linalg.krylov_based.gram_schmidt",
    "content": "# API Function: tenpy.linalg.krylov_based.gram_schmidt\ndef gram_schmidt(vecs, rcond=1e-14):\n    \"\"\"In place Gram-Schmidt Orthogonalization and normalization for npc Arrays.\"\"\"",
    "search_text": "tenpy.linalg.krylov_based.gram_schmidt # api function: tenpy.linalg.krylov_based.gram_schmidt\ndef gram_schmidt(vecs, rcond=1e-14):\n    \"\"\"in place gram-schmidt orthogonalization and normalization for npc arrays.\"\"\" function gram_schmidt",
    "tokens": 50
  },
  {
    "category": "api",
    "name": "tenpy.linalg.krylov_based.iscale_prefactor",
    "content": "# API Function: tenpy.linalg.krylov_based.iscale_prefactor\ndef iscale_prefactor(w, scale): pass",
    "search_text": "tenpy.linalg.krylov_based.iscale_prefactor # api function: tenpy.linalg.krylov_based.iscale_prefactor\ndef iscale_prefactor(w, scale): pass function iscale_prefactor",
    "tokens": 26
  },
  {
    "category": "api",
    "name": "tenpy.linalg.krylov_based.iadd_prefactor_other",
    "content": "# API Function: tenpy.linalg.krylov_based.iadd_prefactor_other\ndef iadd_prefactor_other(w, alpha, v): pass",
    "search_text": "tenpy.linalg.krylov_based.iadd_prefactor_other # api function: tenpy.linalg.krylov_based.iadd_prefactor_other\ndef iadd_prefactor_other(w, alpha, v): pass function iadd_prefactor_other",
    "tokens": 30
  },
  {
    "category": "api",
    "name": "tenpy.linalg.krylov_based.plot_stats",
    "content": "# API Function: tenpy.linalg.krylov_based.plot_stats\ndef plot_stats(ax, Es):\n    \"\"\"Plot the convergence of the energies.\"\"\"",
    "search_text": "tenpy.linalg.krylov_based.plot_stats # api function: tenpy.linalg.krylov_based.plot_stats\ndef plot_stats(ax, es):\n    \"\"\"plot the convergence of the energies.\"\"\" function plot_stats",
    "tokens": 30
  },
  {
    "category": "api",
    "name": "tenpy.linalg.sparse.NpcLinearOperator",
    "content": "# API Definition: tenpy.linalg.sparse.NpcLinearOperator\nclass NpcLinearOperator:\n    \"\"\"Prototype for a Linear Operator acting on :class:`~tenpy.linalg.np_conserved.Array`.\"\"\"\n    def matvec(self, vec):\n        \"\"\"Calculate the action of the operator on a vector `vec`.\"\"\"\n    def to_matrix(self):\n        \"\"\"Contract `self` to a matrix.\"\"\"\n    def adjoint(self):\n        \"\"\"Return the hermitian conjugate of `self`\"\"\"",
    "search_text": "tenpy.linalg.sparse.npclinearoperator # api definition: tenpy.linalg.sparse.npclinearoperator\nclass npclinearoperator:\n    \"\"\"prototype for a linear operator acting on :class:`~tenpy.linalg.np_conserved.array`.\"\"\"\n    def matvec(self, vec):\n        \"\"\"calculate the action of the operator on a vector `vec`.\"\"\"\n    def to_matrix(self):\n        \"\"\"contract `self` to a matrix.\"\"\"\n    def adjoint(self):\n        \"\"\"return the hermitian conjugate of `self`\"\"\" class npclinearoperator tenpy.linalg.sparse",
    "tokens": 100
  },
  {
    "category": "api",
    "name": "tenpy.linalg.sparse.NpcLinearOperatorWrapper",
    "content": "# API Definition: tenpy.linalg.sparse.NpcLinearOperatorWrapper\nclass NpcLinearOperatorWrapper:\n    \"\"\"Base class for wrapping around another :class:`NpcLinearOperator`.\"\"\"\n    def __init__(self, orig_operator): pass\n    def unwrapped(self):\n        \"\"\"Return to the original NpcLinearOperator.\"\"\"\n    def to_matrix(self):\n        \"\"\"Contract `self` to a matrix.\"\"\"\n    def adjoint(self):\n        \"\"\"Return the hermitian conjugate of `self`.\"\"\"",
    "search_text": "tenpy.linalg.sparse.npclinearoperatorwrapper # api definition: tenpy.linalg.sparse.npclinearoperatorwrapper\nclass npclinearoperatorwrapper:\n    \"\"\"base class for wrapping around another :class:`npclinearoperator`.\"\"\"\n    def __init__(self, orig_operator): pass\n    def unwrapped(self):\n        \"\"\"return to the original npclinearoperator.\"\"\"\n    def to_matrix(self):\n        \"\"\"contract `self` to a matrix.\"\"\"\n    def adjoint(self):\n        \"\"\"return the hermitian conjugate of `self`.\"\"\" class npclinearoperatorwrapper tenpy.linalg.sparse",
    "tokens": 103
  },
  {
    "category": "api",
    "name": "tenpy.linalg.sparse.SumNpcLinearOperator",
    "content": "# API Definition: tenpy.linalg.sparse.SumNpcLinearOperator\nclass SumNpcLinearOperator:\n    \"\"\"Sum of two linear operators.\"\"\"\n    def __init__(self, orig_operator, other_operator): pass\n    def matvec(self, vec): pass\n    def to_matrix(self): pass\n    def adjoint(self): pass",
    "search_text": "tenpy.linalg.sparse.sumnpclinearoperator # api definition: tenpy.linalg.sparse.sumnpclinearoperator\nclass sumnpclinearoperator:\n    \"\"\"sum of two linear operators.\"\"\"\n    def __init__(self, orig_operator, other_operator): pass\n    def matvec(self, vec): pass\n    def to_matrix(self): pass\n    def adjoint(self): pass class sumnpclinearoperator tenpy.linalg.sparse",
    "tokens": 69
  },
  {
    "category": "api",
    "name": "tenpy.linalg.sparse.ShiftNpcLinearOperator",
    "content": "# API Definition: tenpy.linalg.sparse.ShiftNpcLinearOperator\nclass ShiftNpcLinearOperator:\n    \"\"\"Represents ``original_operator + shift * identity``.\"\"\"\n    def __init__(self, orig_operator, shift): pass\n    def matvec(self, vec): pass\n    def to_matrix(self): pass\n    def adjoint(self): pass",
    "search_text": "tenpy.linalg.sparse.shiftnpclinearoperator # api definition: tenpy.linalg.sparse.shiftnpclinearoperator\nclass shiftnpclinearoperator:\n    \"\"\"represents ``original_operator + shift * identity``.\"\"\"\n    def __init__(self, orig_operator, shift): pass\n    def matvec(self, vec): pass\n    def to_matrix(self): pass\n    def adjoint(self): pass class shiftnpclinearoperator tenpy.linalg.sparse",
    "tokens": 74
  },
  {
    "category": "api",
    "name": "tenpy.linalg.sparse.BoostNpcLinearOperator",
    "content": "# API Definition: tenpy.linalg.sparse.BoostNpcLinearOperator\nclass BoostNpcLinearOperator:\n    \"\"\"Represents ``original_operator + shift_i * |vec_i><vec_i|``.\"\"\"\n    def __init__(self, orig_operator, boosts, boost_vecs): pass\n    def matvec(self, vec): pass\n    def to_matrix(self): pass\n    def adjoint(self): pass",
    "search_text": "tenpy.linalg.sparse.boostnpclinearoperator # api definition: tenpy.linalg.sparse.boostnpclinearoperator\nclass boostnpclinearoperator:\n    \"\"\"represents ``original_operator + shift_i * |vec_i><vec_i|``.\"\"\"\n    def __init__(self, orig_operator, boosts, boost_vecs): pass\n    def matvec(self, vec): pass\n    def to_matrix(self): pass\n    def adjoint(self): pass class boostnpclinearoperator tenpy.linalg.sparse",
    "tokens": 85
  },
  {
    "category": "api",
    "name": "tenpy.linalg.sparse.OrthogonalNpcLinearOperator",
    "content": "# API Definition: tenpy.linalg.sparse.OrthogonalNpcLinearOperator\nclass OrthogonalNpcLinearOperator:\n    \"\"\"Replace ``H -> P H P`` with the projector ``P = 1 - sum_o |o> <o|``.\"\"\"\n    def __init__(self, orig_operator, ortho_vecs): pass\n    def matvec(self, vec): pass\n    def to_matrix(self): pass\n    def adjoint(self): pass",
    "search_text": "tenpy.linalg.sparse.orthogonalnpclinearoperator # api definition: tenpy.linalg.sparse.orthogonalnpclinearoperator\nclass orthogonalnpclinearoperator:\n    \"\"\"replace ``h -> p h p`` with the projector ``p = 1 - sum_o |o> <o|``.\"\"\"\n    def __init__(self, orig_operator, ortho_vecs): pass\n    def matvec(self, vec): pass\n    def to_matrix(self): pass\n    def adjoint(self): pass class orthogonalnpclinearoperator tenpy.linalg.sparse",
    "tokens": 95
  },
  {
    "category": "api",
    "name": "tenpy.linalg.sparse.FlatLinearOperator",
    "content": "# API Definition: tenpy.linalg.sparse.FlatLinearOperator\nclass FlatLinearOperator:\n    \"\"\"Square Linear operator acting on numpy arrays based on a `matvec` acting on npc Arrays.\"\"\"\n    def __init__(self, npc_matvec, leg, dtype, charge_sector=0, vec_label=None, compact_flat=None): pass\n    def from_NpcArray(cls, mat, charge_sector=0, compact_flat=None):\n        \"\"\"Create a `FlatLinearOperator` from a square :class:`~tenpy.linalg.np_conserved.Array`.\"\"\"\n    def from_guess_with_pipe(cls, npc_matvec, v0_guess, labels_split=None, dtype=None, compact_flat=True):\n        \"\"\"Create a `FlatLinearOperator`` from a `matvec` function acting on multiple legs.\"\"\"\n    def charge_sector(self):\n        \"\"\"Charge sector of the vector which is acted on.\"\"\"\n    def charge_sector(self, value): pass\n    def flat_to_npc(self, vec):\n        \"\"\"Convert flat numpy vector of selected charge sector into npc Array.\"\"\"\n    def npc_to_flat(self, npc_vec):\n        \"\"\"Convert npc Array into a 1D ndarray, inverse of :meth:`flat_to_npc`.\"\"\"\n    def flat_to_npc_None_sector(self, vec, cutoff=1e-10):\n        \"\"\"Convert flat vector of undetermined charge sectors into npc Array.\"\"\"\n    def eigenvectors(self, num_ev=1, max_num_ev=None, max_tol=1e-12, which='LM', v0=None, v0_npc=None, cutoff=1e-10, hermitian=False, **kwargs):\n        \"\"\"Find (dominant) eigenvector(s) of self using :func:`scipy.sparse.linalg.eigs`.\"\"\"",
    "search_text": "tenpy.linalg.sparse.flatlinearoperator # api definition: tenpy.linalg.sparse.flatlinearoperator\nclass flatlinearoperator:\n    \"\"\"square linear operator acting on numpy arrays based on a `matvec` acting on npc arrays.\"\"\"\n    def __init__(self, npc_matvec, leg, dtype, charge_sector=0, vec_label=none, compact_flat=none): pass\n    def from_npcarray(cls, mat, charge_sector=0, compact_flat=none):\n        \"\"\"create a `flatlinearoperator` from a square :class:`~tenpy.linalg.np_conserved.array`.\"\"\"\n    def from_guess_with_pipe(cls, npc_matvec, v0_guess, labels_split=none, dtype=none, compact_flat=true):\n        \"\"\"create a `flatlinearoperator`` from a `matvec` function acting on multiple legs.\"\"\"\n    def charge_sector(self):\n        \"\"\"charge sector of the vector which is acted on.\"\"\"\n    def charge_sector(self, value): pass\n    def flat_to_npc(self, vec):\n        \"\"\"convert flat numpy vector of selected charge sector into npc array.\"\"\"\n    def npc_to_flat(self, npc_vec):\n        \"\"\"convert npc array into a 1d ndarray, inverse of :meth:`flat_to_npc`.\"\"\"\n    def flat_to_npc_none_sector(self, vec, cutoff=1e-10):\n        \"\"\"convert flat vector of undetermined charge sectors into npc array.\"\"\"\n    def eigenvectors(self, num_ev=1, max_num_ev=none, max_tol=1e-12, which='lm', v0=none, v0_npc=none, cutoff=1e-10, hermitian=false, **kwargs):\n        \"\"\"find (dominant) eigenvector(s) of self using :func:`scipy.sparse.linalg.eigs`.\"\"\" class flatlinearoperator tenpy.linalg.sparse",
    "tokens": 354
  },
  {
    "category": "api",
    "name": "tenpy.linalg.sparse.FlatHermitianOperator",
    "content": "# API Definition: tenpy.linalg.sparse.FlatHermitianOperator\nclass FlatHermitianOperator:\n    \"\"\"Hermitian variant of :class:`FlatLinearOperator`.\"\"\"\n    def eigenvectors(self, *args, **kwargs):\n        \"\"\"Same as FlatLinearOperator(..., hermitian=True).\"\"\"",
    "search_text": "tenpy.linalg.sparse.flathermitianoperator # api definition: tenpy.linalg.sparse.flathermitianoperator\nclass flathermitianoperator:\n    \"\"\"hermitian variant of :class:`flatlinearoperator`.\"\"\"\n    def eigenvectors(self, *args, **kwargs):\n        \"\"\"same as flatlinearoperator(..., hermitian=true).\"\"\" class flathermitianoperator tenpy.linalg.sparse",
    "tokens": 64
  },
  {
    "category": "api",
    "name": "tenpy.linalg.svd_robust.svd",
    "content": "# API Function: tenpy.linalg.svd_robust.svd\ndef svd(a, full_matrices=True, compute_uv=True, overwrite_a=False, check_finite=True, lapack_driver='gesdd', warn=True):\n    \"\"\"Wrapper around :func:`scipy.linalg.svd` with `gesvd` backup plan.\"\"\"",
    "search_text": "tenpy.linalg.svd_robust.svd # api function: tenpy.linalg.svd_robust.svd\ndef svd(a, full_matrices=true, compute_uv=true, overwrite_a=false, check_finite=true, lapack_driver='gesdd', warn=true):\n    \"\"\"wrapper around :func:`scipy.linalg.svd` with `gesvd` backup plan.\"\"\" function svd",
    "tokens": 68
  },
  {
    "category": "api",
    "name": "tenpy.linalg.np_conserved.Array",
    "content": "# API Definition: tenpy.linalg.np_conserved.Array\nclass Array:\n    \"\"\"A multidimensional array (=tensor) for using charge conservation.\"\"\"\n    def __init__(self, legcharges, dtype=np.float64, qtotal=None, labels=None):\n        \"\"\"See help(self)\"\"\"\n    def test_sanity(self):\n        \"\"\"Sanity check.\"\"\"\n    def copy(self, deep=True):\n        \"\"\"Return a (deep or shallow) copy of self.\"\"\"\n    def save_hdf5(self, hdf5_saver, h5gr, subpath):\n        \"\"\"Export `self` into a HDF5 file.\"\"\"\n    def from_hdf5(cls, hdf5_loader, h5gr, subpath):\n        \"\"\"Load instance from a HDF5 file.\"\"\"\n    def from_ndarray_trivial(cls, data_flat, dtype=None, labels=None):\n        \"\"\"Convert a flat numpy ndarray to an Array with trivial charge conservation.\"\"\"\n    def from_ndarray(cls, data_flat, legcharges, dtype=None, qtotal=None, cutoff=None, labels=None, raise_wrong_sector=True, warn_wrong_sector=True):\n        \"\"\"Convert a flat (numpy) ndarray to an Array.\"\"\"\n    def from_func(cls, func, legcharges, dtype=None, qtotal=None, func_args=(), func_kwargs={}, shape_kw=None, labels=None):\n        \"\"\"Create an Array from a numpy func.\"\"\"\n    def from_func_square(cls, func, leg, dtype=None, func_args=(), func_kwargs={}, shape_kw=None, labels=None):\n        \"\"\"Create an Array from a (numpy) function.\"\"\"\n    def zeros_like(self):\n        \"\"\"Return a copy of self with only zeros as entries, containing no `_data`.\"\"\"\n    def size(self):\n        \"\"\"The number of dtype-objects stored.\"\"\"\n    def stored_blocks(self):\n        \"\"\"The number of (non-zero) blocks stored in :attr:`_data`.\"\"\"\n    def ndim(self):\n        \"\"\"Alias for :attr:`rank` or ``len(self.shape)``.\"\"\"\n    def get_leg_index(self, label):\n        \"\"\"Translate a leg-index or leg-label to a leg-index.\"\"\"\n    def get_leg_indices(self, labels):\n        \"\"\"Translate a list of leg-indices or leg-labels to leg indices.\"\"\"\n    def iset_leg_labels(self, labels):\n        \"\"\"Set labels for the different axes/legs; in place.\"\"\"\n    def get_leg_labels(self):\n        \"\"\"Return list of the leg labels, with `None` for anonymous legs.\"\"\"\n    def has_label(self, label):\n        \"\"\"Check whether a given label exists.\"\"\"\n    def get_leg(self, label):\n        \"\"\"Return ``self.legs[self.get_leg_index(label)]``.\"\"\"\n    def ireplace_label(self, old_label, new_label):\n        \"\"\"Replace the leg label `old_label` with `new_label`; in place.\"\"\"\n    def replace_label(self, old_label, new_label):\n        \"\"\"Return a shallow copy with the leg label `old_label` replaced by `new_label`.\"\"\"\n    def ireplace_labels(self, old_labels, new_labels):\n        \"\"\"Replace leg label ``old_labels[i]`` with ``new_labels[i]``; in place.\"\"\"\n    def replace_labels(self, old_labels, new_labels):\n        \"\"\"Return a shallow copy with ``old_labels[i]`` replaced by ``new_labels[i]``.\"\"\"\n    def idrop_labels(self, old_labels=None):\n        \"\"\"Remove leg labels from self; in place.\"\"\"\n    def sparse_stats(self):\n        \"\"\"Returns a string detailing the sparse statistics.\"\"\"\n    def to_ndarray(self):\n        \"\"\"Convert self to a dense numpy ndarray.\"\"\"\n    def get_block(self, qindices, insert=False):\n        \"\"\"Return the ndarray in ``_data`` representing the block corresponding to `qindices`.\"\"\"\n    def take_slice(self, indices, axes):\n        \"\"\"Return a copy of self fixing `indices` along one or multiple `axes`.\"\"\"\n    def add_trivial_leg(self, axis=0, label=None, qconj=1):\n        \"\"\"Add a trivial leg (with just one entry) to `self`.\"\"\"\n    def add_leg(self, leg, i, axis=0, label=None):\n        \"\"\"Add a leg to `self`, setting the current array as slice for a given index.\"\"\"\n    def extend(self, axis, extra):\n        \"\"\"Increase the dimension of a given axis, filling the values with zeros.\"\"\"\n    def gauge_total_charge(self, axis, newqtotal=None, new_qconj=None):\n        \"\"\"Changes the total charge by adjusting the charge on a certain leg.\"\"\"\n    def add_charge(self, add_legs, chinfo=None, qtotal=None):\n        \"\"\"Add charges.\"\"\"\n    def drop_charge(self, charge=None, chinfo=None):\n        \"\"\"Drop (one of) the charges.\"\"\"\n    def change_charge(self, charge, new_qmod, new_name='', chinfo=None):\n        \"\"\"Change the `qmod` of one charge in `chinfo`.\"\"\"\n    def is_completely_blocked(self):\n        \"\"\"Return bool whether all legs are blocked by charge.\"\"\"\n    def sort_legcharge(self, sort=True, bunch=True):\n        \"\"\"Return a copy with one or all legs sorted by charges.\"\"\"\n    def isort_qdata(self):\n        \"\"\"(Lexicographically) sort ``self._qdata``; in place.\"\"\"\n    def apply_charge_mapping(self, map_func, func_args=(), func_kwargs={}, inplace: bool=False):\n        \"\"\"Apply a mapping to the charges of all legs and to qtotal.\"\"\"\n    def shift_charges(self, dx, inplace: bool=False):\n        \"\"\"Map all leg-charges and the qtotal with :meth:`ChargeInfo.shift_charges`.\"\"\"\n    def shift_charges_horizontal(self, dx_0: int, inplace: bool=False):\n        \"\"\"Map all leg-charged and the qtotal with :meth:`ChargeInfo.shift_charges_horizontal`.\"\"\"\n    def make_pipe(self, axes, **kwargs):\n        \"\"\"Generates a :class:`~tenpy.linalg.charges.LegPipe` for specified axes.\"\"\"\n    def combine_legs(self, combine_legs, new_axes=None, pipes=None, qconj=None):\n        \"\"\"Reshape: combine multiple legs into multiple pipes. If necessary, transpose before.\"\"\"\n    def split_legs(self, axes=None, cutoff=0.0):\n        \"\"\"Reshape: opposite of combine_legs: split (some) legs which are LegPipes.\"\"\"\n    def as_completely_blocked(self):\n        \"\"\"Gives a version of self which is completely blocked by charges.\"\"\"\n    def squeeze(self, axes=None):\n        \"\"\"Remove single-dimensional legs, like :func:`np.squeeze`.\"\"\"\n    def astype(self, dtype, copy=True):\n        \"\"\"Return copy with new dtype, upcasting all blocks in ``_data``.\"\"\"\n    def ipurge_zeros(self, cutoff=QCUTOFF, norm_order=None):\n        \"\"\"Removes ``self._data`` blocks with *norm* less than cutoff; in place.\"\"\"\n    def iproject(self, mask, axes):\n        \"\"\"Applying masks to one or multiple axes; in place.\"\"\"\n    def permute(self, perm, axis):\n        \"\"\"Apply a permutation in the indices of an axis.\"\"\"\n    def itranspose(self, axes=None):\n        \"\"\"Transpose axes like `np.transpose`; in place.\"\"\"\n    def transpose(self, axes=None):\n        \"\"\"Like :meth:`itranspose`, but on a deep copy.\"\"\"\n    def iswapaxes(self, axis1, axis2):\n        \"\"\"Similar as ``np.swapaxes``; in place.\"\"\"\n    def iscale_axis(self, s, axis=-1):\n        \"\"\"Scale with varying values along an axis; in place.\"\"\"\n    def scale_axis(self, s, axis=-1):\n        \"\"\"Same as :meth:`iscale_axis`, but return a (deep) copy.\"\"\"\n    def iunary_blockwise(self, func, *args, **kwargs):\n        \"\"\"Roughly ``self = f(self)``, block-wise; in place.\"\"\"\n    def unary_blockwise(self, func, *args, **kwargs):\n        \"\"\"Roughly ``return func(self)``, block-wise. Copies.\"\"\"\n    def iconj(self, complex_conj=True):\n        \"\"\"Wrapper around :meth:`self.conj` with ``inplace=True``.\"\"\"\n    def conj(self, complex_conj=True, inplace=False):\n        \"\"\"Conjugate: complex conjugate data, conjugate charge data.\"\"\"\n    def complex_conj(self):\n        \"\"\"Return copy which is complex conjugated *without* conjugating the charge data.\"\"\"\n    def norm(self, ord=None, convert_to_float=True):\n        \"\"\"Norm of flattened data.\"\"\"\n    def ibinary_blockwise(self, func, other, *args, **kwargs):\n        \"\"\"Roughly ``self = func(self, other)``, block-wise; in place.\"\"\"\n    def binary_blockwise(self, func, other, *args, **kwargs):\n        \"\"\"Roughly ``return func(self, other)``, block-wise. Copies.\"\"\"\n    def matvec(self, other):\n        \"\"\"This function is used by the Lanczos algorithm needed for DMRG.\"\"\"\n    def iadd_prefactor_other(self, prefactor, other):\n        \"\"\"``self += prefactor * other`` for scalar `prefactor` and :class:`Array` `other`.\"\"\"\n    def iscale_prefactor(self, prefactor):\n        \"\"\"``self *= prefactor`` for scalar `prefactor`.\"\"\"",
    "search_text": "tenpy.linalg.np_conserved.array # api definition: tenpy.linalg.np_conserved.array\nclass array:\n    \"\"\"a multidimensional array (=tensor) for using charge conservation.\"\"\"\n    def __init__(self, legcharges, dtype=np.float64, qtotal=none, labels=none):\n        \"\"\"see help(self)\"\"\"\n    def test_sanity(self):\n        \"\"\"sanity check.\"\"\"\n    def copy(self, deep=true):\n        \"\"\"return a (deep or shallow) copy of self.\"\"\"\n    def save_hdf5(self, hdf5_saver, h5gr, subpath):\n        \"\"\"export `self` into a hdf5 file.\"\"\"\n    def from_hdf5(cls, hdf5_loader, h5gr, subpath):\n        \"\"\"load instance from a hdf5 file.\"\"\"\n    def from_ndarray_trivial(cls, data_flat, dtype=none, labels=none):\n        \"\"\"convert a flat numpy ndarray to an array with trivial charge conservation.\"\"\"\n    def from_ndarray(cls, data_flat, legcharges, dtype=none, qtotal=none, cutoff=none, labels=none, raise_wrong_sector=true, warn_wrong_sector=true):\n        \"\"\"convert a flat (numpy) ndarray to an array.\"\"\"\n    def from_func(cls, func, legcharges, dtype=none, qtotal=none, func_args=(), func_kwargs={}, shape_kw=none, labels=none):\n        \"\"\"create an array from a numpy func.\"\"\"\n    def from_func_square(cls, func, leg, dtype=none, func_args=(), func_kwargs={}, shape_kw=none, labels=none):\n        \"\"\"create an array from a (numpy) function.\"\"\"\n    def zeros_like(self):\n        \"\"\"return a copy of self with only zeros as entries, containing no `_data`.\"\"\"\n    def size(self):\n        \"\"\"the number of dtype-objects stored.\"\"\"\n    def stored_blocks(self):\n        \"\"\"the number of (non-zero) blocks stored in :attr:`_data`.\"\"\"\n    def ndim(self):\n        \"\"\"alias for :attr:`rank` or ``len(self.shape)``.\"\"\"\n    def get_leg_index(self, label):\n        \"\"\"translate a leg-index or leg-label to a leg-index.\"\"\"\n    def get_leg_indices(self, labels):\n        \"\"\"translate a list of leg-indices or leg-labels to leg indices.\"\"\"\n    def iset_leg_labels(self, labels):\n        \"\"\"set labels for the different axes/legs; in place.\"\"\"\n    def get_leg_labels(self):\n        \"\"\"return list of the leg labels, with `none` for anonymous legs.\"\"\"\n    def has_label(self, label):\n        \"\"\"check whether a given label exists.\"\"\"\n    def get_leg(self, label):\n        \"\"\"return ``self.legs[self.get_leg_index(label)]``.\"\"\"\n    def ireplace_label(self, old_label, new_label):\n        \"\"\"replace the leg label `old_label` with `new_label`; in place.\"\"\"\n    def replace_label(self, old_label, new_label):\n        \"\"\"return a shallow copy with the leg label `old_label` replaced by `new_label`.\"\"\"\n    def ireplace_labels(self, old_labels, new_labels):\n        \"\"\"replace leg label ``old_labels[i]`` with ``new_labels[i]``; in place.\"\"\"\n    def replace_labels(self, old_labels, new_labels):\n        \"\"\"return a shallow copy with ``old_labels[i]`` replaced by ``new_labels[i]``.\"\"\"\n    def idrop_labels(self, old_labels=none):\n        \"\"\"remove leg labels from self; in place.\"\"\"\n    def sparse_stats(self):\n        \"\"\"returns a string detailing the sparse statistics.\"\"\"\n    def to_ndarray(self):\n        \"\"\"convert self to a dense numpy ndarray.\"\"\"\n    def get_block(self, qindices, insert=false):\n        \"\"\"return the ndarray in ``_data`` representing the block corresponding to `qindices`.\"\"\"\n    def take_slice(self, indices, axes):\n        \"\"\"return a copy of self fixing `indices` along one or multiple `axes`.\"\"\"\n    def add_trivial_leg(self, axis=0, label=none, qconj=1):\n        \"\"\"add a trivial leg (with just one entry) to `self`.\"\"\"\n    def add_leg(self, leg, i, axis=0, label=none):\n        \"\"\"add a leg to `self`, setting the current array as slice for a given index.\"\"\"\n    def extend(self, axis, extra):\n        \"\"\"increase the dimension of a given axis, filling the values with zeros.\"\"\"\n    def gauge_total_charge(self, axis, newqtotal=none, new_qconj=none):\n        \"\"\"changes the total charge by adjusting the charge on a certain leg.\"\"\"\n    def add_charge(self, add_legs, chinfo=none, qtotal=none):\n        \"\"\"add charges.\"\"\"\n    def drop_charge(self, charge=none, chinfo=none):\n        \"\"\"drop (one of) the charges.\"\"\"\n    def change_charge(self, charge, new_qmod, new_name='', chinfo=none):\n        \"\"\"change the `qmod` of one charge in `chinfo`.\"\"\"\n    def is_completely_blocked(self):\n        \"\"\"return bool whether all legs are blocked by charge.\"\"\"\n    def sort_legcharge(self, sort=true, bunch=true):\n        \"\"\"return a copy with one or all legs sorted by charges.\"\"\"\n    def isort_qdata(self):\n        \"\"\"(lexicographically) sort ``self._qdata``; in place.\"\"\"\n    def apply_charge_mapping(self, map_func, func_args=(), func_kwargs={}, inplace: bool=false):\n        \"\"\"apply a mapping to the charges of all legs and to qtotal.\"\"\"\n    def shift_charges(self, dx, inplace: bool=false):\n        \"\"\"map all leg-charges and the qtotal with :meth:`chargeinfo.shift_charges`.\"\"\"\n    def shift_charges_horizontal(self, dx_0: int, inplace: bool=false):\n        \"\"\"map all leg-charged and the qtotal with :meth:`chargeinfo.shift_charges_horizontal`.\"\"\"\n    def make_pipe(self, axes, **kwargs):\n        \"\"\"generates a :class:`~tenpy.linalg.charges.legpipe` for specified axes.\"\"\"\n    def combine_legs(self, combine_legs, new_axes=none, pipes=none, qconj=none):\n        \"\"\"reshape: combine multiple legs into multiple pipes. if necessary, transpose before.\"\"\"\n    def split_legs(self, axes=none, cutoff=0.0):\n        \"\"\"reshape: opposite of combine_legs: split (some) legs which are legpipes.\"\"\"\n    def as_completely_blocked(self):\n        \"\"\"gives a version of self which is completely blocked by charges.\"\"\"\n    def squeeze(self, axes=none):\n        \"\"\"remove single-dimensional legs, like :func:`np.squeeze`.\"\"\"\n    def astype(self, dtype, copy=true):\n        \"\"\"return copy with new dtype, upcasting all blocks in ``_data``.\"\"\"\n    def ipurge_zeros(self, cutoff=qcutoff, norm_order=none):\n        \"\"\"removes ``self._data`` blocks with *norm* less than cutoff; in place.\"\"\"\n    def iproject(self, mask, axes):\n        \"\"\"applying masks to one or multiple axes; in place.\"\"\"\n    def permute(self, perm, axis):\n        \"\"\"apply a permutation in the indices of an axis.\"\"\"\n    def itranspose(self, axes=none):\n        \"\"\"transpose axes like `np.transpose`; in place.\"\"\"\n    def transpose(self, axes=none):\n        \"\"\"like :meth:`itranspose`, but on a deep copy.\"\"\"\n    def iswapaxes(self, axis1, axis2):\n        \"\"\"similar as ``np.swapaxes``; in place.\"\"\"\n    def iscale_axis(self, s, axis=-1):\n        \"\"\"scale with varying values along an axis; in place.\"\"\"\n    def scale_axis(self, s, axis=-1):\n        \"\"\"same as :meth:`iscale_axis`, but return a (deep) copy.\"\"\"\n    def iunary_blockwise(self, func, *args, **kwargs):\n        \"\"\"roughly ``self = f(self)``, block-wise; in place.\"\"\"\n    def unary_blockwise(self, func, *args, **kwargs):\n        \"\"\"roughly ``return func(self)``, block-wise. copies.\"\"\"\n    def iconj(self, complex_conj=true):\n        \"\"\"wrapper around :meth:`self.conj` with ``inplace=true``.\"\"\"\n    def conj(self, complex_conj=true, inplace=false):\n        \"\"\"conjugate: complex conjugate data, conjugate charge data.\"\"\"\n    def complex_conj(self):\n        \"\"\"return copy which is complex conjugated *without* conjugating the charge data.\"\"\"\n    def norm(self, ord=none, convert_to_float=true):\n        \"\"\"norm of flattened data.\"\"\"\n    def ibinary_blockwise(self, func, other, *args, **kwargs):\n        \"\"\"roughly ``self = func(self, other)``, block-wise; in place.\"\"\"\n    def binary_blockwise(self, func, other, *args, **kwargs):\n        \"\"\"roughly ``return func(self, other)``, block-wise. copies.\"\"\"\n    def matvec(self, other):\n        \"\"\"this function is used by the lanczos algorithm needed for dmrg.\"\"\"\n    def iadd_prefactor_other(self, prefactor, other):\n        \"\"\"``self += prefactor * other`` for scalar `prefactor` and :class:`array` `other`.\"\"\"\n    def iscale_prefactor(self, prefactor):\n        \"\"\"``self *= prefactor`` for scalar `prefactor`.\"\"\" class array tenpy.linalg.np_conserved",
    "tokens": 1928
  },
  {
    "category": "api",
    "name": "tenpy.linalg.np_conserved.zeros",
    "content": "# API Function: tenpy.linalg.np_conserved.zeros\ndef zeros(legcharges, dtype=np.float64, qtotal=None, labels=None):\n    \"\"\"Create a npc array full of zeros (with no _data).\"\"\"",
    "search_text": "tenpy.linalg.np_conserved.zeros # api function: tenpy.linalg.np_conserved.zeros\ndef zeros(legcharges, dtype=np.float64, qtotal=none, labels=none):\n    \"\"\"create a npc array full of zeros (with no _data).\"\"\" function zeros",
    "tokens": 47
  },
  {
    "category": "api",
    "name": "tenpy.linalg.np_conserved.ones",
    "content": "# API Function: tenpy.linalg.np_conserved.ones\ndef ones(legcharges, dtype=np.float64, qtotal=None, labels=None):\n    \"\"\"Short-hand for :meth:`Array.from_func` with function :func:`numpy.ones`.\"\"\"",
    "search_text": "tenpy.linalg.np_conserved.ones # api function: tenpy.linalg.np_conserved.ones\ndef ones(legcharges, dtype=np.float64, qtotal=none, labels=none):\n    \"\"\"short-hand for :meth:`array.from_func` with function :func:`numpy.ones`.\"\"\" function ones",
    "tokens": 52
  },
  {
    "category": "api",
    "name": "tenpy.linalg.np_conserved.eye_like",
    "content": "# API Function: tenpy.linalg.np_conserved.eye_like\ndef eye_like(a, axis=0, labels=None):\n    \"\"\"Return an identity matrix contractible with the leg `axis` of the :class:`Array` `a`.\"\"\"",
    "search_text": "tenpy.linalg.np_conserved.eye_like # api function: tenpy.linalg.np_conserved.eye_like\ndef eye_like(a, axis=0, labels=none):\n    \"\"\"return an identity matrix contractible with the leg `axis` of the :class:`array` `a`.\"\"\" function eye_like",
    "tokens": 51
  },
  {
    "category": "api",
    "name": "tenpy.linalg.np_conserved.diag",
    "content": "# API Function: tenpy.linalg.np_conserved.diag\ndef diag(s, leg, dtype=None, labels=None):\n    \"\"\"Returns a square, diagonal matrix of entries `s`.\"\"\"",
    "search_text": "tenpy.linalg.np_conserved.diag # api function: tenpy.linalg.np_conserved.diag\ndef diag(s, leg, dtype=none, labels=none):\n    \"\"\"returns a square, diagonal matrix of entries `s`.\"\"\" function diag",
    "tokens": 39
  },
  {
    "category": "api",
    "name": "tenpy.linalg.np_conserved.concatenate",
    "content": "# API Function: tenpy.linalg.np_conserved.concatenate\ndef concatenate(arrays, axis=0, copy=True):\n    \"\"\"Stack arrays along a given axis, similar as np.concatenate.\"\"\"",
    "search_text": "tenpy.linalg.np_conserved.concatenate # api function: tenpy.linalg.np_conserved.concatenate\ndef concatenate(arrays, axis=0, copy=true):\n    \"\"\"stack arrays along a given axis, similar as np.concatenate.\"\"\" function concatenate",
    "tokens": 39
  },
  {
    "category": "api",
    "name": "tenpy.linalg.np_conserved.grid_concat",
    "content": "# API Function: tenpy.linalg.np_conserved.grid_concat\ndef grid_concat(grid, axes, copy=True):\n    \"\"\"Given an np.array of npc.Arrays, performs a multi-dimensional concatenation along 'axes'.\"\"\"",
    "search_text": "tenpy.linalg.np_conserved.grid_concat # api function: tenpy.linalg.np_conserved.grid_concat\ndef grid_concat(grid, axes, copy=true):\n    \"\"\"given an np.array of npc.arrays, performs a multi-dimensional concatenation along 'axes'.\"\"\" function grid_concat",
    "tokens": 45
  },
  {
    "category": "api",
    "name": "tenpy.linalg.np_conserved.grid_outer",
    "content": "# API Function: tenpy.linalg.np_conserved.grid_outer\ndef grid_outer(grid, grid_legs, qtotal=None, grid_labels=None):\n    \"\"\"Given an np.array of npc.Arrays, return the corresponding higher-dimensional Array.\"\"\"",
    "search_text": "tenpy.linalg.np_conserved.grid_outer # api function: tenpy.linalg.np_conserved.grid_outer\ndef grid_outer(grid, grid_legs, qtotal=none, grid_labels=none):\n    \"\"\"given an np.array of npc.arrays, return the corresponding higher-dimensional array.\"\"\" function grid_outer",
    "tokens": 48
  },
  {
    "category": "api",
    "name": "tenpy.linalg.np_conserved.detect_grid_outer_legcharge",
    "content": "# API Function: tenpy.linalg.np_conserved.detect_grid_outer_legcharge\ndef detect_grid_outer_legcharge(grid, grid_legs, qtotal=None, qconj=1, bunch=False):\n    \"\"\"Derive a LegCharge for a grid used for :func:`grid_outer`.\"\"\"",
    "search_text": "tenpy.linalg.np_conserved.detect_grid_outer_legcharge # api function: tenpy.linalg.np_conserved.detect_grid_outer_legcharge\ndef detect_grid_outer_legcharge(grid, grid_legs, qtotal=none, qconj=1, bunch=false):\n    \"\"\"derive a legcharge for a grid used for :func:`grid_outer`.\"\"\" function detect_grid_outer_legcharge",
    "tokens": 60
  },
  {
    "category": "api",
    "name": "tenpy.linalg.np_conserved.detect_qtotal",
    "content": "# API Function: tenpy.linalg.np_conserved.detect_qtotal\ndef detect_qtotal(flat_array, legcharges, cutoff=None):\n    \"\"\"Returns the total charge (w.r.t `legs`) of the sector with largest entry in `flat_array`.\"\"\"",
    "search_text": "tenpy.linalg.np_conserved.detect_qtotal # api function: tenpy.linalg.np_conserved.detect_qtotal\ndef detect_qtotal(flat_array, legcharges, cutoff=none):\n    \"\"\"returns the total charge (w.r.t `legs`) of the sector with largest entry in `flat_array`.\"\"\" function detect_qtotal",
    "tokens": 54
  },
  {
    "category": "api",
    "name": "tenpy.linalg.np_conserved.detect_legcharge",
    "content": "# API Function: tenpy.linalg.np_conserved.detect_legcharge\ndef detect_legcharge(flat_array, chargeinfo, legcharges, qtotal=None, qconj=+1, cutoff=None):\n    \"\"\"Calculate a missing `LegCharge` by looking for nonzero entries of a flat array.\"\"\"",
    "search_text": "tenpy.linalg.np_conserved.detect_legcharge # api function: tenpy.linalg.np_conserved.detect_legcharge\ndef detect_legcharge(flat_array, chargeinfo, legcharges, qtotal=none, qconj=+1, cutoff=none):\n    \"\"\"calculate a missing `legcharge` by looking for nonzero entries of a flat array.\"\"\" function detect_legcharge",
    "tokens": 61
  },
  {
    "category": "api",
    "name": "tenpy.linalg.np_conserved.trace",
    "content": "# API Function: tenpy.linalg.np_conserved.trace\ndef trace(a, leg1=0, leg2=1):\n    \"\"\"Trace of `a`, summing over leg1 and leg2.\"\"\"",
    "search_text": "tenpy.linalg.np_conserved.trace # api function: tenpy.linalg.np_conserved.trace\ndef trace(a, leg1=0, leg2=1):\n    \"\"\"trace of `a`, summing over leg1 and leg2.\"\"\" function trace",
    "tokens": 43
  },
  {
    "category": "api",
    "name": "tenpy.linalg.np_conserved.outer",
    "content": "# API Function: tenpy.linalg.np_conserved.outer\ndef outer(a, b):\n    \"\"\"Forms the outer tensor product, equivalent to ``tensordot(a, b, axes=0)``.\"\"\"",
    "search_text": "tenpy.linalg.np_conserved.outer # api function: tenpy.linalg.np_conserved.outer\ndef outer(a, b):\n    \"\"\"forms the outer tensor product, equivalent to ``tensordot(a, b, axes=0)``.\"\"\" function outer",
    "tokens": 44
  },
  {
    "category": "api",
    "name": "tenpy.linalg.np_conserved.inner",
    "content": "# API Function: tenpy.linalg.np_conserved.inner\ndef inner(a, b, axes='labels', do_conj=False):\n    \"\"\"Contract all legs in `a` and `b`, return scalar.\"\"\"",
    "search_text": "tenpy.linalg.np_conserved.inner # api function: tenpy.linalg.np_conserved.inner\ndef inner(a, b, axes='labels', do_conj=false):\n    \"\"\"contract all legs in `a` and `b`, return scalar.\"\"\" function inner",
    "tokens": 44
  },
  {
    "category": "api",
    "name": "tenpy.linalg.np_conserved.tensordot",
    "content": "# API Function: tenpy.linalg.np_conserved.tensordot\ndef tensordot(a, b, axes=2):\n    \"\"\"Similar as ``np.tensordot`` but for :class:`Array`.\"\"\"",
    "search_text": "tenpy.linalg.np_conserved.tensordot # api function: tenpy.linalg.np_conserved.tensordot\ndef tensordot(a, b, axes=2):\n    \"\"\"similar as ``np.tensordot`` but for :class:`array`.\"\"\" function tensordot",
    "tokens": 47
  },
  {
    "category": "api",
    "name": "tenpy.linalg.np_conserved.svd",
    "content": "# API Function: tenpy.linalg.np_conserved.svd\ndef svd(a, full_matrices=False, compute_uv=True, cutoff=None, qtotal_LR=[None, None], inner_labels=[None, None], inner_qconj=+1):\n    \"\"\"Singular value decomposition of an Array `a`.\"\"\"",
    "search_text": "tenpy.linalg.np_conserved.svd # api function: tenpy.linalg.np_conserved.svd\ndef svd(a, full_matrices=false, compute_uv=true, cutoff=none, qtotal_lr=[none, none], inner_labels=[none, none], inner_qconj=+1):\n    \"\"\"singular value decomposition of an array `a`.\"\"\" function svd",
    "tokens": 65
  },
  {
    "category": "api",
    "name": "tenpy.linalg.np_conserved.polar",
    "content": "# API Function: tenpy.linalg.np_conserved.polar\ndef polar(a, cutoff=1e-16, left=False, inner_labels=[None, None]):\n    \"\"\"Polar decomposition of an Array `a`.\"\"\"",
    "search_text": "tenpy.linalg.np_conserved.polar # api function: tenpy.linalg.np_conserved.polar\ndef polar(a, cutoff=1e-16, left=false, inner_labels=[none, none]):\n    \"\"\"polar decomposition of an array `a`.\"\"\" function polar",
    "tokens": 47
  },
  {
    "category": "api",
    "name": "tenpy.linalg.np_conserved.pinv",
    "content": "# API Function: tenpy.linalg.np_conserved.pinv\ndef pinv(a, cutoff=1e-15):\n    \"\"\"Compute the (Moore-Penrose) pseudo-inverse of a matrix.\"\"\"",
    "search_text": "tenpy.linalg.np_conserved.pinv # api function: tenpy.linalg.np_conserved.pinv\ndef pinv(a, cutoff=1e-15):\n    \"\"\"compute the (moore-penrose) pseudo-inverse of a matrix.\"\"\" function pinv",
    "tokens": 43
  },
  {
    "category": "api",
    "name": "tenpy.linalg.np_conserved.norm",
    "content": "# API Function: tenpy.linalg.np_conserved.norm\ndef norm(a, ord=None, convert_to_float=True):\n    \"\"\"Norm of flattened data.\"\"\"",
    "search_text": "tenpy.linalg.np_conserved.norm # api function: tenpy.linalg.np_conserved.norm\ndef norm(a, ord=none, convert_to_float=true):\n    \"\"\"norm of flattened data.\"\"\" function norm",
    "tokens": 32
  },
  {
    "category": "api",
    "name": "tenpy.linalg.np_conserved.eigh",
    "content": "# API Function: tenpy.linalg.np_conserved.eigh\ndef eigh(a, UPLO='L', sort=None):\n    \"\"\"Calculate eigenvalues and eigenvectors for a hermitian matrix.\"\"\"",
    "search_text": "tenpy.linalg.np_conserved.eigh # api function: tenpy.linalg.np_conserved.eigh\ndef eigh(a, uplo='l', sort=none):\n    \"\"\"calculate eigenvalues and eigenvectors for a hermitian matrix.\"\"\" function eigh",
    "tokens": 43
  },
  {
    "category": "api",
    "name": "tenpy.linalg.np_conserved.eig",
    "content": "# API Function: tenpy.linalg.np_conserved.eig\ndef eig(a, sort=None):\n    \"\"\"Calculate eigenvalues and eigenvectors for a non-hermitian matrix.\"\"\"",
    "search_text": "tenpy.linalg.np_conserved.eig # api function: tenpy.linalg.np_conserved.eig\ndef eig(a, sort=none):\n    \"\"\"calculate eigenvalues and eigenvectors for a non-hermitian matrix.\"\"\" function eig",
    "tokens": 39
  },
  {
    "category": "api",
    "name": "tenpy.linalg.np_conserved.eigvalsh",
    "content": "# API Function: tenpy.linalg.np_conserved.eigvalsh\ndef eigvalsh(a, UPLO='L', sort=None):\n    \"\"\"Calculate eigenvalues for a hermitian matrix.\"\"\"",
    "search_text": "tenpy.linalg.np_conserved.eigvalsh # api function: tenpy.linalg.np_conserved.eigvalsh\ndef eigvalsh(a, uplo='l', sort=none):\n    \"\"\"calculate eigenvalues for a hermitian matrix.\"\"\" function eigvalsh",
    "tokens": 42
  },
  {
    "category": "api",
    "name": "tenpy.linalg.np_conserved.eigvals",
    "content": "# API Function: tenpy.linalg.np_conserved.eigvals\ndef eigvals(a, sort=None):\n    \"\"\"Calculate eigenvalues for a hermitian matrix.\"\"\"",
    "search_text": "tenpy.linalg.np_conserved.eigvals # api function: tenpy.linalg.np_conserved.eigvals\ndef eigvals(a, sort=none):\n    \"\"\"calculate eigenvalues for a hermitian matrix.\"\"\" function eigvals",
    "tokens": 35
  },
  {
    "category": "api",
    "name": "tenpy.linalg.np_conserved.speigs",
    "content": "# API Function: tenpy.linalg.np_conserved.speigs\ndef speigs(a, charge_sector, k, *args, **kwargs):\n    \"\"\"Sparse eigenvalue decomposition ``w, v`` of square `a` in a given charge sector.\"\"\"",
    "search_text": "tenpy.linalg.np_conserved.speigs # api function: tenpy.linalg.np_conserved.speigs\ndef speigs(a, charge_sector, k, *args, **kwargs):\n    \"\"\"sparse eigenvalue decomposition ``w, v`` of square `a` in a given charge sector.\"\"\" function speigs",
    "tokens": 53
  },
  {
    "category": "api",
    "name": "tenpy.linalg.np_conserved.expm",
    "content": "# API Function: tenpy.linalg.np_conserved.expm\ndef expm(a):\n    \"\"\"Use scipy.linalg.expm to calculate the matrix exponential of a square matrix.\"\"\"",
    "search_text": "tenpy.linalg.np_conserved.expm # api function: tenpy.linalg.np_conserved.expm\ndef expm(a):\n    \"\"\"use scipy.linalg.expm to calculate the matrix exponential of a square matrix.\"\"\" function expm",
    "tokens": 36
  },
  {
    "category": "api",
    "name": "tenpy.linalg.np_conserved.qr",
    "content": "# API Function: tenpy.linalg.np_conserved.qr\ndef qr(a, mode='reduced', inner_labels=[None, None], cutoff=None, pos_diag_R=False, qtotal_Q=None, inner_qconj=+1):\n    \"\"\"Q-R decomposition of a matrix.\"\"\"",
    "search_text": "tenpy.linalg.np_conserved.qr # api function: tenpy.linalg.np_conserved.qr\ndef qr(a, mode='reduced', inner_labels=[none, none], cutoff=none, pos_diag_r=false, qtotal_q=none, inner_qconj=+1):\n    \"\"\"q-r decomposition of a matrix.\"\"\" function qr",
    "tokens": 59
  },
  {
    "category": "api",
    "name": "tenpy.linalg.np_conserved.lq",
    "content": "# API Function: tenpy.linalg.np_conserved.lq\ndef lq(a, mode='reduced', inner_labels=[None, None], cutoff=None, pos_diag_L=False, qtotal_Q=None, inner_qconj=+1):\n    \"\"\"Q-R decomposition of a matrix. See documentation for :meth:`qr` for details.\"\"\"",
    "search_text": "tenpy.linalg.np_conserved.lq # api function: tenpy.linalg.np_conserved.lq\ndef lq(a, mode='reduced', inner_labels=[none, none], cutoff=none, pos_diag_l=false, qtotal_q=none, inner_qconj=+1):\n    \"\"\"q-r decomposition of a matrix. see documentation for :meth:`qr` for details.\"\"\" function lq",
    "tokens": 71
  },
  {
    "category": "api",
    "name": "tenpy.linalg.np_conserved.orthogonal_columns",
    "content": "# API Function: tenpy.linalg.np_conserved.orthogonal_columns\ndef orthogonal_columns(a, new_label=None):\n    \"\"\"Find orthogonal columns for a given matrix.\"\"\"",
    "search_text": "tenpy.linalg.np_conserved.orthogonal_columns # api function: tenpy.linalg.np_conserved.orthogonal_columns\ndef orthogonal_columns(a, new_label=none):\n    \"\"\"find orthogonal columns for a given matrix.\"\"\" function orthogonal_columns",
    "tokens": 35
  },
  {
    "category": "api",
    "name": "tenpy.linalg.np_conserved.to_iterable_arrays",
    "content": "# API Function: tenpy.linalg.np_conserved.to_iterable_arrays\ndef to_iterable_arrays(array_list):\n    \"\"\"Similar as :func:`~tenpy.tools.misc.to_iterable`, but also enclose npc Arrays in a list.\"\"\"",
    "search_text": "tenpy.linalg.np_conserved.to_iterable_arrays # api function: tenpy.linalg.np_conserved.to_iterable_arrays\ndef to_iterable_arrays(array_list):\n    \"\"\"similar as :func:`~tenpy.tools.misc.to_iterable`, but also enclose npc arrays in a list.\"\"\" function to_iterable_arrays",
    "tokens": 49
  },
  {
    "category": "api",
    "name": "tenpy.linalg.charges.ChargeInfo",
    "content": "# API Definition: tenpy.linalg.charges.ChargeInfo\nclass ChargeInfo:\n    \"\"\"Meta-data about the charge of a tensor.\"\"\"\n    def __init__(self, mod=[], names=None): pass\n    def save_hdf5(self, hdf5_saver, h5gr, subpath):\n        \"\"\"Export `self` into a HDF5 file.\"\"\"\n    def from_hdf5(cls, hdf5_loader, h5gr, subpath):\n        \"\"\"Load instance from a HDF5 file.\"\"\"\n    def add(cls, chinfos):\n        \"\"\"Create a :class:`ChargeInfo` combining multiple charges.\"\"\"\n    def drop(cls, chinfo, charge=None):\n        \"\"\"Remove a charge from a :class:`ChargeInfo`.\"\"\"\n    def change(cls, chinfo, charge, new_qmod, new_name=''):\n        \"\"\"Change the `qmod` of a given charge.\"\"\"\n    def test_sanity(self):\n        \"\"\"Sanity check, raises ValueErrors, if something is wrong.\"\"\"\n    def qnumber(self):\n        \"\"\"The number of charges.\"\"\"\n    def mod(self):\n        \"\"\"Modulo how much each of the charges is taken.\"\"\"\n    def make_valid(self, charges=None):\n        \"\"\"Take charges modulo self.mod.\"\"\"\n    def check_valid(self, charges):\n        \"\"\"Check, if `charges` has all entries as expected from self.mod.\"\"\"\n    def shift_charges(self, charges, dx):\n        \"\"\"Spatial translation acting on charges.\"\"\"\n    def shift_charges_horizontal(self, charges, dx_0):\n        \"\"\"Like :meth:`shift_charges`, but restricted to the first dimension.\"\"\"",
    "search_text": "tenpy.linalg.charges.chargeinfo # api definition: tenpy.linalg.charges.chargeinfo\nclass chargeinfo:\n    \"\"\"meta-data about the charge of a tensor.\"\"\"\n    def __init__(self, mod=[], names=none): pass\n    def save_hdf5(self, hdf5_saver, h5gr, subpath):\n        \"\"\"export `self` into a hdf5 file.\"\"\"\n    def from_hdf5(cls, hdf5_loader, h5gr, subpath):\n        \"\"\"load instance from a hdf5 file.\"\"\"\n    def add(cls, chinfos):\n        \"\"\"create a :class:`chargeinfo` combining multiple charges.\"\"\"\n    def drop(cls, chinfo, charge=none):\n        \"\"\"remove a charge from a :class:`chargeinfo`.\"\"\"\n    def change(cls, chinfo, charge, new_qmod, new_name=''):\n        \"\"\"change the `qmod` of a given charge.\"\"\"\n    def test_sanity(self):\n        \"\"\"sanity check, raises valueerrors, if something is wrong.\"\"\"\n    def qnumber(self):\n        \"\"\"the number of charges.\"\"\"\n    def mod(self):\n        \"\"\"modulo how much each of the charges is taken.\"\"\"\n    def make_valid(self, charges=none):\n        \"\"\"take charges modulo self.mod.\"\"\"\n    def check_valid(self, charges):\n        \"\"\"check, if `charges` has all entries as expected from self.mod.\"\"\"\n    def shift_charges(self, charges, dx):\n        \"\"\"spatial translation acting on charges.\"\"\"\n    def shift_charges_horizontal(self, charges, dx_0):\n        \"\"\"like :meth:`shift_charges`, but restricted to the first dimension.\"\"\" class chargeinfo tenpy.linalg.charges",
    "tokens": 325
  },
  {
    "category": "api",
    "name": "tenpy.linalg.charges.DipolarChargeInfo",
    "content": "# API Definition: tenpy.linalg.charges.DipolarChargeInfo\nclass DipolarChargeInfo:\n    \"\"\"Version of :class:`ChargeInfo` that supports dipole conservation.\"\"\"\n    def __init__(self, mod=[], names=None, charge_idcs=[], dipole_idcs=[], dipole_dims=None): pass\n    def shift_charges(self, charges, dx): pass\n    def shift_charges_horizontal(self, charges, dx_0): pass\n    def save_hdf5(self, hdf5_saver, h5gr, subpath): pass\n    def from_hdf5(cls, hdf5_loader, h5gr, subpath): pass\n    def test_sanity(self): pass",
    "search_text": "tenpy.linalg.charges.dipolarchargeinfo # api definition: tenpy.linalg.charges.dipolarchargeinfo\nclass dipolarchargeinfo:\n    \"\"\"version of :class:`chargeinfo` that supports dipole conservation.\"\"\"\n    def __init__(self, mod=[], names=none, charge_idcs=[], dipole_idcs=[], dipole_dims=none): pass\n    def shift_charges(self, charges, dx): pass\n    def shift_charges_horizontal(self, charges, dx_0): pass\n    def save_hdf5(self, hdf5_saver, h5gr, subpath): pass\n    def from_hdf5(cls, hdf5_loader, h5gr, subpath): pass\n    def test_sanity(self): pass class dipolarchargeinfo tenpy.linalg.charges",
    "tokens": 145
  },
  {
    "category": "api",
    "name": "tenpy.linalg.charges.LegCharge",
    "content": "# API Definition: tenpy.linalg.charges.LegCharge\nclass LegCharge:\n    \"\"\"Save the charge data associated to a leg of a tensor.\"\"\"\n    def __init__(self, chargeinfo, slices, charges, qconj=1): pass\n    def copy(self):\n        \"\"\"Return a (shallow) copy of self.\"\"\"\n    def save_hdf5(self, hdf5_saver, h5gr, subpath):\n        \"\"\"Export `self` into a HDF5 file.\"\"\"\n    def from_hdf5(cls, hdf5_loader, h5gr, subpath):\n        \"\"\"Load instance from a HDF5 file.\"\"\"\n    def from_trivial(cls, ind_len, chargeinfo=None, qconj=1):\n        \"\"\"Create trivial (qnumber=0) LegCharge for given len of indices `ind_len`.\"\"\"\n    def from_qflat(cls, chargeinfo, qflat, qconj=1):\n        \"\"\"Create a LegCharge from qflat form.\"\"\"\n    def from_qind(cls, chargeinfo, slices, charges, qconj=1):\n        \"\"\"Just a wrapper around self.__init__(), see class doc-string for parameters.\"\"\"\n    def from_qdict(cls, chargeinfo, qdict, qconj=1):\n        \"\"\"Create a LegCharge from qdict form.\"\"\"\n    def from_add_charge(cls, legs, chargeinfo=None):\n        \"\"\"Add the (independent) charges of two or more legs to get larger `qnumber`.\"\"\"\n    def from_drop_charge(cls, leg, charge=None, chargeinfo=None):\n        \"\"\"Remove a charge from a LegCharge.\"\"\"\n    def from_change_charge(cls, leg, charge, new_qmod, new_name='', chargeinfo=None):\n        \"\"\"Remove a charge from a LegCharge.\"\"\"\n    def test_sanity(self):\n        \"\"\"Sanity check, raises ValueErrors, if something is wrong.\"\"\"\n    def conj(self):\n        \"\"\"Return a (shallow) copy with opposite ``self.qconj``.\"\"\"\n    def flip_charges_qconj(self):\n        \"\"\"Return a copy with both negative `qconj` and `charges`.\"\"\"\n    def apply_charge_mapping(self, map_func, func_args=(), func_kwargs={}):\n        \"\"\"Apply mapping to :attr:`LegCharge.charges`.\"\"\"\n    def to_qflat(self):\n        \"\"\"Return charges in `qflat` form.\"\"\"\n    def to_qdict(self):\n        \"\"\"Return charges in `qdict` form.\"\"\"\n    def is_blocked(self):\n        \"\"\"Returns whether self is blocked, i.e. qindex map 1:1 to charge values.\"\"\"\n    def is_sorted(self):\n        \"\"\"Returns whether `self.charges` is sorted lexicographically.\"\"\"\n    def is_bunched(self):\n        \"\"\"Checks whether :meth:`bunch` would change something.\"\"\"\n    def test_contractible(self, other):\n        \"\"\"Raises a ValueError if charges are incompatible for contraction with other.\"\"\"\n    def test_equal(self, other):\n        \"\"\"Test if charges are *equal* including `qconj`.\"\"\"\n    def get_block_sizes(self):\n        \"\"\"Return the sizes of the individual blocks.\"\"\"\n    def get_slice(self, qindex):\n        \"\"\"Return slice selecting the block for a given `qindex`.\"\"\"\n    def get_qindex(self, flat_index):\n        \"\"\"Find qindex containing a flat index.\"\"\"\n    def get_qindex_of_charges(self, charges):\n        \"\"\"Return the slice selecting the block for given charge values.\"\"\"\n    def get_charge(self, qindex):\n        \"\"\"Return charge ``self.charges[qindex] * self.qconj`` for a given `qindex`.\"\"\"\n    def sort(self, bunch=True):\n        \"\"\"Return a copy of `self` sorted by charges (but maybe not bunched).\"\"\"\n    def bunch(self):\n        \"\"\"Return a copy with bunched self.charges: form blocks for contiguous equal charges.\"\"\"\n    def project(self, mask):\n        \"\"\"Return copy keeping only the indices specified by `mask`.\"\"\"\n    def extend(self, extra):\n        \"\"\"Return a new :class:`LegCharge`, which extends self with further charges.\"\"\"\n    def charge_sectors(self):\n        \"\"\"Return unique rows of self.charges.\"\"\"\n    def perm_flat_from_perm_qind(self, perm_qind):\n        \"\"\"Convert a permutation of qind (acting on self) into a flat permutation.\"\"\"\n    def perm_qind_from_perm_flat(self, perm_flat):\n        \"\"\"Convert flat permutation into qind permutation.\"\"\"",
    "search_text": "tenpy.linalg.charges.legcharge # api definition: tenpy.linalg.charges.legcharge\nclass legcharge:\n    \"\"\"save the charge data associated to a leg of a tensor.\"\"\"\n    def __init__(self, chargeinfo, slices, charges, qconj=1): pass\n    def copy(self):\n        \"\"\"return a (shallow) copy of self.\"\"\"\n    def save_hdf5(self, hdf5_saver, h5gr, subpath):\n        \"\"\"export `self` into a hdf5 file.\"\"\"\n    def from_hdf5(cls, hdf5_loader, h5gr, subpath):\n        \"\"\"load instance from a hdf5 file.\"\"\"\n    def from_trivial(cls, ind_len, chargeinfo=none, qconj=1):\n        \"\"\"create trivial (qnumber=0) legcharge for given len of indices `ind_len`.\"\"\"\n    def from_qflat(cls, chargeinfo, qflat, qconj=1):\n        \"\"\"create a legcharge from qflat form.\"\"\"\n    def from_qind(cls, chargeinfo, slices, charges, qconj=1):\n        \"\"\"just a wrapper around self.__init__(), see class doc-string for parameters.\"\"\"\n    def from_qdict(cls, chargeinfo, qdict, qconj=1):\n        \"\"\"create a legcharge from qdict form.\"\"\"\n    def from_add_charge(cls, legs, chargeinfo=none):\n        \"\"\"add the (independent) charges of two or more legs to get larger `qnumber`.\"\"\"\n    def from_drop_charge(cls, leg, charge=none, chargeinfo=none):\n        \"\"\"remove a charge from a legcharge.\"\"\"\n    def from_change_charge(cls, leg, charge, new_qmod, new_name='', chargeinfo=none):\n        \"\"\"remove a charge from a legcharge.\"\"\"\n    def test_sanity(self):\n        \"\"\"sanity check, raises valueerrors, if something is wrong.\"\"\"\n    def conj(self):\n        \"\"\"return a (shallow) copy with opposite ``self.qconj``.\"\"\"\n    def flip_charges_qconj(self):\n        \"\"\"return a copy with both negative `qconj` and `charges`.\"\"\"\n    def apply_charge_mapping(self, map_func, func_args=(), func_kwargs={}):\n        \"\"\"apply mapping to :attr:`legcharge.charges`.\"\"\"\n    def to_qflat(self):\n        \"\"\"return charges in `qflat` form.\"\"\"\n    def to_qdict(self):\n        \"\"\"return charges in `qdict` form.\"\"\"\n    def is_blocked(self):\n        \"\"\"returns whether self is blocked, i.e. qindex map 1:1 to charge values.\"\"\"\n    def is_sorted(self):\n        \"\"\"returns whether `self.charges` is sorted lexicographically.\"\"\"\n    def is_bunched(self):\n        \"\"\"checks whether :meth:`bunch` would change something.\"\"\"\n    def test_contractible(self, other):\n        \"\"\"raises a valueerror if charges are incompatible for contraction with other.\"\"\"\n    def test_equal(self, other):\n        \"\"\"test if charges are *equal* including `qconj`.\"\"\"\n    def get_block_sizes(self):\n        \"\"\"return the sizes of the individual blocks.\"\"\"\n    def get_slice(self, qindex):\n        \"\"\"return slice selecting the block for a given `qindex`.\"\"\"\n    def get_qindex(self, flat_index):\n        \"\"\"find qindex containing a flat index.\"\"\"\n    def get_qindex_of_charges(self, charges):\n        \"\"\"return the slice selecting the block for given charge values.\"\"\"\n    def get_charge(self, qindex):\n        \"\"\"return charge ``self.charges[qindex] * self.qconj`` for a given `qindex`.\"\"\"\n    def sort(self, bunch=true):\n        \"\"\"return a copy of `self` sorted by charges (but maybe not bunched).\"\"\"\n    def bunch(self):\n        \"\"\"return a copy with bunched self.charges: form blocks for contiguous equal charges.\"\"\"\n    def project(self, mask):\n        \"\"\"return copy keeping only the indices specified by `mask`.\"\"\"\n    def extend(self, extra):\n        \"\"\"return a new :class:`legcharge`, which extends self with further charges.\"\"\"\n    def charge_sectors(self):\n        \"\"\"return unique rows of self.charges.\"\"\"\n    def perm_flat_from_perm_qind(self, perm_qind):\n        \"\"\"convert a permutation of qind (acting on self) into a flat permutation.\"\"\"\n    def perm_qind_from_perm_flat(self, perm_flat):\n        \"\"\"convert flat permutation into qind permutation.\"\"\" class legcharge tenpy.linalg.charges",
    "tokens": 902
  },
  {
    "category": "api",
    "name": "tenpy.linalg.charges.LegPipe",
    "content": "# API Definition: tenpy.linalg.charges.LegPipe\nclass LegPipe:\n    \"\"\"A `LegPipe` combines multiple legs of a tensor to one.\"\"\"\n    def __init__(self, legs, qconj=1, sort=True, bunch=True): pass\n    def copy(self):\n        \"\"\"Return a (shallow) copy of self.\"\"\"\n    def save_hdf5(self, hdf5_saver, h5gr, subpath):\n        \"\"\"Export `self` into a HDF5 file.\"\"\"\n    def from_hdf5(cls, hdf5_loader, h5gr, subpath):\n        \"\"\"Load instance from a HDF5 file.\"\"\"\n    def test_sanity(self):\n        \"\"\"Sanity check, raises ValueErrors, if something is wrong.\"\"\"\n    def to_LegCharge(self):\n        \"\"\"Convert self to a LegCharge, discarding the information how to split the legs.\"\"\"\n    def apply_charge_mapping(self, map_func, func_args=(), func_kwargs={}): pass\n    def conj(self):\n        \"\"\"Return a shallow copy with opposite ``self.qconj``.\"\"\"\n    def outer_conj(self):\n        \"\"\"Like :meth:`conj`, but don't change ``qconj`` for incoming legs.\"\"\"\n    def sort(self, *args, **kwargs):\n        \"\"\"Convert to LegCharge and call :meth:`LegCharge.sort`.\"\"\"\n    def bunch(self, *args, **kwargs):\n        \"\"\"Convert to LegCharge and call :meth:`LegCharge.bunch`.\"\"\"\n    def project(self, *args, **kwargs):\n        \"\"\"Convert self to LegCharge and call :meth:`LegCharge.project`.\"\"\"\n    def map_incoming_flat(self, incoming_indices):\n        \"\"\"Map (flat) incoming indices to an index in the outgoing pipe.\"\"\"",
    "search_text": "tenpy.linalg.charges.legpipe # api definition: tenpy.linalg.charges.legpipe\nclass legpipe:\n    \"\"\"a `legpipe` combines multiple legs of a tensor to one.\"\"\"\n    def __init__(self, legs, qconj=1, sort=true, bunch=true): pass\n    def copy(self):\n        \"\"\"return a (shallow) copy of self.\"\"\"\n    def save_hdf5(self, hdf5_saver, h5gr, subpath):\n        \"\"\"export `self` into a hdf5 file.\"\"\"\n    def from_hdf5(cls, hdf5_loader, h5gr, subpath):\n        \"\"\"load instance from a hdf5 file.\"\"\"\n    def test_sanity(self):\n        \"\"\"sanity check, raises valueerrors, if something is wrong.\"\"\"\n    def to_legcharge(self):\n        \"\"\"convert self to a legcharge, discarding the information how to split the legs.\"\"\"\n    def apply_charge_mapping(self, map_func, func_args=(), func_kwargs={}): pass\n    def conj(self):\n        \"\"\"return a shallow copy with opposite ``self.qconj``.\"\"\"\n    def outer_conj(self):\n        \"\"\"like :meth:`conj`, but don't change ``qconj`` for incoming legs.\"\"\"\n    def sort(self, *args, **kwargs):\n        \"\"\"convert to legcharge and call :meth:`legcharge.sort`.\"\"\"\n    def bunch(self, *args, **kwargs):\n        \"\"\"convert to legcharge and call :meth:`legcharge.bunch`.\"\"\"\n    def project(self, *args, **kwargs):\n        \"\"\"convert self to legcharge and call :meth:`legcharge.project`.\"\"\"\n    def map_incoming_flat(self, incoming_indices):\n        \"\"\"map (flat) incoming indices to an index in the outgoing pipe.\"\"\" class legpipe tenpy.linalg.charges",
    "tokens": 358
  },
  {
    "category": "api",
    "name": "tenpy.linalg.truncation.TruncationError",
    "content": "# API Definition: tenpy.linalg.truncation.TruncationError\nclass TruncationError:\n    \"\"\"Class representing a truncation error.\"\"\"\n    def __init__(self, eps=0.0, ov=1.0): pass\n    def copy(self):\n        \"\"\"Return a copy of self.\"\"\"\n    def from_norm(cls, norm_new, norm_old=1.0):\n        \"\"\"Construct TruncationError from norm after and before the truncation.\"\"\"\n    def from_S(cls, S_discarded, norm_old=None):\n        \"\"\"Construct TruncationError from discarded singular values.\"\"\"\n    def ov_err(self):\n        \"\"\"Error ``1.-ov`` of the overlap with the correct state.\"\"\"",
    "search_text": "tenpy.linalg.truncation.truncationerror # api definition: tenpy.linalg.truncation.truncationerror\nclass truncationerror:\n    \"\"\"class representing a truncation error.\"\"\"\n    def __init__(self, eps=0.0, ov=1.0): pass\n    def copy(self):\n        \"\"\"return a copy of self.\"\"\"\n    def from_norm(cls, norm_new, norm_old=1.0):\n        \"\"\"construct truncationerror from norm after and before the truncation.\"\"\"\n    def from_s(cls, s_discarded, norm_old=none):\n        \"\"\"construct truncationerror from discarded singular values.\"\"\"\n    def ov_err(self):\n        \"\"\"error ``1.-ov`` of the overlap with the correct state.\"\"\" class truncationerror tenpy.linalg.truncation",
    "tokens": 144
  },
  {
    "category": "api",
    "name": "tenpy.linalg.truncation.truncate",
    "content": "# API Function: tenpy.linalg.truncation.truncate\ndef truncate(S, options):\n    \"\"\"Given a Schmidt spectrum `S`, determine which values to keep.\"\"\"",
    "search_text": "tenpy.linalg.truncation.truncate # api function: tenpy.linalg.truncation.truncate\ndef truncate(s, options):\n    \"\"\"given a schmidt spectrum `s`, determine which values to keep.\"\"\" function truncate",
    "tokens": 34
  },
  {
    "category": "api",
    "name": "tenpy.linalg.truncation.svd_theta",
    "content": "# API Function: tenpy.linalg.truncation.svd_theta\ndef svd_theta(theta, trunc_par, qtotal_LR=[None, None], inner_labels=['vR', 'vL']):\n    \"\"\"Performs SVD of a matrix `theta` (= the wavefunction) and truncates it.\"\"\"",
    "search_text": "tenpy.linalg.truncation.svd_theta # api function: tenpy.linalg.truncation.svd_theta\ndef svd_theta(theta, trunc_par, qtotal_lr=[none, none], inner_labels=['vr', 'vl']):\n    \"\"\"performs svd of a matrix `theta` (= the wavefunction) and truncates it.\"\"\" function svd_theta",
    "tokens": 63
  },
  {
    "category": "api",
    "name": "tenpy.linalg.truncation.eigh_rho",
    "content": "# API Function: tenpy.linalg.truncation.eigh_rho\ndef eigh_rho(rho, trunc_par, UPLO='L', sort=None):\n    \"\"\"Performs EIG of a hermitian matrix `rho` (= density matrix) and truncates it.\"\"\"",
    "search_text": "tenpy.linalg.truncation.eigh_rho # api function: tenpy.linalg.truncation.eigh_rho\ndef eigh_rho(rho, trunc_par, uplo='l', sort=none):\n    \"\"\"performs eig of a hermitian matrix `rho` (= density matrix) and truncates it.\"\"\" function eigh_rho",
    "tokens": 56
  },
  {
    "category": "api",
    "name": "tenpy.linalg.truncation.decompose_theta_qr_based",
    "content": "# API Function: tenpy.linalg.truncation.decompose_theta_qr_based\ndef decompose_theta_qr_based(old_qtotal_L, old_qtotal_R, old_bond_leg, theta: npc.Array, move_right: bool, expand: float, min_block_increase: int, use_eig_based_svd: bool, trunc_params: dict, compute_err: bool, return_both_T: bool):\n    \"\"\"Performs a QR based decomposition of a matrix `theta` (= the wavefunction) and truncates it.\"\"\"",
    "search_text": "tenpy.linalg.truncation.decompose_theta_qr_based # api function: tenpy.linalg.truncation.decompose_theta_qr_based\ndef decompose_theta_qr_based(old_qtotal_l, old_qtotal_r, old_bond_leg, theta: npc.array, move_right: bool, expand: float, min_block_increase: int, use_eig_based_svd: bool, trunc_params: dict, compute_err: bool, return_both_t: bool):\n    \"\"\"performs a qr based decomposition of a matrix `theta` (= the wavefunction) and truncates it.\"\"\" function decompose_theta_qr_based",
    "tokens": 108
  },
  {
    "category": "api",
    "name": "tenpy.linalg.random_matrix.box",
    "content": "# API Function: tenpy.linalg.random_matrix.box\ndef box(size, W=1.0):\n    \"\"\"Return random number uniform in (-W, W].\"\"\"",
    "search_text": "tenpy.linalg.random_matrix.box # api function: tenpy.linalg.random_matrix.box\ndef box(size, w=1.0):\n    \"\"\"return random number uniform in (-w, w].\"\"\" function box",
    "tokens": 34
  },
  {
    "category": "api",
    "name": "tenpy.linalg.random_matrix.standard_normal_complex",
    "content": "# API Function: tenpy.linalg.random_matrix.standard_normal_complex\ndef standard_normal_complex(size):\n    \"\"\"Return ``(R + 1.j*I)`` for independent `R` and `I` from np.random.standard_normal.\"\"\"",
    "search_text": "tenpy.linalg.random_matrix.standard_normal_complex # api function: tenpy.linalg.random_matrix.standard_normal_complex\ndef standard_normal_complex(size):\n    \"\"\"return ``(r + 1.j*i)`` for independent `r` and `i` from np.random.standard_normal.\"\"\" function standard_normal_complex",
    "tokens": 46
  },
  {
    "category": "api",
    "name": "tenpy.linalg.random_matrix.GOE",
    "content": "# API Function: tenpy.linalg.random_matrix.GOE\ndef GOE(size):\n    \"\"\"Gaussian orthogonal ensemble (GOE).\"\"\"",
    "search_text": "tenpy.linalg.random_matrix.goe # api function: tenpy.linalg.random_matrix.goe\ndef goe(size):\n    \"\"\"gaussian orthogonal ensemble (goe).\"\"\" function goe",
    "tokens": 28
  },
  {
    "category": "api",
    "name": "tenpy.linalg.random_matrix.GUE",
    "content": "# API Function: tenpy.linalg.random_matrix.GUE\ndef GUE(size):\n    \"\"\"Gaussian unitary ensemble (GUE).\"\"\"",
    "search_text": "tenpy.linalg.random_matrix.gue # api function: tenpy.linalg.random_matrix.gue\ndef gue(size):\n    \"\"\"gaussian unitary ensemble (gue).\"\"\" function gue",
    "tokens": 29
  },
  {
    "category": "api",
    "name": "tenpy.linalg.random_matrix.CRE",
    "content": "# API Function: tenpy.linalg.random_matrix.CRE\ndef CRE(size):\n    \"\"\"Circular real ensemble (CRE).\"\"\"",
    "search_text": "tenpy.linalg.random_matrix.cre # api function: tenpy.linalg.random_matrix.cre\ndef cre(size):\n    \"\"\"circular real ensemble (cre).\"\"\" function cre",
    "tokens": 25
  },
  {
    "category": "api",
    "name": "tenpy.linalg.random_matrix.COE",
    "content": "# API Function: tenpy.linalg.random_matrix.COE\ndef COE(size):\n    \"\"\"Circular orthogonal ensemble (COE).\"\"\"",
    "search_text": "tenpy.linalg.random_matrix.coe # api function: tenpy.linalg.random_matrix.coe\ndef coe(size):\n    \"\"\"circular orthogonal ensemble (coe).\"\"\" function coe",
    "tokens": 27
  },
  {
    "category": "api",
    "name": "tenpy.linalg.random_matrix.CUE",
    "content": "# API Function: tenpy.linalg.random_matrix.CUE\ndef CUE(size):\n    \"\"\"Circular unitary ensemble (CUE).\"\"\"",
    "search_text": "tenpy.linalg.random_matrix.cue # api function: tenpy.linalg.random_matrix.cue\ndef cue(size):\n    \"\"\"circular unitary ensemble (cue).\"\"\" function cue",
    "tokens": 28
  },
  {
    "category": "api",
    "name": "tenpy.linalg.random_matrix.O_close_1",
    "content": "# API Function: tenpy.linalg.random_matrix.O_close_1\ndef O_close_1(size, a=0.01):\n    \"\"\"Return an random orthogonal matrix 'close' to the Identity.\"\"\"",
    "search_text": "tenpy.linalg.random_matrix.o_close_1 # api function: tenpy.linalg.random_matrix.o_close_1\ndef o_close_1(size, a=0.01):\n    \"\"\"return an random orthogonal matrix 'close' to the identity.\"\"\" function o_close_1",
    "tokens": 41
  },
  {
    "category": "api",
    "name": "tenpy.linalg.random_matrix.U_close_1",
    "content": "# API Function: tenpy.linalg.random_matrix.U_close_1\ndef U_close_1(size, a=0.01):\n    \"\"\"Return an random orthogonal matrix 'close' to the identity.\"\"\"",
    "search_text": "tenpy.linalg.random_matrix.u_close_1 # api function: tenpy.linalg.random_matrix.u_close_1\ndef u_close_1(size, a=0.01):\n    \"\"\"return an random orthogonal matrix 'close' to the identity.\"\"\" function u_close_1",
    "tokens": 41
  },
  {
    "category": "api",
    "name": "tenpy.simulations.post_processing.DataLoader",
    "content": "# API Definition: tenpy.simulations.post_processing.DataLoader\nclass DataLoader:\n    \"\"\"Post-processing class to handle IO and get Model and MPS from saved simulation data.\"\"\"\n    def __init__(self, filename=None, simulation=None, data=None): pass\n    def close(self): pass\n    def measurements(self): pass\n    def get_data_m(self, key, prefix='measurements/', convert_to_numpy=True): pass\n    def get_data(self, key, prefix='', convert_to_numpy=False): pass\n    def convert_list_to_ndarray(self, value, key): pass\n    def model(self): pass\n    def get_model(self):\n        \"\"\"Deprecated in favor of the simpler property access via :attr:`DataLoader.model`.\"\"\"\n    def lat(self): pass\n    def BZ(self): pass\n    def psi(self): pass\n    def get_all_keys_as_dict(self): pass",
    "search_text": "tenpy.simulations.post_processing.dataloader # api definition: tenpy.simulations.post_processing.dataloader\nclass dataloader:\n    \"\"\"post-processing class to handle io and get model and mps from saved simulation data.\"\"\"\n    def __init__(self, filename=none, simulation=none, data=none): pass\n    def close(self): pass\n    def measurements(self): pass\n    def get_data_m(self, key, prefix='measurements/', convert_to_numpy=true): pass\n    def get_data(self, key, prefix='', convert_to_numpy=false): pass\n    def convert_list_to_ndarray(self, value, key): pass\n    def model(self): pass\n    def get_model(self):\n        \"\"\"deprecated in favor of the simpler property access via :attr:`dataloader.model`.\"\"\"\n    def lat(self): pass\n    def bz(self): pass\n    def psi(self): pass\n    def get_all_keys_as_dict(self): pass class dataloader tenpy.simulations.post_processing",
    "tokens": 183
  },
  {
    "category": "api",
    "name": "tenpy.simulations.post_processing.DataFiles",
    "content": "# API Definition: tenpy.simulations.post_processing.DataFiles\nclass DataFiles:\n    \"\"\"Hold multiple DataLoader instances open, indexed by the filename.\"\"\"\n    def __init__(self, files=None, folder=None): pass\n    def close(self):\n        \"\"\"Close all files held open by self.\"\"\"\n    def keys(self):\n        \"\"\"Return paths of the files opened.\"\"\"\n    def values(self):\n        \"\"\"Return iterator over the :class:`DataLoader` instances.\"\"\"\n    def items(self): pass\n    def load_from_folder(self, folder, glob='*.h5'):\n        \"\"\"Load all data files from a given folder.\"\"\"",
    "search_text": "tenpy.simulations.post_processing.datafiles # api definition: tenpy.simulations.post_processing.datafiles\nclass datafiles:\n    \"\"\"hold multiple dataloader instances open, indexed by the filename.\"\"\"\n    def __init__(self, files=none, folder=none): pass\n    def close(self):\n        \"\"\"close all files held open by self.\"\"\"\n    def keys(self):\n        \"\"\"return paths of the files opened.\"\"\"\n    def values(self):\n        \"\"\"return iterator over the :class:`dataloader` instances.\"\"\"\n    def items(self): pass\n    def load_from_folder(self, folder, glob='*.h5'):\n        \"\"\"load all data files from a given folder.\"\"\" class datafiles tenpy.simulations.post_processing",
    "tokens": 126
  },
  {
    "category": "api",
    "name": "tenpy.simulations.post_processing.pp_spectral_function",
    "content": "# API Function: tenpy.simulations.post_processing.pp_spectral_function\ndef pp_spectral_function(DL: DataLoader, **kwargs):\n    \"\"\"Given a time dependent correlation function C(t, r), calculate its Spectral Function.\"\"\"",
    "search_text": "tenpy.simulations.post_processing.pp_spectral_function # api function: tenpy.simulations.post_processing.pp_spectral_function\ndef pp_spectral_function(dl: dataloader, **kwargs):\n    \"\"\"given a time dependent correlation function c(t, r), calculate its spectral function.\"\"\" function pp_spectral_function",
    "tokens": 47
  },
  {
    "category": "api",
    "name": "tenpy.simulations.post_processing.pp_plot_correlations_on_lattice",
    "content": "# API Function: tenpy.simulations.post_processing.pp_plot_correlations_on_lattice\ndef pp_plot_correlations_on_lattice(DL: DataLoader, **kwargs):\n    \"\"\"Save a plot during post-processing to plot correlations on a lattice.\"\"\"",
    "search_text": "tenpy.simulations.post_processing.pp_plot_correlations_on_lattice # api function: tenpy.simulations.post_processing.pp_plot_correlations_on_lattice\ndef pp_plot_correlations_on_lattice(dl: dataloader, **kwargs):\n    \"\"\"save a plot during post-processing to plot correlations on a lattice.\"\"\" function pp_plot_correlations_on_lattice",
    "tokens": 49
  },
  {
    "category": "api",
    "name": "tenpy.simulations.time_evolution.RealTimeEvolution",
    "content": "# API Definition: tenpy.simulations.time_evolution.RealTimeEvolution\nclass RealTimeEvolution:\n    \"\"\"Perform a real-time evolution on a tensor network state.\"\"\"\n    def __init__(self, options, **kwargs): pass\n    def run_algorithm(self):\n        \"\"\"Run the algorithm.\"\"\"\n    def perform_measurements(self): pass\n    def resume_run_algorithm(self): pass\n    def final_measurements(self):\n        \"\"\"Do nothing.\"\"\"\n    def eps_error(self):\n        \"\"\"Accumulated eps error since the start of the time-evolution.\"\"\"\n    def ov_error(self):\n        \"\"\"Total ov error of the time-evolution.\"\"\"",
    "search_text": "tenpy.simulations.time_evolution.realtimeevolution # api definition: tenpy.simulations.time_evolution.realtimeevolution\nclass realtimeevolution:\n    \"\"\"perform a real-time evolution on a tensor network state.\"\"\"\n    def __init__(self, options, **kwargs): pass\n    def run_algorithm(self):\n        \"\"\"run the algorithm.\"\"\"\n    def perform_measurements(self): pass\n    def resume_run_algorithm(self): pass\n    def final_measurements(self):\n        \"\"\"do nothing.\"\"\"\n    def eps_error(self):\n        \"\"\"accumulated eps error since the start of the time-evolution.\"\"\"\n    def ov_error(self):\n        \"\"\"total ov error of the time-evolution.\"\"\" class realtimeevolution tenpy.simulations.time_evolution",
    "tokens": 130
  },
  {
    "category": "api",
    "name": "tenpy.simulations.time_evolution.TimeDependentCorrelation",
    "content": "# API Definition: tenpy.simulations.time_evolution.TimeDependentCorrelation\nclass TimeDependentCorrelation:\n    \"\"\"Specialized :class:`RealTimeEvolution` to calculate a time dependent correlation function of a ground state.\"\"\"\n    def __init__(self, options, **kwargs): pass\n    def resume_run(self): pass\n    def get_resume_data(self): pass\n    def init_measurements(self): pass\n    def init_state(self): pass\n    def init_algorithm(self, **kwargs): pass\n    def apply_operator_t0_to_psi(self): pass\n    def m_correlation_function(self, results, psi, model, simulation, **kwargs):\n        \"\"\"Measurement function for time dependent correlations.\"\"\"",
    "search_text": "tenpy.simulations.time_evolution.timedependentcorrelation # api definition: tenpy.simulations.time_evolution.timedependentcorrelation\nclass timedependentcorrelation:\n    \"\"\"specialized :class:`realtimeevolution` to calculate a time dependent correlation function of a ground state.\"\"\"\n    def __init__(self, options, **kwargs): pass\n    def resume_run(self): pass\n    def get_resume_data(self): pass\n    def init_measurements(self): pass\n    def init_state(self): pass\n    def init_algorithm(self, **kwargs): pass\n    def apply_operator_t0_to_psi(self): pass\n    def m_correlation_function(self, results, psi, model, simulation, **kwargs):\n        \"\"\"measurement function for time dependent correlations.\"\"\" class timedependentcorrelation tenpy.simulations.time_evolution",
    "tokens": 148
  },
  {
    "category": "api",
    "name": "tenpy.simulations.time_evolution.TimeDependentCorrelationEvolveBraKet",
    "content": "# API Definition: tenpy.simulations.time_evolution.TimeDependentCorrelationEvolveBraKet\nclass TimeDependentCorrelationEvolveBraKet:\n    \"\"\"Evolving the bra and ket state in :class:`TimeDependentCorrelation`.\"\"\"\n    def __init__(self, *args, **kwargs): pass\n    def init_algorithm(self, **kwargs): pass\n    def run_algorithm(self): pass\n    def m_correlation_function(self, results, psi, model, simulation, **kwargs):\n        \"\"\"Equivalent to :meth:`TimeDependentCorrelation.m_correlation_function`.\"\"\"\n    def get_resume_data(self):\n        \"\"\"Get resume data for a Simulation for two engines.\"\"\"\n    def estimate_RAM(self): pass\n    def group_sites_for_algorithm(self): pass\n    def group_split(self):\n        \"\"\"Split sites of psi that were grouped in  :meth:`group_sites_for_algorithm`.\"\"\"",
    "search_text": "tenpy.simulations.time_evolution.timedependentcorrelationevolvebraket # api definition: tenpy.simulations.time_evolution.timedependentcorrelationevolvebraket\nclass timedependentcorrelationevolvebraket:\n    \"\"\"evolving the bra and ket state in :class:`timedependentcorrelation`.\"\"\"\n    def __init__(self, *args, **kwargs): pass\n    def init_algorithm(self, **kwargs): pass\n    def run_algorithm(self): pass\n    def m_correlation_function(self, results, psi, model, simulation, **kwargs):\n        \"\"\"equivalent to :meth:`timedependentcorrelation.m_correlation_function`.\"\"\"\n    def get_resume_data(self):\n        \"\"\"get resume data for a simulation for two engines.\"\"\"\n    def estimate_ram(self): pass\n    def group_sites_for_algorithm(self): pass\n    def group_split(self):\n        \"\"\"split sites of psi that were grouped in  :meth:`group_sites_for_algorithm`.\"\"\" class timedependentcorrelationevolvebraket tenpy.simulations.time_evolution",
    "tokens": 191
  },
  {
    "category": "api",
    "name": "tenpy.simulations.time_evolution.SpectralSimulation",
    "content": "# API Definition: tenpy.simulations.time_evolution.SpectralSimulation\nclass SpectralSimulation:\n    \"\"\"Simulation class to calculate Spectral Functions.\"\"\"\n    def __init__(self, options, **kwargs): pass\n    def run_post_processing(self): pass",
    "search_text": "tenpy.simulations.time_evolution.spectralsimulation # api definition: tenpy.simulations.time_evolution.spectralsimulation\nclass spectralsimulation:\n    \"\"\"simulation class to calculate spectral functions.\"\"\"\n    def __init__(self, options, **kwargs): pass\n    def run_post_processing(self): pass class spectralsimulation tenpy.simulations.time_evolution",
    "tokens": 52
  },
  {
    "category": "api",
    "name": "tenpy.simulations.time_evolution.SpectralSimulationEvolveBraKet",
    "content": "# API Definition: tenpy.simulations.time_evolution.SpectralSimulationEvolveBraKet\nclass SpectralSimulationEvolveBraKet:\n",
    "search_text": "tenpy.simulations.time_evolution.spectralsimulationevolvebraket # api definition: tenpy.simulations.time_evolution.spectralsimulationevolvebraket\nclass spectralsimulationevolvebraket:\n class spectralsimulationevolvebraket tenpy.simulations.time_evolution",
    "tokens": 32
  },
  {
    "category": "api",
    "name": "tenpy.simulations.simulation.Simulation",
    "content": "# API Definition: tenpy.simulations.simulation.Simulation\nclass Simulation:\n    \"\"\"Base class for simulations.\"\"\"\n    def __init__(self, options): pass\n    def handle_abort_signal(self, signum, frame):\n        \"\"\"Handle a SIGINT signal, usually caused by a CTRL-C press.\"\"\"\n    def estimate_RAM(self):\n        \"\"\"Estimates the RAM usage for the simulation, without running it.\"\"\"\n    def run(self):\n        \"\"\"Run the whole simulation.\"\"\"\n    def from_saved_checkpoint(cls, filename=None, checkpoint_results=None, **kwargs):\n        \"\"\"Re-initialize a given simulation class from checkpoint results.\"\"\"\n    def resume_run(self):\n        \"\"\"Resume a simulation that was initialized from a checkpoint.\"\"\"\n    def init_cache(self):\n        \"\"\"Initialize the :attr:`cache` from the options.\"\"\"\n    def init_model(self):\n        \"\"\"Initialize a :attr:`model` from the model parameters.\"\"\"\n    def init_state(self):\n        \"\"\"Initialize a tensor network :attr:`psi`.\"\"\"\n    def group_sites_for_algorithm(self):\n        \"\"\"Coarse-grain the model and state for the algorithm.\"\"\"\n    def group_split(self):\n        \"\"\"Split sites of psi that were grouped in  :meth:`group_sites_for_algorithm`.\"\"\"\n    def init_algorithm(self, **kwargs):\n        \"\"\"Initialize the algorithm.\"\"\"\n    def init_measurements(self):\n        \"\"\"Initialize and prepare measurements.\"\"\"\n    def run_algorithm(self):\n        \"\"\"Run the algorithm.\"\"\"\n    def resume_run_algorithm(self):\n        \"\"\"Resume running the algorithm.\"\"\"\n    def make_measurements(self):\n        \"\"\"Perform measurements and merge the results into ``self.results['measurements']``.\"\"\"\n    def perform_measurements(self):\n        \"\"\"Emits the :attr:`measurement_event` to call measurement functions and collect results.\"\"\"\n    def get_measurement_psi_model(self, psi, model):\n        \"\"\"Get psi for measurements.\"\"\"\n    def final_measurements(self):\n        \"\"\"Perform a last set of measurements.\"\"\"\n    def run_post_processing(self):\n        \"\"\"Apply (several) post-processing steps.\"\"\"\n    def get_version_info(self):\n        \"\"\"Try to save version info which is necessary to allow reproducibility.\"\"\"\n    def get_output_filename(self):\n        \"\"\"Read out the `output_filename` from the options.\"\"\"\n    def fix_output_filenames(self):\n        \"\"\"Determine the output filenames.\"\"\"\n    def get_backup_filename(self, output_filename):\n        \"\"\"Extract the name used for backups of `output_filename`.\"\"\"\n    def save_results(self, results=None):\n        \"\"\"Save the :attr:`results` to an output file.\"\"\"\n    def prepare_results_for_save(self):\n        \"\"\"Bring the `results` into a state suitable for saving.\"\"\"\n    def get_resume_data(self):\n        \"\"\"Get resume data for a Simulation.\"\"\"\n    def save_at_checkpoint(self, alg_engine):\n        \"\"\"Save the intermediate results at the checkpoint of an algorithm.\"\"\"\n    def walltime(self):\n        \"\"\"Wall time evolved since initialization of the simulation class.\"\"\"",
    "search_text": "tenpy.simulations.simulation.simulation # api definition: tenpy.simulations.simulation.simulation\nclass simulation:\n    \"\"\"base class for simulations.\"\"\"\n    def __init__(self, options): pass\n    def handle_abort_signal(self, signum, frame):\n        \"\"\"handle a sigint signal, usually caused by a ctrl-c press.\"\"\"\n    def estimate_ram(self):\n        \"\"\"estimates the ram usage for the simulation, without running it.\"\"\"\n    def run(self):\n        \"\"\"run the whole simulation.\"\"\"\n    def from_saved_checkpoint(cls, filename=none, checkpoint_results=none, **kwargs):\n        \"\"\"re-initialize a given simulation class from checkpoint results.\"\"\"\n    def resume_run(self):\n        \"\"\"resume a simulation that was initialized from a checkpoint.\"\"\"\n    def init_cache(self):\n        \"\"\"initialize the :attr:`cache` from the options.\"\"\"\n    def init_model(self):\n        \"\"\"initialize a :attr:`model` from the model parameters.\"\"\"\n    def init_state(self):\n        \"\"\"initialize a tensor network :attr:`psi`.\"\"\"\n    def group_sites_for_algorithm(self):\n        \"\"\"coarse-grain the model and state for the algorithm.\"\"\"\n    def group_split(self):\n        \"\"\"split sites of psi that were grouped in  :meth:`group_sites_for_algorithm`.\"\"\"\n    def init_algorithm(self, **kwargs):\n        \"\"\"initialize the algorithm.\"\"\"\n    def init_measurements(self):\n        \"\"\"initialize and prepare measurements.\"\"\"\n    def run_algorithm(self):\n        \"\"\"run the algorithm.\"\"\"\n    def resume_run_algorithm(self):\n        \"\"\"resume running the algorithm.\"\"\"\n    def make_measurements(self):\n        \"\"\"perform measurements and merge the results into ``self.results['measurements']``.\"\"\"\n    def perform_measurements(self):\n        \"\"\"emits the :attr:`measurement_event` to call measurement functions and collect results.\"\"\"\n    def get_measurement_psi_model(self, psi, model):\n        \"\"\"get psi for measurements.\"\"\"\n    def final_measurements(self):\n        \"\"\"perform a last set of measurements.\"\"\"\n    def run_post_processing(self):\n        \"\"\"apply (several) post-processing steps.\"\"\"\n    def get_version_info(self):\n        \"\"\"try to save version info which is necessary to allow reproducibility.\"\"\"\n    def get_output_filename(self):\n        \"\"\"read out the `output_filename` from the options.\"\"\"\n    def fix_output_filenames(self):\n        \"\"\"determine the output filenames.\"\"\"\n    def get_backup_filename(self, output_filename):\n        \"\"\"extract the name used for backups of `output_filename`.\"\"\"\n    def save_results(self, results=none):\n        \"\"\"save the :attr:`results` to an output file.\"\"\"\n    def prepare_results_for_save(self):\n        \"\"\"bring the `results` into a state suitable for saving.\"\"\"\n    def get_resume_data(self):\n        \"\"\"get resume data for a simulation.\"\"\"\n    def save_at_checkpoint(self, alg_engine):\n        \"\"\"save the intermediate results at the checkpoint of an algorithm.\"\"\"\n    def walltime(self):\n        \"\"\"wall time evolved since initialization of the simulation class.\"\"\" class simulation tenpy.simulations.simulation",
    "tokens": 592
  },
  {
    "category": "api",
    "name": "tenpy.simulations.simulation.Skip",
    "content": "# API Definition: tenpy.simulations.simulation.Skip\nclass Skip:\n    \"\"\"Error raised if simulation output already exists.\"\"\"\n    def __init__(self, msg, filename): pass",
    "search_text": "tenpy.simulations.simulation.skip # api definition: tenpy.simulations.simulation.skip\nclass skip:\n    \"\"\"error raised if simulation output already exists.\"\"\"\n    def __init__(self, msg, filename): pass class skip tenpy.simulations.simulation",
    "tokens": 37
  },
  {
    "category": "api",
    "name": "tenpy.simulations.simulation.init_simulation",
    "content": "# API Function: tenpy.simulations.simulation.init_simulation\ndef init_simulation(simulation_class='GroundStateSearch', simulation_class_kwargs=None, **simulation_params):\n    \"\"\"Run the simulation with a simulation class.\"\"\"",
    "search_text": "tenpy.simulations.simulation.init_simulation # api function: tenpy.simulations.simulation.init_simulation\ndef init_simulation(simulation_class='groundstatesearch', simulation_class_kwargs=none, **simulation_params):\n    \"\"\"run the simulation with a simulation class.\"\"\" function init_simulation",
    "tokens": 43
  },
  {
    "category": "api",
    "name": "tenpy.simulations.simulation.run_simulation",
    "content": "# API Function: tenpy.simulations.simulation.run_simulation\ndef run_simulation(simulation_class='GroundStateSearch', simulation_class_kwargs=None, **simulation_params):\n    \"\"\"Run the simulation with a simulation class.\"\"\"",
    "search_text": "tenpy.simulations.simulation.run_simulation # api function: tenpy.simulations.simulation.run_simulation\ndef run_simulation(simulation_class='groundstatesearch', simulation_class_kwargs=none, **simulation_params):\n    \"\"\"run the simulation with a simulation class.\"\"\" function run_simulation",
    "tokens": 43
  },
  {
    "category": "api",
    "name": "tenpy.simulations.simulation.init_simulation_from_checkpoint",
    "content": "# API Function: tenpy.simulations.simulation.init_simulation_from_checkpoint\ndef init_simulation_from_checkpoint():\n    \"\"\"Re-initialize a simulation from a given checkpoint without running it.\"\"\"",
    "search_text": "tenpy.simulations.simulation.init_simulation_from_checkpoint # api function: tenpy.simulations.simulation.init_simulation_from_checkpoint\ndef init_simulation_from_checkpoint():\n    \"\"\"re-initialize a simulation from a given checkpoint without running it.\"\"\" function init_simulation_from_checkpoint",
    "tokens": 36
  },
  {
    "category": "api",
    "name": "tenpy.simulations.simulation.resume_from_checkpoint",
    "content": "# API Function: tenpy.simulations.simulation.resume_from_checkpoint\ndef resume_from_checkpoint():\n    \"\"\"Resume a simulation run from a given checkpoint.\"\"\"",
    "search_text": "tenpy.simulations.simulation.resume_from_checkpoint # api function: tenpy.simulations.simulation.resume_from_checkpoint\ndef resume_from_checkpoint():\n    \"\"\"resume a simulation run from a given checkpoint.\"\"\" function resume_from_checkpoint",
    "tokens": 30
  },
  {
    "category": "api",
    "name": "tenpy.simulations.simulation.run_seq_simulations",
    "content": "# API Function: tenpy.simulations.simulation.run_seq_simulations\ndef run_seq_simulations(sequential, simulation_class='GroundStateSearch', simulation_class_kwargs=None, **simulation_params):\n    \"\"\"Sequentially run (variational) simulations.\"\"\"",
    "search_text": "tenpy.simulations.simulation.run_seq_simulations # api function: tenpy.simulations.simulation.run_seq_simulations\ndef run_seq_simulations(sequential, simulation_class='groundstatesearch', simulation_class_kwargs=none, **simulation_params):\n    \"\"\"sequentially run (variational) simulations.\"\"\" function run_seq_simulations",
    "tokens": 50
  },
  {
    "category": "api",
    "name": "tenpy.simulations.simulation.estimate_simulation_RAM",
    "content": "# API Function: tenpy.simulations.simulation.estimate_simulation_RAM\ndef estimate_simulation_RAM(**simulation_params):\n    \"\"\"Pre-simulation RAM estimate.\"\"\"",
    "search_text": "tenpy.simulations.simulation.estimate_simulation_ram # api function: tenpy.simulations.simulation.estimate_simulation_ram\ndef estimate_simulation_ram(**simulation_params):\n    \"\"\"pre-simulation ram estimate.\"\"\" function estimate_simulation_ram",
    "tokens": 31
  },
  {
    "category": "api",
    "name": "tenpy.simulations.simulation.output_filename_from_dict",
    "content": "# API Function: tenpy.simulations.simulation.output_filename_from_dict\ndef output_filename_from_dict(options, parts={}, prefix='result', suffix='.h5', joint='_', parts_order=None, separator='.'):\n    \"\"\"Format a `output_filename` from parts with values from nested `options`.\"\"\"",
    "search_text": "tenpy.simulations.simulation.output_filename_from_dict # api function: tenpy.simulations.simulation.output_filename_from_dict\ndef output_filename_from_dict(options, parts={}, prefix='result', suffix='.h5', joint='_', parts_order=none, separator='.'):\n    \"\"\"format a `output_filename` from parts with values from nested `options`.\"\"\" function output_filename_from_dict",
    "tokens": 61
  },
  {
    "category": "api",
    "name": "tenpy.simulations.measurement.measurement_wrapper",
    "content": "# API Function: tenpy.simulations.measurement.measurement_wrapper\ndef measurement_wrapper(function, results_key, **kwargs):\n    \"\"\"Decorator to transform a function into a measurement function.\"\"\"",
    "search_text": "tenpy.simulations.measurement.measurement_wrapper # api function: tenpy.simulations.measurement.measurement_wrapper\ndef measurement_wrapper(function, results_key, **kwargs):\n    \"\"\"decorator to transform a function into a measurement function.\"\"\" function measurement_wrapper",
    "tokens": 37
  },
  {
    "category": "api",
    "name": "tenpy.simulations.measurement.m_measurement_index",
    "content": "# API Function: tenpy.simulations.measurement.m_measurement_index\ndef m_measurement_index(results, psi, model, simulation, results_key='measurement_index'):\n    \"\"\"'Measure' the index of how many measurements have been performed so far.\"\"\"",
    "search_text": "tenpy.simulations.measurement.m_measurement_index # api function: tenpy.simulations.measurement.m_measurement_index\ndef m_measurement_index(results, psi, model, simulation, results_key='measurement_index'):\n    \"\"\"'measure' the index of how many measurements have been performed so far.\"\"\" function m_measurement_index",
    "tokens": 49
  },
  {
    "category": "api",
    "name": "tenpy.simulations.measurement.m_bond_dimension",
    "content": "# API Function: tenpy.simulations.measurement.m_bond_dimension\ndef m_bond_dimension(results, psi, model, simulation, results_key='bond_dimension'):\n    \"\"\"'Measure' the bond dimension of an MPS.\"\"\"",
    "search_text": "tenpy.simulations.measurement.m_bond_dimension # api function: tenpy.simulations.measurement.m_bond_dimension\ndef m_bond_dimension(results, psi, model, simulation, results_key='bond_dimension'):\n    \"\"\"'measure' the bond dimension of an mps.\"\"\" function m_bond_dimension",
    "tokens": 46
  },
  {
    "category": "api",
    "name": "tenpy.simulations.measurement.m_bond_energies",
    "content": "# API Function: tenpy.simulations.measurement.m_bond_energies\ndef m_bond_energies(results, psi, model, simulation, results_key='bond_energies'):\n    \"\"\"Measure the energy of an MPS.\"\"\"",
    "search_text": "tenpy.simulations.measurement.m_bond_energies # api function: tenpy.simulations.measurement.m_bond_energies\ndef m_bond_energies(results, psi, model, simulation, results_key='bond_energies'):\n    \"\"\"measure the energy of an mps.\"\"\" function m_bond_energies",
    "tokens": 49
  },
  {
    "category": "api",
    "name": "tenpy.simulations.measurement.m_simulation_parameter",
    "content": "# API Function: tenpy.simulations.measurement.m_simulation_parameter\ndef m_simulation_parameter(results, psi, model, simulation, recursive_key, results_key=None, **kwargs):\n    \"\"\"Dummy measurement of a simulation parameter.\"\"\"",
    "search_text": "tenpy.simulations.measurement.m_simulation_parameter # api function: tenpy.simulations.measurement.m_simulation_parameter\ndef m_simulation_parameter(results, psi, model, simulation, recursive_key, results_key=none, **kwargs):\n    \"\"\"dummy measurement of a simulation parameter.\"\"\" function m_simulation_parameter",
    "tokens": 45
  },
  {
    "category": "api",
    "name": "tenpy.simulations.measurement.m_energy_MPO",
    "content": "# API Function: tenpy.simulations.measurement.m_energy_MPO\ndef m_energy_MPO(results, psi, model, simulation, results_key='energy_MPO'):\n    \"\"\"Measure the energy of an MPS by evaluating the MPS expectation value.\"\"\"",
    "search_text": "tenpy.simulations.measurement.m_energy_mpo # api function: tenpy.simulations.measurement.m_energy_mpo\ndef m_energy_mpo(results, psi, model, simulation, results_key='energy_mpo'):\n    \"\"\"measure the energy of an mps by evaluating the mps expectation value.\"\"\" function m_energy_mpo",
    "tokens": 50
  },
  {
    "category": "api",
    "name": "tenpy.simulations.measurement.m_entropy",
    "content": "# API Function: tenpy.simulations.measurement.m_entropy\ndef m_entropy(results, psi, model, simulation, results_key='entropy'):\n    \"\"\"Measure the entropy at all bonds of an MPS.\"\"\"",
    "search_text": "tenpy.simulations.measurement.m_entropy # api function: tenpy.simulations.measurement.m_entropy\ndef m_entropy(results, psi, model, simulation, results_key='entropy'):\n    \"\"\"measure the entropy at all bonds of an mps.\"\"\" function m_entropy",
    "tokens": 41
  },
  {
    "category": "api",
    "name": "tenpy.simulations.measurement.m_onsite_expectation_value",
    "content": "# API Function: tenpy.simulations.measurement.m_onsite_expectation_value\ndef m_onsite_expectation_value(results, psi, model, simulation, opname, results_key=None, fix_u=None, **kwargs):\n    \"\"\"Measure expectation values of an onsite operator.\"\"\"",
    "search_text": "tenpy.simulations.measurement.m_onsite_expectation_value # api function: tenpy.simulations.measurement.m_onsite_expectation_value\ndef m_onsite_expectation_value(results, psi, model, simulation, opname, results_key=none, fix_u=none, **kwargs):\n    \"\"\"measure expectation values of an onsite operator.\"\"\" function m_onsite_expectation_value",
    "tokens": 58
  },
  {
    "category": "api",
    "name": "tenpy.simulations.measurement.m_correlation_length",
    "content": "# API Function: tenpy.simulations.measurement.m_correlation_length\ndef m_correlation_length(results, psi, model, simulation, results_key='correlation_length', unit=None, **kwargs):\n    \"\"\"Measure the correlation of an infinite MPS.\"\"\"",
    "search_text": "tenpy.simulations.measurement.m_correlation_length # api function: tenpy.simulations.measurement.m_correlation_length\ndef m_correlation_length(results, psi, model, simulation, results_key='correlation_length', unit=none, **kwargs):\n    \"\"\"measure the correlation of an infinite mps.\"\"\" function m_correlation_length",
    "tokens": 51
  },
  {
    "category": "api",
    "name": "tenpy.simulations.measurement.m_evolved_time",
    "content": "# API Function: tenpy.simulations.measurement.m_evolved_time\ndef m_evolved_time(results, psi, model, simulation, results_key='evolved_time'):\n    \"\"\"Measure the time evolved by the engine, ``engine.evolved_time``.\"\"\"",
    "search_text": "tenpy.simulations.measurement.m_evolved_time # api function: tenpy.simulations.measurement.m_evolved_time\ndef m_evolved_time(results, psi, model, simulation, results_key='evolved_time'):\n    \"\"\"measure the time evolved by the engine, ``engine.evolved_time``.\"\"\" function m_evolved_time",
    "tokens": 52
  },
  {
    "category": "api",
    "name": "tenpy.simulations.ground_state_search.GroundStateSearch",
    "content": "# API Definition: tenpy.simulations.ground_state_search.GroundStateSearch\nclass GroundStateSearch:\n    \"\"\"Simulation for variational ground state searches.\"\"\"\n    def init_algorithm(self, **kwargs):\n        \"\"\"Initialize the algorithm.\"\"\"\n    def run_algorithm(self): pass\n    def resume_run_algorithm(self):\n        \"\"\"Run the algorithm.\"\"\"",
    "search_text": "tenpy.simulations.ground_state_search.groundstatesearch # api definition: tenpy.simulations.ground_state_search.groundstatesearch\nclass groundstatesearch:\n    \"\"\"simulation for variational ground state searches.\"\"\"\n    def init_algorithm(self, **kwargs):\n        \"\"\"initialize the algorithm.\"\"\"\n    def run_algorithm(self): pass\n    def resume_run_algorithm(self):\n        \"\"\"run the algorithm.\"\"\" class groundstatesearch tenpy.simulations.ground_state_search",
    "tokens": 68
  },
  {
    "category": "api",
    "name": "tenpy.simulations.ground_state_search.PlaneWaveExcitations",
    "content": "# API Definition: tenpy.simulations.ground_state_search.PlaneWaveExcitations\nclass PlaneWaveExcitations:\n    \"\"\"Simulation for plane-wave excitations.\"\"\"\n    def __init__(self, options, **kwargs): pass\n    def run(self): pass\n    def resume_run(self): pass\n    def load_groundstate(self):\n        \"\"\"Load ground state and convert to uMPS.\"\"\"\n    def write_back_environments(self, gs_data, gs_fn):\n        \"\"\"Write converged environments back into the file with the ground state.\"\"\"\n    def run_algorithm(self): pass\n    def resume_run_algorithm(self):\n        \"\"\"Not Implemented\"\"\"\n    def prepare_results_for_save(self): pass",
    "search_text": "tenpy.simulations.ground_state_search.planewaveexcitations # api definition: tenpy.simulations.ground_state_search.planewaveexcitations\nclass planewaveexcitations:\n    \"\"\"simulation for plane-wave excitations.\"\"\"\n    def __init__(self, options, **kwargs): pass\n    def run(self): pass\n    def resume_run(self): pass\n    def load_groundstate(self):\n        \"\"\"load ground state and convert to umps.\"\"\"\n    def write_back_environments(self, gs_data, gs_fn):\n        \"\"\"write converged environments back into the file with the ground state.\"\"\"\n    def run_algorithm(self): pass\n    def resume_run_algorithm(self):\n        \"\"\"not implemented\"\"\"\n    def prepare_results_for_save(self): pass class planewaveexcitations tenpy.simulations.ground_state_search",
    "tokens": 138
  },
  {
    "category": "api",
    "name": "tenpy.simulations.ground_state_search.OrthogonalExcitations",
    "content": "# API Definition: tenpy.simulations.ground_state_search.OrthogonalExcitations\nclass OrthogonalExcitations:\n    \"\"\"Find excitations by another GroundStateSearch orthogonalizing against previous states.\"\"\"\n    def __init__(self, options, **kwargs): pass\n    def run(self): pass\n    def resume_run(self): pass\n    def init_orthogonal_from_groundstate(self):\n        \"\"\"Initialize :attr:`orthogonal_to` from the ground state.\"\"\"\n    def extract_segment_from_infinite(self, psi0_inf, model_inf, resume_data):\n        \"\"\"Extract a finite segment from the infinite model/state.\"\"\"\n    def write_converged_environments(self, gs_data, gs_fn):\n        \"\"\"Write converged environments back into the file with the ground state.\"\"\"\n    def init_state(self):\n        \"\"\"Initialize the state.\"\"\"\n    def init_algorithm(self, **kwargs): pass\n    def switch_charge_sector(self):\n        \"\"\"Change the charge sector of :attr:`psi` in place.\"\"\"\n    def run_algorithm(self): pass\n    def resume_run_algorithm(self): pass\n    def prepare_results_for_save(self): pass",
    "search_text": "tenpy.simulations.ground_state_search.orthogonalexcitations # api definition: tenpy.simulations.ground_state_search.orthogonalexcitations\nclass orthogonalexcitations:\n    \"\"\"find excitations by another groundstatesearch orthogonalizing against previous states.\"\"\"\n    def __init__(self, options, **kwargs): pass\n    def run(self): pass\n    def resume_run(self): pass\n    def init_orthogonal_from_groundstate(self):\n        \"\"\"initialize :attr:`orthogonal_to` from the ground state.\"\"\"\n    def extract_segment_from_infinite(self, psi0_inf, model_inf, resume_data):\n        \"\"\"extract a finite segment from the infinite model/state.\"\"\"\n    def write_converged_environments(self, gs_data, gs_fn):\n        \"\"\"write converged environments back into the file with the ground state.\"\"\"\n    def init_state(self):\n        \"\"\"initialize the state.\"\"\"\n    def init_algorithm(self, **kwargs): pass\n    def switch_charge_sector(self):\n        \"\"\"change the charge sector of :attr:`psi` in place.\"\"\"\n    def run_algorithm(self): pass\n    def resume_run_algorithm(self): pass\n    def prepare_results_for_save(self): pass class orthogonalexcitations tenpy.simulations.ground_state_search",
    "tokens": 227
  },
  {
    "category": "api",
    "name": "tenpy.simulations.ground_state_search.TopologicalExcitations",
    "content": "# API Definition: tenpy.simulations.ground_state_search.TopologicalExcitations\nclass TopologicalExcitations:\n    def __init__(self, options, **kwargs): pass\n    def init_from_groundstate(self):\n        \"\"\"Initialize :attr:`orthogonal_to` from the ground state.\"\"\"\n    def extract_segment(self, psi0_alpha_Orig, psi0_beta_Orig, model_orig, resume_data_alpha, resume_data_beta):\n        \"\"\"Extract a finite segment from the original model and states.\"\"\"\n    def correction(self, psi0_alpha, psi0_beta, env_alpha, env_beta, last): pass\n    def arbitrary_shift_left(self, i, psi, LP): pass\n    def arbitrary_shift_right(self, i, psi, RP): pass\n    def get_reference_energy(self, psi0_alpha, psi0_beta):\n        \"\"\"Obtain ground state reference energy.\"\"\"",
    "search_text": "tenpy.simulations.ground_state_search.topologicalexcitations # api definition: tenpy.simulations.ground_state_search.topologicalexcitations\nclass topologicalexcitations:\n    def __init__(self, options, **kwargs): pass\n    def init_from_groundstate(self):\n        \"\"\"initialize :attr:`orthogonal_to` from the ground state.\"\"\"\n    def extract_segment(self, psi0_alpha_orig, psi0_beta_orig, model_orig, resume_data_alpha, resume_data_beta):\n        \"\"\"extract a finite segment from the original model and states.\"\"\"\n    def correction(self, psi0_alpha, psi0_beta, env_alpha, env_beta, last): pass\n    def arbitrary_shift_left(self, i, psi, lp): pass\n    def arbitrary_shift_right(self, i, psi, rp): pass\n    def get_reference_energy(self, psi0_alpha, psi0_beta):\n        \"\"\"obtain ground state reference energy.\"\"\" class topologicalexcitations tenpy.simulations.ground_state_search",
    "tokens": 179
  },
  {
    "category": "api",
    "name": "tenpy.simulations.ground_state_search.ExcitationInitialState",
    "content": "# API Definition: tenpy.simulations.ground_state_search.ExcitationInitialState\nclass ExcitationInitialState:\n    \"\"\"InitialStateBuilder for :class:`OrthogonalExcitations`.\"\"\"\n    def __init__(self, sim, options): pass\n    def from_orthogonal(self): pass",
    "search_text": "tenpy.simulations.ground_state_search.excitationinitialstate # api definition: tenpy.simulations.ground_state_search.excitationinitialstate\nclass excitationinitialstate:\n    \"\"\"initialstatebuilder for :class:`orthogonalexcitations`.\"\"\"\n    def __init__(self, sim, options): pass\n    def from_orthogonal(self): pass class excitationinitialstate tenpy.simulations.ground_state_search",
    "tokens": 57
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.vumps.VUMPSEngine",
    "content": "# API Definition: tenpy.algorithms.vumps.VUMPSEngine\nclass VUMPSEngine:\n    \"\"\"VUMPS base class with common methods for the TwoSiteVUMPS and SingleSiteVUMPS.\"\"\"\n    def __init__(self, psi, model, options, **kwargs): pass\n    def lanczos_options(self):\n        \"\"\"Deprecated alias of :attr:`lanczos_params`.\"\"\"\n    def S_inv_cutoff(self): pass\n    def run_iteration(self):\n        \"\"\"Perform a single iteration, consisting of ``N_sweeps_check`` sweeps.\"\"\"\n    def status_update(self, iteration_start_time: float): pass\n    def is_converged(self):\n        \"\"\"Determines if the algorithm is converged.\"\"\"\n    def post_run_cleanup(self):\n        \"\"\"Perform any final steps or clean up after the main loop has terminated.\"\"\"\n    def mixer_cleanup(self):\n        \"\"\"For uniform MPS there is no need to clean up after the mixer.\"\"\"\n    def run(self):\n        \"\"\"Run the VUMPS simulation to find the ground state.\"\"\"\n    def environment_sweeps(self, N_sweeps):\n        \"\"\"In VUMPS we don't want to do this as we regenerate the environment each time we do an update.\"\"\"\n    def reset_stats(self, resume_data=None):\n        \"\"\"Reset the statistics, useful if you want to start a new sweep run.\"\"\"\n    def get_sweep_schedule(self):\n        \"\"\"Sweep from site 0 to L-1\"\"\"\n    def prepare_update_local(self):\n        \"\"\"For each update, we need to rebuild the environments from scratch using the most recent tensors\"\"\"\n    def make_eff_H(self):\n        \"\"\"Create new instance of `self.EffectiveH` at `self.i0`.\"\"\"\n    def post_update_local(self, e_L, e_R, eps_L, eps_R, e_C1, e_C2, e_theta, N0_L, N0_R, N1, **update_data):\n        \"\"\"Perform post-update actions.\"\"\"\n    def free_no_longer_needed_envs(self): pass\n    def resume_run(self): pass\n    def tangent_projector_test(self, env_data):\n        \"\"\"The ground state projector P_GS\"\"\"",
    "search_text": "tenpy.algorithms.vumps.vumpsengine # api definition: tenpy.algorithms.vumps.vumpsengine\nclass vumpsengine:\n    \"\"\"vumps base class with common methods for the twositevumps and singlesitevumps.\"\"\"\n    def __init__(self, psi, model, options, **kwargs): pass\n    def lanczos_options(self):\n        \"\"\"deprecated alias of :attr:`lanczos_params`.\"\"\"\n    def s_inv_cutoff(self): pass\n    def run_iteration(self):\n        \"\"\"perform a single iteration, consisting of ``n_sweeps_check`` sweeps.\"\"\"\n    def status_update(self, iteration_start_time: float): pass\n    def is_converged(self):\n        \"\"\"determines if the algorithm is converged.\"\"\"\n    def post_run_cleanup(self):\n        \"\"\"perform any final steps or clean up after the main loop has terminated.\"\"\"\n    def mixer_cleanup(self):\n        \"\"\"for uniform mps there is no need to clean up after the mixer.\"\"\"\n    def run(self):\n        \"\"\"run the vumps simulation to find the ground state.\"\"\"\n    def environment_sweeps(self, n_sweeps):\n        \"\"\"in vumps we don't want to do this as we regenerate the environment each time we do an update.\"\"\"\n    def reset_stats(self, resume_data=none):\n        \"\"\"reset the statistics, useful if you want to start a new sweep run.\"\"\"\n    def get_sweep_schedule(self):\n        \"\"\"sweep from site 0 to l-1\"\"\"\n    def prepare_update_local(self):\n        \"\"\"for each update, we need to rebuild the environments from scratch using the most recent tensors\"\"\"\n    def make_eff_h(self):\n        \"\"\"create new instance of `self.effectiveh` at `self.i0`.\"\"\"\n    def post_update_local(self, e_l, e_r, eps_l, eps_r, e_c1, e_c2, e_theta, n0_l, n0_r, n1, **update_data):\n        \"\"\"perform post-update actions.\"\"\"\n    def free_no_longer_needed_envs(self): pass\n    def resume_run(self): pass\n    def tangent_projector_test(self, env_data):\n        \"\"\"the ground state projector p_gs\"\"\" class vumpsengine tenpy.algorithms.vumps",
    "tokens": 446
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.vumps.SingleSiteVUMPSEngine",
    "content": "# API Definition: tenpy.algorithms.vumps.SingleSiteVUMPSEngine\nclass SingleSiteVUMPSEngine:\n    \"\"\"Engine for the single-site VUMPS algorithm.\"\"\"\n    def __init__(self, psi, model, options, **kwargs): pass\n    def update_env(self, **update_data): pass\n    def update_local(self, theta, **kwargs):\n        \"\"\"Perform single-site update on the site ``i0``.\"\"\"\n    def polar_max(self, AC, C1, C2):\n        \"\"\"Polar decompositions: Given AC and C, find AL and AR such that AL C = AC = C AR\"\"\"",
    "search_text": "tenpy.algorithms.vumps.singlesitevumpsengine # api definition: tenpy.algorithms.vumps.singlesitevumpsengine\nclass singlesitevumpsengine:\n    \"\"\"engine for the single-site vumps algorithm.\"\"\"\n    def __init__(self, psi, model, options, **kwargs): pass\n    def update_env(self, **update_data): pass\n    def update_local(self, theta, **kwargs):\n        \"\"\"perform single-site update on the site ``i0``.\"\"\"\n    def polar_max(self, ac, c1, c2):\n        \"\"\"polar decompositions: given ac and c, find al and ar such that al c = ac = c ar\"\"\" class singlesitevumpsengine tenpy.algorithms.vumps",
    "tokens": 132
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.vumps.TwoSiteVUMPSEngine",
    "content": "# API Definition: tenpy.algorithms.vumps.TwoSiteVUMPSEngine\nclass TwoSiteVUMPSEngine:\n    \"\"\"Engine for the two-site VUMPS algorithm.\"\"\"\n    def __init__(self, psi, model, options, **kwargs): pass\n    def update_env(self, **update_data): pass\n    def update_local(self, theta, **kwargs):\n        \"\"\"Perform two-site update on the site ``i0`` and ``i0+1``.\"\"\"\n    def polar_max(self, AC1, AC2, C1, C3):\n        \"\"\"Polar decompositions on two sites\"\"\"\n    def mixed_svd(self, theta):\n        \"\"\"Get (truncated) `B` from the new theta (as returned by diag).\"\"\"",
    "search_text": "tenpy.algorithms.vumps.twositevumpsengine # api definition: tenpy.algorithms.vumps.twositevumpsengine\nclass twositevumpsengine:\n    \"\"\"engine for the two-site vumps algorithm.\"\"\"\n    def __init__(self, psi, model, options, **kwargs): pass\n    def update_env(self, **update_data): pass\n    def update_local(self, theta, **kwargs):\n        \"\"\"perform two-site update on the site ``i0`` and ``i0+1``.\"\"\"\n    def polar_max(self, ac1, ac2, c1, c3):\n        \"\"\"polar decompositions on two sites\"\"\"\n    def mixed_svd(self, theta):\n        \"\"\"get (truncated) `b` from the new theta (as returned by diag).\"\"\" class twositevumpsengine tenpy.algorithms.vumps",
    "tokens": 158
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.disentangler.Disentangler",
    "content": "# API Definition: tenpy.algorithms.disentangler.Disentangler\nclass Disentangler:\n    \"\"\"Prototype for a disentangler. Trivial, does nothing.\"\"\"\n    def __init__(self, parent): pass",
    "search_text": "tenpy.algorithms.disentangler.disentangler # api definition: tenpy.algorithms.disentangler.disentangler\nclass disentangler:\n    \"\"\"prototype for a disentangler. trivial, does nothing.\"\"\"\n    def __init__(self, parent): pass class disentangler tenpy.algorithms.disentangler",
    "tokens": 45
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.disentangler.BackwardDisentangler",
    "content": "# API Definition: tenpy.algorithms.disentangler.BackwardDisentangler\nclass BackwardDisentangler:\n    \"\"\"Disentangle with backward time evolution.\"\"\"\n    def __init__(self, parent): pass",
    "search_text": "tenpy.algorithms.disentangler.backwarddisentangler # api definition: tenpy.algorithms.disentangler.backwarddisentangler\nclass backwarddisentangler:\n    \"\"\"disentangle with backward time evolution.\"\"\"\n    def __init__(self, parent): pass class backwarddisentangler tenpy.algorithms.disentangler",
    "tokens": 44
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.disentangler.RenyiDisentangler",
    "content": "# API Definition: tenpy.algorithms.disentangler.RenyiDisentangler\nclass RenyiDisentangler:\n    \"\"\"Iteratively find `U` which minimized the second Renyi entropy.\"\"\"\n    def __init__(self, parent): pass\n    def iter(self, theta, U):\n        \"\"\"Given `theta` and `U`, find another `U` which reduces the 2nd Renyi entropy.\"\"\"",
    "search_text": "tenpy.algorithms.disentangler.renyidisentangler # api definition: tenpy.algorithms.disentangler.renyidisentangler\nclass renyidisentangler:\n    \"\"\"iteratively find `u` which minimized the second renyi entropy.\"\"\"\n    def __init__(self, parent): pass\n    def iter(self, theta, u):\n        \"\"\"given `theta` and `u`, find another `u` which reduces the 2nd renyi entropy.\"\"\" class renyidisentangler tenpy.algorithms.disentangler",
    "tokens": 86
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.disentangler.NormDisentangler",
    "content": "# API Definition: tenpy.algorithms.disentangler.NormDisentangler\nclass NormDisentangler:\n    \"\"\"Disentangle with the unitary that maximizes overlap with the truncated ``U|theta>``.\"\"\"\n    def __init__(self, parent): pass\n    def iter(self, theta, U, trunc_params):\n        \"\"\"Given `theta` and `U`, find `U2` maximizing ``<theta|U2 truncate(U |theta>)``.\"\"\"",
    "search_text": "tenpy.algorithms.disentangler.normdisentangler # api definition: tenpy.algorithms.disentangler.normdisentangler\nclass normdisentangler:\n    \"\"\"disentangle with the unitary that maximizes overlap with the truncated ``u|theta>``.\"\"\"\n    def __init__(self, parent): pass\n    def iter(self, theta, u, trunc_params):\n        \"\"\"given `theta` and `u`, find `u2` maximizing ``<theta|u2 truncate(u |theta>)``.\"\"\" class normdisentangler tenpy.algorithms.disentangler",
    "tokens": 98
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.disentangler.GradientDescentDisentangler",
    "content": "# API Definition: tenpy.algorithms.disentangler.GradientDescentDisentangler\nclass GradientDescentDisentangler:\n    \"\"\"Gradient-descent optimization, similar to :class:`RenyiDisentangler`.\"\"\"\n    def __init__(self, parent): pass\n    def iter(self, theta):\n        \"\"\"Given `theta`, find a unitary `U` towards minimizing the n-th Renyi entropy.\"\"\"",
    "search_text": "tenpy.algorithms.disentangler.gradientdescentdisentangler # api definition: tenpy.algorithms.disentangler.gradientdescentdisentangler\nclass gradientdescentdisentangler:\n    \"\"\"gradient-descent optimization, similar to :class:`renyidisentangler`.\"\"\"\n    def __init__(self, parent): pass\n    def iter(self, theta):\n        \"\"\"given `theta`, find a unitary `u` towards minimizing the n-th renyi entropy.\"\"\" class gradientdescentdisentangler tenpy.algorithms.disentangler",
    "tokens": 86
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.disentangler.NoiseDisentangler",
    "content": "# API Definition: tenpy.algorithms.disentangler.NoiseDisentangler\nclass NoiseDisentangler:\n    \"\"\"Disentangle with tunable noise, i.e. with random unitary close to identity.\"\"\"\n    def __init__(self, parent): pass",
    "search_text": "tenpy.algorithms.disentangler.noisedisentangler # api definition: tenpy.algorithms.disentangler.noisedisentangler\nclass noisedisentangler:\n    \"\"\"disentangle with tunable noise, i.e. with random unitary close to identity.\"\"\"\n    def __init__(self, parent): pass class noisedisentangler tenpy.algorithms.disentangler",
    "tokens": 54
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.disentangler.LastDisentangler",
    "content": "# API Definition: tenpy.algorithms.disentangler.LastDisentangler\nclass LastDisentangler:\n    \"\"\"Disentangle using the same unitary that was used the last time at that bond.\"\"\"\n",
    "search_text": "tenpy.algorithms.disentangler.lastdisentangler # api definition: tenpy.algorithms.disentangler.lastdisentangler\nclass lastdisentangler:\n    \"\"\"disentangle using the same unitary that was used the last time at that bond.\"\"\"\n class lastdisentangler tenpy.algorithms.disentangler",
    "tokens": 42
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.disentangler.DiagonalizeDisentangler",
    "content": "# API Definition: tenpy.algorithms.disentangler.DiagonalizeDisentangler\nclass DiagonalizeDisentangler:\n    \"\"\"Disentangle by diagonalizing the two-site density matrix in the auxiliary space.\"\"\"\n",
    "search_text": "tenpy.algorithms.disentangler.diagonalizedisentangler # api definition: tenpy.algorithms.disentangler.diagonalizedisentangler\nclass diagonalizedisentangler:\n    \"\"\"disentangle by diagonalizing the two-site density matrix in the auxiliary space.\"\"\"\n class diagonalizedisentangler tenpy.algorithms.disentangler",
    "tokens": 44
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.disentangler.CompositeDisentangler",
    "content": "# API Definition: tenpy.algorithms.disentangler.CompositeDisentangler\nclass CompositeDisentangler:\n    \"\"\"Concatenate multiple disentanglers.\"\"\"\n    def __init__(self, disentanglers): pass",
    "search_text": "tenpy.algorithms.disentangler.compositedisentangler # api definition: tenpy.algorithms.disentangler.compositedisentangler\nclass compositedisentangler:\n    \"\"\"concatenate multiple disentanglers.\"\"\"\n    def __init__(self, disentanglers): pass class compositedisentangler tenpy.algorithms.disentangler",
    "tokens": 46
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.disentangler.MinDisentangler",
    "content": "# API Definition: tenpy.algorithms.disentangler.MinDisentangler\nclass MinDisentangler:\n    \"\"\"Chose the disentangler giving the smallest entropy.\"\"\"\n    def __init__(self, disentanglers, parent): pass",
    "search_text": "tenpy.algorithms.disentangler.mindisentangler # api definition: tenpy.algorithms.disentangler.mindisentangler\nclass mindisentangler:\n    \"\"\"chose the disentangler giving the smallest entropy.\"\"\"\n    def __init__(self, disentanglers, parent): pass class mindisentangler tenpy.algorithms.disentangler",
    "tokens": 50
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.disentangler.get_disentangler",
    "content": "# API Function: tenpy.algorithms.disentangler.get_disentangler\ndef get_disentangler(method, parent):\n    \"\"\"Parse the parameter `method` and construct a :class:`Disentangler` instance.\"\"\"",
    "search_text": "tenpy.algorithms.disentangler.get_disentangler # api function: tenpy.algorithms.disentangler.get_disentangler\ndef get_disentangler(method, parent):\n    \"\"\"parse the parameter `method` and construct a :class:`disentangler` instance.\"\"\" function get_disentangler",
    "tokens": 45
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.mps_common.Sweep",
    "content": "# API Definition: tenpy.algorithms.mps_common.Sweep\nclass Sweep:\n    \"\"\"Prototype class for a 'sweeping' algorithm.\"\"\"\n    def __init__(self, psi, model, options, **kwargs): pass\n    def S_inv_cutoff(self): pass\n    def get_resume_data(self, sequential_simulations=False): pass\n    def n_optimize(self):\n        \"\"\"The number of sites to be optimized at once.\"\"\"\n    def init_env(self, model=None, resume_data=None, orthogonal_to=None):\n        \"\"\"(Re-)initialize the environment.\"\"\"\n    def reset_stats(self, resume_data=None):\n        \"\"\"Reset the statistics. Useful if you want to start a new Sweep run.\"\"\"\n    def environment_sweeps(self, N_sweeps):\n        \"\"\"Perform `N_sweeps` sweeps without optimization to update the environment.\"\"\"\n    def sweep(self, optimize=True):\n        \"\"\"One 'sweep' of a sweeper algorithm.\"\"\"\n    def get_sweep_schedule(self):\n        \"\"\"Define the schedule of the sweep.\"\"\"\n    def prepare_update_local(self):\n        \"\"\"Prepare `self` for calling :meth:`update_local`.\"\"\"\n    def make_eff_H(self):\n        \"\"\"Create new instance of `self.EffectiveH` at `self.i0` and set it to `self.eff_H`.\"\"\"\n    def update_local(self, theta, **kwargs):\n        \"\"\"Perform algorithm-specific local update.\"\"\"\n    def update_env(self, **update_data):\n        \"\"\"Update the left and right environments after an update of the state.\"\"\"\n    def post_update_local(self, err, **update_data):\n        \"\"\"Algorithm-specific actions to be taken after local update.\"\"\"\n    def free_no_longer_needed_envs(self):\n        \"\"\"Remove no longer needed environments after an update.\"\"\"\n    def mixer_activate(self):\n        \"\"\"Set `self.mixer` to the class specified by `options['mixer']`.\"\"\"\n    def mixer_deactivate(self):\n        \"\"\"Deactivate the mixer.\"\"\"\n    def mixer_cleanup(self):\n        \"\"\"Cleanup the effects of a mixer.\"\"\"",
    "search_text": "tenpy.algorithms.mps_common.sweep # api definition: tenpy.algorithms.mps_common.sweep\nclass sweep:\n    \"\"\"prototype class for a 'sweeping' algorithm.\"\"\"\n    def __init__(self, psi, model, options, **kwargs): pass\n    def s_inv_cutoff(self): pass\n    def get_resume_data(self, sequential_simulations=false): pass\n    def n_optimize(self):\n        \"\"\"the number of sites to be optimized at once.\"\"\"\n    def init_env(self, model=none, resume_data=none, orthogonal_to=none):\n        \"\"\"(re-)initialize the environment.\"\"\"\n    def reset_stats(self, resume_data=none):\n        \"\"\"reset the statistics. useful if you want to start a new sweep run.\"\"\"\n    def environment_sweeps(self, n_sweeps):\n        \"\"\"perform `n_sweeps` sweeps without optimization to update the environment.\"\"\"\n    def sweep(self, optimize=true):\n        \"\"\"one 'sweep' of a sweeper algorithm.\"\"\"\n    def get_sweep_schedule(self):\n        \"\"\"define the schedule of the sweep.\"\"\"\n    def prepare_update_local(self):\n        \"\"\"prepare `self` for calling :meth:`update_local`.\"\"\"\n    def make_eff_h(self):\n        \"\"\"create new instance of `self.effectiveh` at `self.i0` and set it to `self.eff_h`.\"\"\"\n    def update_local(self, theta, **kwargs):\n        \"\"\"perform algorithm-specific local update.\"\"\"\n    def update_env(self, **update_data):\n        \"\"\"update the left and right environments after an update of the state.\"\"\"\n    def post_update_local(self, err, **update_data):\n        \"\"\"algorithm-specific actions to be taken after local update.\"\"\"\n    def free_no_longer_needed_envs(self):\n        \"\"\"remove no longer needed environments after an update.\"\"\"\n    def mixer_activate(self):\n        \"\"\"set `self.mixer` to the class specified by `options['mixer']`.\"\"\"\n    def mixer_deactivate(self):\n        \"\"\"deactivate the mixer.\"\"\"\n    def mixer_cleanup(self):\n        \"\"\"cleanup the effects of a mixer.\"\"\" class sweep tenpy.algorithms.mps_common",
    "tokens": 415
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.mps_common.IterativeSweeps",
    "content": "# API Definition: tenpy.algorithms.mps_common.IterativeSweeps\nclass IterativeSweeps:\n    \"\"\"Prototype class for algorithms that iterate the same sweep until convergence.\"\"\"\n    def run(self): pass\n    def pre_run_initialize(self):\n        \"\"\"Perform preparations before :meth:`run_iteration` is iterated.\"\"\"\n    def run_iteration(self):\n        \"\"\"Perform a single iteration.\"\"\"\n    def status_update(self, iteration_start_time: float):\n        \"\"\"Emits a status message to the logging system after an iteration.\"\"\"\n    def stopping_criterion(self, iteration_start_time: float):\n        \"\"\"Determines if the main loop should be terminated.\"\"\"\n    def is_converged(self):\n        \"\"\"Determines if the algorithm is converged.\"\"\"\n    def post_run_cleanup(self):\n        \"\"\"Perform any final steps or clean up after the main loop has terminated.\"\"\"",
    "search_text": "tenpy.algorithms.mps_common.iterativesweeps # api definition: tenpy.algorithms.mps_common.iterativesweeps\nclass iterativesweeps:\n    \"\"\"prototype class for algorithms that iterate the same sweep until convergence.\"\"\"\n    def run(self): pass\n    def pre_run_initialize(self):\n        \"\"\"perform preparations before :meth:`run_iteration` is iterated.\"\"\"\n    def run_iteration(self):\n        \"\"\"perform a single iteration.\"\"\"\n    def status_update(self, iteration_start_time: float):\n        \"\"\"emits a status message to the logging system after an iteration.\"\"\"\n    def stopping_criterion(self, iteration_start_time: float):\n        \"\"\"determines if the main loop should be terminated.\"\"\"\n    def is_converged(self):\n        \"\"\"determines if the algorithm is converged.\"\"\"\n    def post_run_cleanup(self):\n        \"\"\"perform any final steps or clean up after the main loop has terminated.\"\"\" class iterativesweeps tenpy.algorithms.mps_common",
    "tokens": 173
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.mps_common.EffectiveH",
    "content": "# API Definition: tenpy.algorithms.mps_common.EffectiveH\nclass EffectiveH:\n    \"\"\"Prototype class for local effective Hamiltonians used in sweep algorithms.\"\"\"\n    def __init__(self, env, i0, combine=False, move_right=True): pass\n    def combine_theta(self, theta):\n        \"\"\"Combine the legs of `theta`, such that it fits to how we combined the legs of `self`.\"\"\"\n    def update_LP(self, env, i, U=None):\n        \"\"\"Equivalent to ``env.get_LP(i, store=True)``; optimized for `combine`.\"\"\"\n    def update_RP(self, env, i, VH=None):\n        \"\"\"Equivalent to ``env.get_RP(i, store=True)``; optimized for `combine`.\"\"\"",
    "search_text": "tenpy.algorithms.mps_common.effectiveh # api definition: tenpy.algorithms.mps_common.effectiveh\nclass effectiveh:\n    \"\"\"prototype class for local effective hamiltonians used in sweep algorithms.\"\"\"\n    def __init__(self, env, i0, combine=false, move_right=true): pass\n    def combine_theta(self, theta):\n        \"\"\"combine the legs of `theta`, such that it fits to how we combined the legs of `self`.\"\"\"\n    def update_lp(self, env, i, u=none):\n        \"\"\"equivalent to ``env.get_lp(i, store=true)``; optimized for `combine`.\"\"\"\n    def update_rp(self, env, i, vh=none):\n        \"\"\"equivalent to ``env.get_rp(i, store=true)``; optimized for `combine`.\"\"\" class effectiveh tenpy.algorithms.mps_common",
    "tokens": 156
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.mps_common.OneSiteH",
    "content": "# API Definition: tenpy.algorithms.mps_common.OneSiteH\nclass OneSiteH:\n    \"\"\"Class defining the one-site effective Hamiltonian for Lanczos.\"\"\"\n    def __init__(self, env, i0, combine=False, move_right=True): pass\n    def from_LP_W0_RP(cls, LP, W0, RP, i0=0, combine=False, move_right=True): pass\n    def matvec(self, theta):\n        \"\"\"Apply the effective Hamiltonian to `theta`.\"\"\"\n    def combine_Heff(self, env):\n        \"\"\"Combine LP and RP with W to form LHeff and RHeff, depending on the direction.\"\"\"\n    def combine_theta(self, theta):\n        \"\"\"Combine the legs of `theta`, such that it fits to how we combined the legs of `self`.\"\"\"\n    def to_matrix(self):\n        \"\"\"Contract `self` to a matrix.\"\"\"\n    def adjoint(self):\n        \"\"\"Return the hermitian conjugate of `self`.\"\"\"\n    def update_LP(self, env, i, U=None): pass\n    def update_RP(self, env, i, VH=None): pass",
    "search_text": "tenpy.algorithms.mps_common.onesiteh # api definition: tenpy.algorithms.mps_common.onesiteh\nclass onesiteh:\n    \"\"\"class defining the one-site effective hamiltonian for lanczos.\"\"\"\n    def __init__(self, env, i0, combine=false, move_right=true): pass\n    def from_lp_w0_rp(cls, lp, w0, rp, i0=0, combine=false, move_right=true): pass\n    def matvec(self, theta):\n        \"\"\"apply the effective hamiltonian to `theta`.\"\"\"\n    def combine_heff(self, env):\n        \"\"\"combine lp and rp with w to form lheff and rheff, depending on the direction.\"\"\"\n    def combine_theta(self, theta):\n        \"\"\"combine the legs of `theta`, such that it fits to how we combined the legs of `self`.\"\"\"\n    def to_matrix(self):\n        \"\"\"contract `self` to a matrix.\"\"\"\n    def adjoint(self):\n        \"\"\"return the hermitian conjugate of `self`.\"\"\"\n    def update_lp(self, env, i, u=none): pass\n    def update_rp(self, env, i, vh=none): pass class onesiteh tenpy.algorithms.mps_common",
    "tokens": 237
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.mps_common.TwoSiteH",
    "content": "# API Definition: tenpy.algorithms.mps_common.TwoSiteH\nclass TwoSiteH:\n    \"\"\"Class defining the two-site effective Hamiltonian for Lanczos.\"\"\"\n    def __init__(self, env, i0, combine=False, move_right=True): pass\n    def matvec(self, theta):\n        \"\"\"Apply the effective Hamiltonian to `theta`.\"\"\"\n    def combine_Heff(self, env, left=True, right=True):\n        \"\"\"Combine LP and RP with W to form LHeff and RHeff.\"\"\"\n    def combine_theta(self, theta):\n        \"\"\"Combine the legs of `theta`, such that it fits to how we combined the legs of `self`.\"\"\"\n    def to_matrix(self):\n        \"\"\"Contract `self` to a matrix.\"\"\"\n    def adjoint(self):\n        \"\"\"Return the hermitian conjugate of `self`.\"\"\"\n    def update_LP(self, env, i, U=None): pass\n    def update_RP(self, env, i, VH=None): pass",
    "search_text": "tenpy.algorithms.mps_common.twositeh # api definition: tenpy.algorithms.mps_common.twositeh\nclass twositeh:\n    \"\"\"class defining the two-site effective hamiltonian for lanczos.\"\"\"\n    def __init__(self, env, i0, combine=false, move_right=true): pass\n    def matvec(self, theta):\n        \"\"\"apply the effective hamiltonian to `theta`.\"\"\"\n    def combine_heff(self, env, left=true, right=true):\n        \"\"\"combine lp and rp with w to form lheff and rheff.\"\"\"\n    def combine_theta(self, theta):\n        \"\"\"combine the legs of `theta`, such that it fits to how we combined the legs of `self`.\"\"\"\n    def to_matrix(self):\n        \"\"\"contract `self` to a matrix.\"\"\"\n    def adjoint(self):\n        \"\"\"return the hermitian conjugate of `self`.\"\"\"\n    def update_lp(self, env, i, u=none): pass\n    def update_rp(self, env, i, vh=none): pass class twositeh tenpy.algorithms.mps_common",
    "tokens": 208
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.mps_common.ZeroSiteH",
    "content": "# API Definition: tenpy.algorithms.mps_common.ZeroSiteH\nclass ZeroSiteH:\n    \"\"\"Class defining the zero-site effective Hamiltonian for Lanczos.\"\"\"\n    def __init__(self, env, i0): pass\n    def from_LP_RP(cls, LP, RP, i0=0): pass\n    def matvec(self, theta):\n        \"\"\"Apply the effective Hamiltonian to `theta`.\"\"\"\n    def to_matrix(self):\n        \"\"\"Contract `self` to a matrix.\"\"\"\n    def adjoint(self):\n        \"\"\"Return the hermitian conjugate of `self`.\"\"\"",
    "search_text": "tenpy.algorithms.mps_common.zerositeh # api definition: tenpy.algorithms.mps_common.zerositeh\nclass zerositeh:\n    \"\"\"class defining the zero-site effective hamiltonian for lanczos.\"\"\"\n    def __init__(self, env, i0): pass\n    def from_lp_rp(cls, lp, rp, i0=0): pass\n    def matvec(self, theta):\n        \"\"\"apply the effective hamiltonian to `theta`.\"\"\"\n    def to_matrix(self):\n        \"\"\"contract `self` to a matrix.\"\"\"\n    def adjoint(self):\n        \"\"\"return the hermitian conjugate of `self`.\"\"\" class zerositeh tenpy.algorithms.mps_common",
    "tokens": 123
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.mps_common.DummyTwoSiteH",
    "content": "# API Definition: tenpy.algorithms.mps_common.DummyTwoSiteH\nclass DummyTwoSiteH:\n    \"\"\"A dummy replacement for :meth:`TwoSiteH` with similar methods but no actual MPO.\"\"\"\n    def __init__(self, *args, **kwargs): pass\n    def combine_theta(self, theta): pass",
    "search_text": "tenpy.algorithms.mps_common.dummytwositeh # api definition: tenpy.algorithms.mps_common.dummytwositeh\nclass dummytwositeh:\n    \"\"\"a dummy replacement for :meth:`twositeh` with similar methods but no actual mpo.\"\"\"\n    def __init__(self, *args, **kwargs): pass\n    def combine_theta(self, theta): pass class dummytwositeh tenpy.algorithms.mps_common",
    "tokens": 69
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.mps_common.Mixer",
    "content": "# API Definition: tenpy.algorithms.mps_common.Mixer\nclass Mixer:\n    \"\"\"Base class for a general Mixer.\"\"\"\n    def __init__(self, options, sweep_activated=0): pass\n    def update_amplitude(self, sweeps):\n        \"\"\"Update the amplitude, possibly disable the mixer.\"\"\"\n    def mixed_svd_2site(self, engine: Sweep, theta: npc.Array, i0: int, mix_left: bool, mix_right: bool, qtotal_LR=[None, None]):\n        \"\"\"Mix and SVD-like decompose a two-site wavefunction.\"\"\"\n    def mix_and_decompose_1site(self, engine: Sweep, theta: npc.Array, i0: int, move_right: bool):\n        \"\"\"Decompose single-site wavefunction and expand/mix an adjacent bond.\"\"\"\n    def mix_and_decompose_2site(self, engine: Sweep, theta: npc.Array, i0: int, mix_left: bool, mix_right: bool, qtotal_LR=None):\n        \"\"\"Decompose two-site wavefunction and expand/mix enclosed bond(s).\"\"\"\n    def determine_qtotal_L_R(theta_qtotal, qtotal_LR):\n        \"\"\"Figure out ``qtotal_L, qtotal_R`` such that ``qtotal_L + qtotal_R == theta_qtotal``.\"\"\"",
    "search_text": "tenpy.algorithms.mps_common.mixer # api definition: tenpy.algorithms.mps_common.mixer\nclass mixer:\n    \"\"\"base class for a general mixer.\"\"\"\n    def __init__(self, options, sweep_activated=0): pass\n    def update_amplitude(self, sweeps):\n        \"\"\"update the amplitude, possibly disable the mixer.\"\"\"\n    def mixed_svd_2site(self, engine: sweep, theta: npc.array, i0: int, mix_left: bool, mix_right: bool, qtotal_lr=[none, none]):\n        \"\"\"mix and svd-like decompose a two-site wavefunction.\"\"\"\n    def mix_and_decompose_1site(self, engine: sweep, theta: npc.array, i0: int, move_right: bool):\n        \"\"\"decompose single-site wavefunction and expand/mix an adjacent bond.\"\"\"\n    def mix_and_decompose_2site(self, engine: sweep, theta: npc.array, i0: int, mix_left: bool, mix_right: bool, qtotal_lr=none):\n        \"\"\"decompose two-site wavefunction and expand/mix enclosed bond(s).\"\"\"\n    def determine_qtotal_l_r(theta_qtotal, qtotal_lr):\n        \"\"\"figure out ``qtotal_l, qtotal_r`` such that ``qtotal_l + qtotal_r == theta_qtotal``.\"\"\" class mixer tenpy.algorithms.mps_common",
    "tokens": 269
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.mps_common.DensityMatrixMixer",
    "content": "# API Definition: tenpy.algorithms.mps_common.DensityMatrixMixer\nclass DensityMatrixMixer:\n    \"\"\"Mixer based on reduced density matrices.\"\"\"\n    def __init__(self, options, sweep_activated=0): pass\n    def mixed_svd_2site(self, engine: Sweep, theta: npc.Array, i0: int, mix_left: bool, mix_right: bool, qtotal_LR=[None, None]): pass\n    def mix_rho(self, engine: Sweep, theta: npc.Array, i0: int, mix_left: bool, mix_right: bool):\n        \"\"\"Calculate the (possibly mixed) reduced density matrices.\"\"\"\n    def svd_from_rho(self, engine: Sweep, rho_L: npc.Array, rho_R: npc.Array, theta: npc.Array, qtotal_LR):\n        \"\"\"Diagonalize ``rho_L, rho_R`` to rewrite `theta` as ``U S V`` with isometric U/V.\"\"\"",
    "search_text": "tenpy.algorithms.mps_common.densitymatrixmixer # api definition: tenpy.algorithms.mps_common.densitymatrixmixer\nclass densitymatrixmixer:\n    \"\"\"mixer based on reduced density matrices.\"\"\"\n    def __init__(self, options, sweep_activated=0): pass\n    def mixed_svd_2site(self, engine: sweep, theta: npc.array, i0: int, mix_left: bool, mix_right: bool, qtotal_lr=[none, none]): pass\n    def mix_rho(self, engine: sweep, theta: npc.array, i0: int, mix_left: bool, mix_right: bool):\n        \"\"\"calculate the (possibly mixed) reduced density matrices.\"\"\"\n    def svd_from_rho(self, engine: sweep, rho_l: npc.array, rho_r: npc.array, theta: npc.array, qtotal_lr):\n        \"\"\"diagonalize ``rho_l, rho_r`` to rewrite `theta` as ``u s v`` with isometric u/v.\"\"\" class densitymatrixmixer tenpy.algorithms.mps_common",
    "tokens": 198
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.mps_common.SubspaceExpansion",
    "content": "# API Definition: tenpy.algorithms.mps_common.SubspaceExpansion\nclass SubspaceExpansion:\n    \"\"\"Mixer of a direct subspace expansion.\"\"\"\n    def __init__(self, options, sweep_activated=0): pass\n    def mix_and_decompose_1site(self, engine: Sweep, theta: npc.Array, i0: int, move_right: bool): pass",
    "search_text": "tenpy.algorithms.mps_common.subspaceexpansion # api definition: tenpy.algorithms.mps_common.subspaceexpansion\nclass subspaceexpansion:\n    \"\"\"mixer of a direct subspace expansion.\"\"\"\n    def __init__(self, options, sweep_activated=0): pass\n    def mix_and_decompose_1site(self, engine: sweep, theta: npc.array, i0: int, move_right: bool): pass class subspaceexpansion tenpy.algorithms.mps_common",
    "tokens": 79
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.mps_common.VariationalCompression",
    "content": "# API Definition: tenpy.algorithms.mps_common.VariationalCompression\nclass VariationalCompression:\n    \"\"\"Variational compression of an MPS (in place).\"\"\"\n    def __init__(self, psi, options, resume_data=None): pass\n    def pre_run_initialize(self): pass\n    def run_iteration(self): pass\n    def is_converged(self): pass\n    def post_run_cleanup(self): pass\n    def run(self):\n        \"\"\"Run the compression.\"\"\"\n    def init_env(self, model=None, resume_data=None, orthogonal_to=None):\n        \"\"\"Initialize the environment.\"\"\"\n    def get_sweep_schedule(self):\n        \"\"\"Define the schedule of the sweep.\"\"\"\n    def update_local(self, _, optimize=True):\n        \"\"\"Perform local update.\"\"\"\n    def update_new_psi(self, theta):\n        \"\"\"Given a new two-site wave function `theta`, split it and save it in :attr:`psi`.\"\"\"",
    "search_text": "tenpy.algorithms.mps_common.variationalcompression # api definition: tenpy.algorithms.mps_common.variationalcompression\nclass variationalcompression:\n    \"\"\"variational compression of an mps (in place).\"\"\"\n    def __init__(self, psi, options, resume_data=none): pass\n    def pre_run_initialize(self): pass\n    def run_iteration(self): pass\n    def is_converged(self): pass\n    def post_run_cleanup(self): pass\n    def run(self):\n        \"\"\"run the compression.\"\"\"\n    def init_env(self, model=none, resume_data=none, orthogonal_to=none):\n        \"\"\"initialize the environment.\"\"\"\n    def get_sweep_schedule(self):\n        \"\"\"define the schedule of the sweep.\"\"\"\n    def update_local(self, _, optimize=true):\n        \"\"\"perform local update.\"\"\"\n    def update_new_psi(self, theta):\n        \"\"\"given a new two-site wave function `theta`, split it and save it in :attr:`psi`.\"\"\" class variationalcompression tenpy.algorithms.mps_common",
    "tokens": 188
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.mps_common.VariationalApplyMPO",
    "content": "# API Definition: tenpy.algorithms.mps_common.VariationalApplyMPO\nclass VariationalApplyMPO:\n    \"\"\"Variational compression for applying an MPO to an MPS (in place).\"\"\"\n    def __init__(self, psi, U_MPO, options, **kwargs): pass\n    def init_env(self, U_MPO, resume_data=None, orthogonal_to=None):\n        \"\"\"Initialize the environment.\"\"\"\n    def update_local(self, _, optimize=True):\n        \"\"\"Perform local update.\"\"\"",
    "search_text": "tenpy.algorithms.mps_common.variationalapplympo # api definition: tenpy.algorithms.mps_common.variationalapplympo\nclass variationalapplympo:\n    \"\"\"variational compression for applying an mpo to an mps (in place).\"\"\"\n    def __init__(self, psi, u_mpo, options, **kwargs): pass\n    def init_env(self, u_mpo, resume_data=none, orthogonal_to=none):\n        \"\"\"initialize the environment.\"\"\"\n    def update_local(self, _, optimize=true):\n        \"\"\"perform local update.\"\"\" class variationalapplympo tenpy.algorithms.mps_common",
    "tokens": 103
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.mps_common.QRBasedVariationalApplyMPO",
    "content": "# API Definition: tenpy.algorithms.mps_common.QRBasedVariationalApplyMPO\nclass QRBasedVariationalApplyMPO:\n    \"\"\"Variational MPO application, using QR-based decompositions instead of SVD.\"\"\"\n    def update_new_psi(self, theta: npc.Array):\n        \"\"\"Given a new two-site wave function `theta`, split it and save it in :attr:`psi`.\"\"\"",
    "search_text": "tenpy.algorithms.mps_common.qrbasedvariationalapplympo # api definition: tenpy.algorithms.mps_common.qrbasedvariationalapplympo\nclass qrbasedvariationalapplympo:\n    \"\"\"variational mpo application, using qr-based decompositions instead of svd.\"\"\"\n    def update_new_psi(self, theta: npc.array):\n        \"\"\"given a new two-site wave function `theta`, split it and save it in :attr:`psi`.\"\"\" class qrbasedvariationalapplympo tenpy.algorithms.mps_common",
    "tokens": 84
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.exact_diag.ExactDiag",
    "content": "# API Definition: tenpy.algorithms.exact_diag.ExactDiag\nclass ExactDiag:\n    \"\"\"(Full) exact diagonalization of the Hamiltonian.\"\"\"\n    def __init__(self, model, charge_sector=None, sparse=False, max_size=2000000.0): pass\n    def possible_charge_sectors(self): pass\n    def from_infinite_model(cls, model, first=0, last=None, enlarge=None, **kwargs):\n        \"\"\"Initialize by extracting a finite segment from a ``bc_MPS=infinite'`` model.\"\"\"\n    def from_H_mpo(cls, H_MPO, *args, **kwargs):\n        \"\"\"Wrapper taking directly an MPO instead of a Model.\"\"\"\n    def build_full_H_from_mpo(self):\n        \"\"\"Calculate self.full_H from the MPO (``H_MPO``) of the model.\"\"\"\n    def build_full_H_from_bonds(self):\n        \"\"\"Calculate self.full_H from bond terms (``H_bond``) of the model.\"\"\"\n    def full_diagonalization(self, *args, **kwargs):\n        \"\"\"Full diagonalization to obtain all eigenvalues and eigenvectors.\"\"\"\n    def groundstate(self, charge_sector=None):\n        \"\"\"Pick the ground state energy and ground state from ``self.V``.\"\"\"\n    def exp_H(self, dt):\n        \"\"\"Return ``U(dt) := exp(-i H dt)``.\"\"\"\n    def mps_to_full(self, mps):\n        \"\"\"Contract an MPS along the virtual bonds and combine its legs.\"\"\"\n    def full_to_mps(self, psi, canonical_form='B'):\n        \"\"\"Convert a full state (with a single leg) to an MPS.\"\"\"\n    def matvec(self, psi):\n        \"\"\"Allow to use `self` as LinearOperator for lanczos.\"\"\"\n    def sparse_diag(self, k, *args, **kwargs):\n        \"\"\"Call :func:`~tenpy.linalg.np_conserved.speigs`.\"\"\"",
    "search_text": "tenpy.algorithms.exact_diag.exactdiag # api definition: tenpy.algorithms.exact_diag.exactdiag\nclass exactdiag:\n    \"\"\"(full) exact diagonalization of the hamiltonian.\"\"\"\n    def __init__(self, model, charge_sector=none, sparse=false, max_size=2000000.0): pass\n    def possible_charge_sectors(self): pass\n    def from_infinite_model(cls, model, first=0, last=none, enlarge=none, **kwargs):\n        \"\"\"initialize by extracting a finite segment from a ``bc_mps=infinite'`` model.\"\"\"\n    def from_h_mpo(cls, h_mpo, *args, **kwargs):\n        \"\"\"wrapper taking directly an mpo instead of a model.\"\"\"\n    def build_full_h_from_mpo(self):\n        \"\"\"calculate self.full_h from the mpo (``h_mpo``) of the model.\"\"\"\n    def build_full_h_from_bonds(self):\n        \"\"\"calculate self.full_h from bond terms (``h_bond``) of the model.\"\"\"\n    def full_diagonalization(self, *args, **kwargs):\n        \"\"\"full diagonalization to obtain all eigenvalues and eigenvectors.\"\"\"\n    def groundstate(self, charge_sector=none):\n        \"\"\"pick the ground state energy and ground state from ``self.v``.\"\"\"\n    def exp_h(self, dt):\n        \"\"\"return ``u(dt) := exp(-i h dt)``.\"\"\"\n    def mps_to_full(self, mps):\n        \"\"\"contract an mps along the virtual bonds and combine its legs.\"\"\"\n    def full_to_mps(self, psi, canonical_form='b'):\n        \"\"\"convert a full state (with a single leg) to an mps.\"\"\"\n    def matvec(self, psi):\n        \"\"\"allow to use `self` as linearoperator for lanczos.\"\"\"\n    def sparse_diag(self, k, *args, **kwargs):\n        \"\"\"call :func:`~tenpy.linalg.np_conserved.speigs`.\"\"\" class exactdiag tenpy.algorithms.exact_diag",
    "tokens": 396
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.exact_diag.get_full_wavefunction",
    "content": "# API Function: tenpy.algorithms.exact_diag.get_full_wavefunction\ndef get_full_wavefunction(psi: MPS, undo_sort_charge: bool=True):\n    \"\"\"Get the full wavefunction of a finite MPS as a 1D numpy array.\"\"\"",
    "search_text": "tenpy.algorithms.exact_diag.get_full_wavefunction # api function: tenpy.algorithms.exact_diag.get_full_wavefunction\ndef get_full_wavefunction(psi: mps, undo_sort_charge: bool=true):\n    \"\"\"get the full wavefunction of a finite mps as a 1d numpy array.\"\"\" function get_full_wavefunction",
    "tokens": 52
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.exact_diag.get_numpy_Hamiltonian",
    "content": "# API Function: tenpy.algorithms.exact_diag.get_numpy_Hamiltonian\ndef get_numpy_Hamiltonian(model, from_mpo: bool=True, undo_sort_charge: bool=True):\n    \"\"\"Get the Hamiltonian as a matrix (2D numpy array).\"\"\"",
    "search_text": "tenpy.algorithms.exact_diag.get_numpy_hamiltonian # api function: tenpy.algorithms.exact_diag.get_numpy_hamiltonian\ndef get_numpy_hamiltonian(model, from_mpo: bool=true, undo_sort_charge: bool=true):\n    \"\"\"get the hamiltonian as a matrix (2d numpy array).\"\"\" function get_numpy_hamiltonian",
    "tokens": 57
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.exact_diag.get_scipy_sparse_Hamiltonian",
    "content": "# API Function: tenpy.algorithms.exact_diag.get_scipy_sparse_Hamiltonian\ndef get_scipy_sparse_Hamiltonian(model, undo_sort_charge: bool=True):\n    \"\"\"Get the Hamiltonian as a sparse scipy matrix.\"\"\"",
    "search_text": "tenpy.algorithms.exact_diag.get_scipy_sparse_hamiltonian # api function: tenpy.algorithms.exact_diag.get_scipy_sparse_hamiltonian\ndef get_scipy_sparse_hamiltonian(model, undo_sort_charge: bool=true):\n    \"\"\"get the hamiltonian as a sparse scipy matrix.\"\"\" function get_scipy_sparse_hamiltonian",
    "tokens": 50
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.plane_wave_excitation.append_right_env",
    "content": "# API Function: tenpy.algorithms.plane_wave_excitation.append_right_env\ndef append_right_env(As, Bs, R, Ws=None):\n    \"\"\"Contract all tensors in As and Bs to the right environment R.\"\"\"",
    "search_text": "tenpy.algorithms.plane_wave_excitation.append_right_env # api function: tenpy.algorithms.plane_wave_excitation.append_right_env\ndef append_right_env(as, bs, r, ws=none):\n    \"\"\"contract all tensors in as and bs to the right environment r.\"\"\" function append_right_env",
    "tokens": 47
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.plane_wave_excitation.append_left_env",
    "content": "# API Function: tenpy.algorithms.plane_wave_excitation.append_left_env\ndef append_left_env(As, Bs, L, Ws=None):\n    \"\"\"Contract all tensors in As and Bs to the left environment L.\"\"\"",
    "search_text": "tenpy.algorithms.plane_wave_excitation.append_left_env # api function: tenpy.algorithms.plane_wave_excitation.append_left_env\ndef append_left_env(as, bs, l, ws=none):\n    \"\"\"contract all tensors in as and bs to the left environment l.\"\"\" function append_left_env",
    "tokens": 47
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.plane_wave_excitation.construct_orthogonal",
    "content": "# API Function: tenpy.algorithms.plane_wave_excitation.construct_orthogonal\ndef construct_orthogonal(M, left=True):\n    \"\"\"Find (left) orthogonal complement of tensor M\"\"\"",
    "search_text": "tenpy.algorithms.plane_wave_excitation.construct_orthogonal # api function: tenpy.algorithms.plane_wave_excitation.construct_orthogonal\ndef construct_orthogonal(m, left=true):\n    \"\"\"find (left) orthogonal complement of tensor m\"\"\" function construct_orthogonal",
    "tokens": 40
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.plane_wave_excitation.PlaneWaveExcitationEngine",
    "content": "# API Definition: tenpy.algorithms.plane_wave_excitation.PlaneWaveExcitationEngine\nclass PlaneWaveExcitationEngine:\n    \"\"\"Base engine to compute quasiparticle excitations for uniform MPS.\"\"\"\n    def __init__(self, psi, model, options, **kwargs): pass\n    def run(self, p, qtotal_change=None, orthogonal_to=[], E_boosts=[], num_ev=1):\n        \"\"\"Run the plane-wave algorithm to find excited states of the given model.\"\"\"\n    def resume_run(self): pass\n    def energy(self, p, X):\n        \"\"\"Compute the energy of excited states\"\"\"\n    def infinite_sum_right(self, p, X):\n        \"\"\"Infinite sum to the right, see Eq. (194) in :cite:`vanderstraeten2019`\"\"\"\n    def infinite_sum_left(self, p, X):\n        \"\"\"Infinite sum to the left, see Eq. (194) in :cite:`vanderstraeten2019`\"\"\"\n    def initial_guess(self, qtotal_change):\n        \"\"\"Initial guess for the `X` tensors within a fixed charge sector.\"\"\"",
    "search_text": "tenpy.algorithms.plane_wave_excitation.planewaveexcitationengine # api definition: tenpy.algorithms.plane_wave_excitation.planewaveexcitationengine\nclass planewaveexcitationengine:\n    \"\"\"base engine to compute quasiparticle excitations for uniform mps.\"\"\"\n    def __init__(self, psi, model, options, **kwargs): pass\n    def run(self, p, qtotal_change=none, orthogonal_to=[], e_boosts=[], num_ev=1):\n        \"\"\"run the plane-wave algorithm to find excited states of the given model.\"\"\"\n    def resume_run(self): pass\n    def energy(self, p, x):\n        \"\"\"compute the energy of excited states\"\"\"\n    def infinite_sum_right(self, p, x):\n        \"\"\"infinite sum to the right, see eq. (194) in :cite:`vanderstraeten2019`\"\"\"\n    def infinite_sum_left(self, p, x):\n        \"\"\"infinite sum to the left, see eq. (194) in :cite:`vanderstraeten2019`\"\"\"\n    def initial_guess(self, qtotal_change):\n        \"\"\"initial guess for the `x` tensors within a fixed charge sector.\"\"\" class planewaveexcitationengine tenpy.algorithms.plane_wave_excitation",
    "tokens": 229
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.plane_wave_excitation.MultiSitePlaneWaveExcitationEngine",
    "content": "# API Definition: tenpy.algorithms.plane_wave_excitation.MultiSitePlaneWaveExcitationEngine\nclass MultiSitePlaneWaveExcitationEngine:\n    \"\"\"Engine to compute quasiparticle excitations across multiple sites for uniform MPS.\"\"\"\n    def __init__(self, psi, model, options, **kwargs): pass\n    def run(self, p, qtotal_change=None, orthogonal_to=[], E_boosts=[], num_ev=1):\n        \"\"\"Run the plane-wave algorithm to find excited states of the given model.\"\"\"\n    def resume_run(self): pass\n    def energy(self, p, X):\n        \"\"\"Compute the energy of excited states\"\"\"\n    def attach_right(self, VL, X, As, R, Ws=None):\n        \"\"\"Attach excitation tensors to a right environment\"\"\"\n    def infinite_sum_right(self, p, X):\n        \"\"\"Infinite sum to the right, see Eq. (194) in :cite:`vanderstraeten2019`\"\"\"\n    def attach_left(self, VL, X, As, L, Ws=None):\n        \"\"\"Attach excitation tensors to a left environment\"\"\"\n    def infinite_sum_left(self, p, X):\n        \"\"\"Infinite sum to the left, see Eq. (194) in :cite:`vanderstraeten2019`\"\"\"\n    def initial_guess(self, qtotal_change):\n        \"\"\"Initial guess for the `X` tensors within a fixed charge sector.\"\"\"",
    "search_text": "tenpy.algorithms.plane_wave_excitation.multisiteplanewaveexcitationengine # api definition: tenpy.algorithms.plane_wave_excitation.multisiteplanewaveexcitationengine\nclass multisiteplanewaveexcitationengine:\n    \"\"\"engine to compute quasiparticle excitations across multiple sites for uniform mps.\"\"\"\n    def __init__(self, psi, model, options, **kwargs): pass\n    def run(self, p, qtotal_change=none, orthogonal_to=[], e_boosts=[], num_ev=1):\n        \"\"\"run the plane-wave algorithm to find excited states of the given model.\"\"\"\n    def resume_run(self): pass\n    def energy(self, p, x):\n        \"\"\"compute the energy of excited states\"\"\"\n    def attach_right(self, vl, x, as, r, ws=none):\n        \"\"\"attach excitation tensors to a right environment\"\"\"\n    def infinite_sum_right(self, p, x):\n        \"\"\"infinite sum to the right, see eq. (194) in :cite:`vanderstraeten2019`\"\"\"\n    def attach_left(self, vl, x, as, l, ws=none):\n        \"\"\"attach excitation tensors to a left environment\"\"\"\n    def infinite_sum_left(self, p, x):\n        \"\"\"infinite sum to the left, see eq. (194) in :cite:`vanderstraeten2019`\"\"\"\n    def initial_guess(self, qtotal_change):\n        \"\"\"initial guess for the `x` tensors within a fixed charge sector.\"\"\" class multisiteplanewaveexcitationengine tenpy.algorithms.plane_wave_excitation",
    "tokens": 292
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.dmrg.run",
    "content": "# API Function: tenpy.algorithms.dmrg.run\ndef run(psi, model, options, **kwargs):\n    \"\"\"Run the DMRG algorithm to find the ground state of the given model.\"\"\"",
    "search_text": "tenpy.algorithms.dmrg.run # api function: tenpy.algorithms.dmrg.run\ndef run(psi, model, options, **kwargs):\n    \"\"\"run the dmrg algorithm to find the ground state of the given model.\"\"\" function run",
    "tokens": 42
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.dmrg.DMRGEngine",
    "content": "# API Definition: tenpy.algorithms.dmrg.DMRGEngine\nclass DMRGEngine:\n    \"\"\"DMRG base class with common methods for the TwoSiteDMRG and SingleSiteDMRG.\"\"\"\n    def __init__(self, psi, model, options, **kwargs): pass\n    def pre_run_initialize(self): pass\n    def run_iteration(self):\n        \"\"\"Perform a single iteration, consisting of ``N_sweeps_check`` sweeps.\"\"\"\n    def status_update(self, iteration_start_time: float): pass\n    def is_converged(self):\n        \"\"\"Determines if the algorithm is converged.\"\"\"\n    def post_run_cleanup(self):\n        \"\"\"Perform any final steps or clean up after the main loop has terminated.\"\"\"\n    def run(self):\n        \"\"\"Run the DMRG simulation to find the ground state.\"\"\"\n    def reset_stats(self, resume_data=None):\n        \"\"\"Reset the statistics, useful if you want to start a new sweep run.\"\"\"\n    def sweep(self, optimize=True, meas_E_trunc=False):\n        \"\"\"One 'sweep' of the algorithm.\"\"\"\n    def update_local(self, theta, optimize=True):\n        \"\"\"Perform site-update on the site ``i0``.\"\"\"\n    def post_update_local(self, E0, age, N, ov_change, err, **update_data):\n        \"\"\"Perform post-update actions.\"\"\"\n    def update_segment_boundaries(self):\n        \"\"\"Update the singular values at the boundaries of the segment.\"\"\"\n    def diag(self, theta_guess):\n        \"\"\"Diagonalize the effective Hamiltonian represented by self.\"\"\"\n    def plot_update_stats(self, axes, xaxis='time', yaxis='E', y_exact=None, **kwargs):\n        \"\"\"Plot :attr:`update_stats` to display the convergence during the sweeps.\"\"\"\n    def plot_sweep_stats(self, axes=None, xaxis='time', yaxis='E', y_exact=None, **kwargs):\n        \"\"\"Plot :attr:`sweep_stats` to display the convergence with the sweeps.\"\"\"",
    "search_text": "tenpy.algorithms.dmrg.dmrgengine # api definition: tenpy.algorithms.dmrg.dmrgengine\nclass dmrgengine:\n    \"\"\"dmrg base class with common methods for the twositedmrg and singlesitedmrg.\"\"\"\n    def __init__(self, psi, model, options, **kwargs): pass\n    def pre_run_initialize(self): pass\n    def run_iteration(self):\n        \"\"\"perform a single iteration, consisting of ``n_sweeps_check`` sweeps.\"\"\"\n    def status_update(self, iteration_start_time: float): pass\n    def is_converged(self):\n        \"\"\"determines if the algorithm is converged.\"\"\"\n    def post_run_cleanup(self):\n        \"\"\"perform any final steps or clean up after the main loop has terminated.\"\"\"\n    def run(self):\n        \"\"\"run the dmrg simulation to find the ground state.\"\"\"\n    def reset_stats(self, resume_data=none):\n        \"\"\"reset the statistics, useful if you want to start a new sweep run.\"\"\"\n    def sweep(self, optimize=true, meas_e_trunc=false):\n        \"\"\"one 'sweep' of the algorithm.\"\"\"\n    def update_local(self, theta, optimize=true):\n        \"\"\"perform site-update on the site ``i0``.\"\"\"\n    def post_update_local(self, e0, age, n, ov_change, err, **update_data):\n        \"\"\"perform post-update actions.\"\"\"\n    def update_segment_boundaries(self):\n        \"\"\"update the singular values at the boundaries of the segment.\"\"\"\n    def diag(self, theta_guess):\n        \"\"\"diagonalize the effective hamiltonian represented by self.\"\"\"\n    def plot_update_stats(self, axes, xaxis='time', yaxis='e', y_exact=none, **kwargs):\n        \"\"\"plot :attr:`update_stats` to display the convergence during the sweeps.\"\"\"\n    def plot_sweep_stats(self, axes=none, xaxis='time', yaxis='e', y_exact=none, **kwargs):\n        \"\"\"plot :attr:`sweep_stats` to display the convergence with the sweeps.\"\"\" class dmrgengine tenpy.algorithms.dmrg",
    "tokens": 404
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.dmrg.TwoSiteDMRGEngine",
    "content": "# API Definition: tenpy.algorithms.dmrg.TwoSiteDMRGEngine\nclass TwoSiteDMRGEngine:\n    \"\"\"Engine for the two-site DMRG algorithm.\"\"\"\n    def prepare_svd(self, theta):\n        \"\"\"Transform theta into matrix for svd.\"\"\"\n    def mixed_svd(self, theta):\n        \"\"\"Get (truncated) `B` from the new theta (as returned by diag).\"\"\"\n    def set_B(self, U, S, VH):\n        \"\"\"Update the MPS with the ``U, S, VH`` returned by `self.mixed_svd`.\"\"\"",
    "search_text": "tenpy.algorithms.dmrg.twositedmrgengine # api definition: tenpy.algorithms.dmrg.twositedmrgengine\nclass twositedmrgengine:\n    \"\"\"engine for the two-site dmrg algorithm.\"\"\"\n    def prepare_svd(self, theta):\n        \"\"\"transform theta into matrix for svd.\"\"\"\n    def mixed_svd(self, theta):\n        \"\"\"get (truncated) `b` from the new theta (as returned by diag).\"\"\"\n    def set_b(self, u, s, vh):\n        \"\"\"update the mps with the ``u, s, vh`` returned by `self.mixed_svd`.\"\"\" class twositedmrgengine tenpy.algorithms.dmrg",
    "tokens": 121
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.dmrg.SingleSiteDMRGEngine",
    "content": "# API Definition: tenpy.algorithms.dmrg.SingleSiteDMRGEngine\nclass SingleSiteDMRGEngine:\n    \"\"\"Engine for the single-site DMRG algorithm.\"\"\"\n    def prepare_svd(self, theta):\n        \"\"\"Transform theta into matrix for svd.\"\"\"\n    def mixed_svd(self, theta):\n        \"\"\"Get (truncated) `B` from the new theta (as returned by diag).\"\"\"\n    def set_B(self, U, S, VH):\n        \"\"\"Update the MPS with the ``U, S, VH`` returned by `self.mixed_svd`.\"\"\"\n    def mixer_activate(self): pass",
    "search_text": "tenpy.algorithms.dmrg.singlesitedmrgengine # api definition: tenpy.algorithms.dmrg.singlesitedmrgengine\nclass singlesitedmrgengine:\n    \"\"\"engine for the single-site dmrg algorithm.\"\"\"\n    def prepare_svd(self, theta):\n        \"\"\"transform theta into matrix for svd.\"\"\"\n    def mixed_svd(self, theta):\n        \"\"\"get (truncated) `b` from the new theta (as returned by diag).\"\"\"\n    def set_b(self, u, s, vh):\n        \"\"\"update the mps with the ``u, s, vh`` returned by `self.mixed_svd`.\"\"\"\n    def mixer_activate(self): pass class singlesitedmrgengine tenpy.algorithms.dmrg",
    "tokens": 127
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.dmrg.chi_list",
    "content": "# API Function: tenpy.algorithms.dmrg.chi_list\ndef chi_list(chi_max, dchi=20, nsweeps=20):\n    \"\"\"Compute a 'ramping-up' chi_list.\"\"\"",
    "search_text": "tenpy.algorithms.dmrg.chi_list # api function: tenpy.algorithms.dmrg.chi_list\ndef chi_list(chi_max, dchi=20, nsweeps=20):\n    \"\"\"compute a 'ramping-up' chi_list.\"\"\" function chi_list",
    "tokens": 44
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.dmrg.full_diag_effH",
    "content": "# API Function: tenpy.algorithms.dmrg.full_diag_effH\ndef full_diag_effH(effH, theta_guess, keep_sector=True):\n    \"\"\"Perform an exact diagonalization of `effH`.\"\"\"",
    "search_text": "tenpy.algorithms.dmrg.full_diag_effh # api function: tenpy.algorithms.dmrg.full_diag_effh\ndef full_diag_effh(effh, theta_guess, keep_sector=true):\n    \"\"\"perform an exact diagonalization of `effh`.\"\"\" function full_diag_effh",
    "tokens": 44
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.dmrg_parallel.TwoSiteHThreadPlusHC",
    "content": "# API Definition: tenpy.algorithms.dmrg_parallel.TwoSiteHThreadPlusHC\nclass TwoSiteHThreadPlusHC:\n    \"\"\"Version of `TwoSiteH` that parallelizes matvec with threads.\"\"\"\n    def __init__(self, *args, **kwargs): pass\n    def matvec(self, theta): pass\n    def matvec_hc(self, theta): pass\n    def to_matrix(self): pass\n    def adjoint(self): pass",
    "search_text": "tenpy.algorithms.dmrg_parallel.twositehthreadplushc # api definition: tenpy.algorithms.dmrg_parallel.twositehthreadplushc\nclass twositehthreadplushc:\n    \"\"\"version of `twositeh` that parallelizes matvec with threads.\"\"\"\n    def __init__(self, *args, **kwargs): pass\n    def matvec(self, theta): pass\n    def matvec_hc(self, theta): pass\n    def to_matrix(self): pass\n    def adjoint(self): pass class twositehthreadplushc tenpy.algorithms.dmrg_parallel",
    "tokens": 96
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.dmrg_parallel.DMRGThreadPlusHC",
    "content": "# API Definition: tenpy.algorithms.dmrg_parallel.DMRGThreadPlusHC\nclass DMRGThreadPlusHC:\n    def __init__(self, psi, model, options, **kwargs): pass\n    def make_eff_H(self): pass\n    def run(self): pass",
    "search_text": "tenpy.algorithms.dmrg_parallel.dmrgthreadplushc # api definition: tenpy.algorithms.dmrg_parallel.dmrgthreadplushc\nclass dmrgthreadplushc:\n    def __init__(self, psi, model, options, **kwargs): pass\n    def make_eff_h(self): pass\n    def run(self): pass class dmrgthreadplushc tenpy.algorithms.dmrg_parallel",
    "tokens": 59
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.tebd.TEBDEngine",
    "content": "# API Definition: tenpy.algorithms.tebd.TEBDEngine\nclass TEBDEngine:\n    \"\"\"Time Evolving Block Decimation (TEBD) algorithm.\"\"\"\n    def __init__(self, psi, model, options, **kwargs): pass\n    def trunc_err_bonds(self):\n        \"\"\"Truncation error introduced on each non-trivial bond.\"\"\"\n    def run_GS(self):\n        \"\"\"TEBD algorithm in imaginary time to find the ground state.\"\"\"\n    def suzuki_trotter_time_steps(order):\n        \"\"\"Return time steps of U for the Suzuki Trotter decomposition of desired order.\"\"\"\n    def suzuki_trotter_decomposition(order, N_steps):\n        \"\"\"Returns list of necessary steps for the suzuki trotter decomposition.\"\"\"\n    def prepare_evolve(self, dt): pass\n    def calc_U(self, order, delta_t, type_evo='real', E_offset=None):\n        \"\"\"Calculate ``self.U_bond`` from ``self.model.H_bond``.\"\"\"\n    def evolve(self, N_steps, dt):\n        \"\"\"Evolve by ``dt * N_steps``.\"\"\"\n    def evolve_step(self, U_idx_dt, odd):\n        \"\"\"Updates either even *or* odd bonds in unit cell.\"\"\"\n    def update_bond(self, i, U_bond):\n        \"\"\"Updates the B matrices on a given bond.\"\"\"\n    def update_imag(self, N_steps, call_canonical_form=True):\n        \"\"\"Perform an update suitable for imaginary time evolution.\"\"\"\n    def update_bond_imag(self, i, U_bond):\n        \"\"\"Update a bond with a (possibly non-unitary) `U_bond`.\"\"\"",
    "search_text": "tenpy.algorithms.tebd.tebdengine # api definition: tenpy.algorithms.tebd.tebdengine\nclass tebdengine:\n    \"\"\"time evolving block decimation (tebd) algorithm.\"\"\"\n    def __init__(self, psi, model, options, **kwargs): pass\n    def trunc_err_bonds(self):\n        \"\"\"truncation error introduced on each non-trivial bond.\"\"\"\n    def run_gs(self):\n        \"\"\"tebd algorithm in imaginary time to find the ground state.\"\"\"\n    def suzuki_trotter_time_steps(order):\n        \"\"\"return time steps of u for the suzuki trotter decomposition of desired order.\"\"\"\n    def suzuki_trotter_decomposition(order, n_steps):\n        \"\"\"returns list of necessary steps for the suzuki trotter decomposition.\"\"\"\n    def prepare_evolve(self, dt): pass\n    def calc_u(self, order, delta_t, type_evo='real', e_offset=none):\n        \"\"\"calculate ``self.u_bond`` from ``self.model.h_bond``.\"\"\"\n    def evolve(self, n_steps, dt):\n        \"\"\"evolve by ``dt * n_steps``.\"\"\"\n    def evolve_step(self, u_idx_dt, odd):\n        \"\"\"updates either even *or* odd bonds in unit cell.\"\"\"\n    def update_bond(self, i, u_bond):\n        \"\"\"updates the b matrices on a given bond.\"\"\"\n    def update_imag(self, n_steps, call_canonical_form=true):\n        \"\"\"perform an update suitable for imaginary time evolution.\"\"\"\n    def update_bond_imag(self, i, u_bond):\n        \"\"\"update a bond with a (possibly non-unitary) `u_bond`.\"\"\" class tebdengine tenpy.algorithms.tebd",
    "tokens": 337
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.tebd.QRBasedTEBDEngine",
    "content": "# API Definition: tenpy.algorithms.tebd.QRBasedTEBDEngine\nclass QRBasedTEBDEngine:\n    \"\"\"Version of TEBD that relies on QR decompositions rather than SVD.\"\"\"\n    def update_bond(self, i, U_bond): pass\n    def update_bond_imag(self, i, U_bond): pass",
    "search_text": "tenpy.algorithms.tebd.qrbasedtebdengine # api definition: tenpy.algorithms.tebd.qrbasedtebdengine\nclass qrbasedtebdengine:\n    \"\"\"version of tebd that relies on qr decompositions rather than svd.\"\"\"\n    def update_bond(self, i, u_bond): pass\n    def update_bond_imag(self, i, u_bond): pass class qrbasedtebdengine tenpy.algorithms.tebd",
    "tokens": 74
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.tebd.RandomUnitaryEvolution",
    "content": "# API Definition: tenpy.algorithms.tebd.RandomUnitaryEvolution\nclass RandomUnitaryEvolution:\n    \"\"\"Evolution of an MPS with random two-site unitaries in a TEBD-like fashion.\"\"\"\n    def __init__(self, psi, options, **kwargs): pass\n    def run(self):\n        \"\"\"Time evolution with TEBD and random two-site unitaries (possibly conserving charges).\"\"\"\n    def prepare_evolve(self, dt):\n        \"\"\"Do nothing, as we call :meth:`calc_U` directly in :meth:`update`.\"\"\"\n    def calc_U(self):\n        \"\"\"Draw new random two-site unitaries replacing the usual `U` of TEBD.\"\"\"\n    def evolve(self, N_steps, dt):\n        \"\"\"Apply ``N_steps`` random two-site unitaries to each bond (in even-odd pattern).\"\"\"",
    "search_text": "tenpy.algorithms.tebd.randomunitaryevolution # api definition: tenpy.algorithms.tebd.randomunitaryevolution\nclass randomunitaryevolution:\n    \"\"\"evolution of an mps with random two-site unitaries in a tebd-like fashion.\"\"\"\n    def __init__(self, psi, options, **kwargs): pass\n    def run(self):\n        \"\"\"time evolution with tebd and random two-site unitaries (possibly conserving charges).\"\"\"\n    def prepare_evolve(self, dt):\n        \"\"\"do nothing, as we call :meth:`calc_u` directly in :meth:`update`.\"\"\"\n    def calc_u(self):\n        \"\"\"draw new random two-site unitaries replacing the usual `u` of tebd.\"\"\"\n    def evolve(self, n_steps, dt):\n        \"\"\"apply ``n_steps`` random two-site unitaries to each bond (in even-odd pattern).\"\"\" class randomunitaryevolution tenpy.algorithms.tebd",
    "tokens": 176
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.tebd.TimeDependentTEBD",
    "content": "# API Definition: tenpy.algorithms.tebd.TimeDependentTEBD\nclass TimeDependentTEBD:\n    \"\"\"Variant of :class:`TEBDEngine` that can handle time-dependent Hamiltonians.\"\"\"\n",
    "search_text": "tenpy.algorithms.tebd.timedependenttebd # api definition: tenpy.algorithms.tebd.timedependenttebd\nclass timedependenttebd:\n    \"\"\"variant of :class:`tebdengine` that can handle time-dependent hamiltonians.\"\"\"\n class timedependenttebd tenpy.algorithms.tebd",
    "tokens": 43
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.algorithm.Algorithm",
    "content": "# API Definition: tenpy.algorithms.algorithm.Algorithm\nclass Algorithm:\n    \"\"\"Base class and common interface for a tensor-network based algorithm in TeNPy.\"\"\"\n    def __init__(self, psi, model, options): pass\n    def switch_engine(cls, other_engine, **kwargs):\n        \"\"\"Initialize algorithm from another algorithm instance of a different class.\"\"\"\n    def run(self):\n        \"\"\"Actually run the algorithm.\"\"\"\n    def resume_run(self):\n        \"\"\"Resume a run that was interrupted.\"\"\"\n    def get_resume_data(self, sequential_simulations=False):\n        \"\"\"Return necessary data to resume a :meth:`run` interrupted at a checkpoint.\"\"\"\n    def estimate_RAM(self, mem_saving_factor=None):\n        \"\"\"Gives an approximate prediction for the required memory usage.\"\"\"",
    "search_text": "tenpy.algorithms.algorithm.algorithm # api definition: tenpy.algorithms.algorithm.algorithm\nclass algorithm:\n    \"\"\"base class and common interface for a tensor-network based algorithm in tenpy.\"\"\"\n    def __init__(self, psi, model, options): pass\n    def switch_engine(cls, other_engine, **kwargs):\n        \"\"\"initialize algorithm from another algorithm instance of a different class.\"\"\"\n    def run(self):\n        \"\"\"actually run the algorithm.\"\"\"\n    def resume_run(self):\n        \"\"\"resume a run that was interrupted.\"\"\"\n    def get_resume_data(self, sequential_simulations=false):\n        \"\"\"return necessary data to resume a :meth:`run` interrupted at a checkpoint.\"\"\"\n    def estimate_ram(self, mem_saving_factor=none):\n        \"\"\"gives an approximate prediction for the required memory usage.\"\"\" class algorithm tenpy.algorithms.algorithm",
    "tokens": 155
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.algorithm.TimeEvolutionAlgorithm",
    "content": "# API Definition: tenpy.algorithms.algorithm.TimeEvolutionAlgorithm\nclass TimeEvolutionAlgorithm:\n    \"\"\"Common interface for (real) time evolution algorithms.\"\"\"\n    def __init__(self, psi, model, options, **kwargs): pass\n    def get_resume_data(self, sequential_simulations=False): pass\n    def run(self):\n        \"\"\"Perform a (real-)time evolution of :attr:`psi` by `N_steps` * `dt`.\"\"\"\n    def run_evolution(self, N_steps, dt):\n        \"\"\"Perform a (real-)time evolution of :attr:`psi` by `N_steps` * `dt`.\"\"\"\n    def prepare_evolve(self, dt):\n        \"\"\"Prepare an evolution step.\"\"\"\n    def evolve(self, N_steps, dt):\n        \"\"\"Evolve by N_steps*dt.\"\"\"\n    def evolve_step(self, dt): pass",
    "search_text": "tenpy.algorithms.algorithm.timeevolutionalgorithm # api definition: tenpy.algorithms.algorithm.timeevolutionalgorithm\nclass timeevolutionalgorithm:\n    \"\"\"common interface for (real) time evolution algorithms.\"\"\"\n    def __init__(self, psi, model, options, **kwargs): pass\n    def get_resume_data(self, sequential_simulations=false): pass\n    def run(self):\n        \"\"\"perform a (real-)time evolution of :attr:`psi` by `n_steps` * `dt`.\"\"\"\n    def run_evolution(self, n_steps, dt):\n        \"\"\"perform a (real-)time evolution of :attr:`psi` by `n_steps` * `dt`.\"\"\"\n    def prepare_evolve(self, dt):\n        \"\"\"prepare an evolution step.\"\"\"\n    def evolve(self, n_steps, dt):\n        \"\"\"evolve by n_steps*dt.\"\"\"\n    def evolve_step(self, dt): pass class timeevolutionalgorithm tenpy.algorithms.algorithm",
    "tokens": 175
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.algorithm.TimeDependentHAlgorithm",
    "content": "# API Definition: tenpy.algorithms.algorithm.TimeDependentHAlgorithm\nclass TimeDependentHAlgorithm:\n    \"\"\"Time evolution under a time dependent Hamiltonian.\"\"\"\n    def __init__(self, psi, model, options, **kwargs): pass\n    def run_evolution(self, N_steps, dt):\n        \"\"\"Run the time evolution for N_steps * dt.\"\"\"\n    def reinit_model(self):\n        \"\"\"Re-initialize a new :attr:`model` at current :attr:`evolved_time`.\"\"\"",
    "search_text": "tenpy.algorithms.algorithm.timedependenthalgorithm # api definition: tenpy.algorithms.algorithm.timedependenthalgorithm\nclass timedependenthalgorithm:\n    \"\"\"time evolution under a time dependent hamiltonian.\"\"\"\n    def __init__(self, psi, model, options, **kwargs): pass\n    def run_evolution(self, n_steps, dt):\n        \"\"\"run the time evolution for n_steps * dt.\"\"\"\n    def reinit_model(self):\n        \"\"\"re-initialize a new :attr:`model` at current :attr:`evolved_time`.\"\"\" class timedependenthalgorithm tenpy.algorithms.algorithm",
    "tokens": 104
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.network_contractor.ncon",
    "content": "# API Function: tenpy.algorithms.network_contractor.ncon\ndef ncon(tensor_list, leg_links, sequence=None):\n    \"\"\"Implementation of ``ncon.m`` for TeNPy Arrays.\"\"\"",
    "search_text": "tenpy.algorithms.network_contractor.ncon # api function: tenpy.algorithms.network_contractor.ncon\ndef ncon(tensor_list, leg_links, sequence=none):\n    \"\"\"implementation of ``ncon.m`` for tenpy arrays.\"\"\" function ncon",
    "tokens": 41
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.network_contractor.contract",
    "content": "# API Function: tenpy.algorithms.network_contractor.contract\ndef contract(tensor_list, tensor_names=None, leg_contractions=None, open_legs=None, sequence=None):\n    \"\"\"Contract a network of tensors.\"\"\"",
    "search_text": "tenpy.algorithms.network_contractor.contract # api function: tenpy.algorithms.network_contractor.contract\ndef contract(tensor_list, tensor_names=none, leg_contractions=none, open_legs=none, sequence=none):\n    \"\"\"contract a network of tensors.\"\"\" function contract",
    "tokens": 43
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.purification.PurificationTwoSiteU",
    "content": "# API Definition: tenpy.algorithms.purification.PurificationTwoSiteU\nclass PurificationTwoSiteU:\n    \"\"\"Variant of `TwoSiteH` suitable for purification.\"\"\"\n    def combine_Heff(self): pass",
    "search_text": "tenpy.algorithms.purification.purificationtwositeu # api definition: tenpy.algorithms.purification.purificationtwositeu\nclass purificationtwositeu:\n    \"\"\"variant of `twositeh` suitable for purification.\"\"\"\n    def combine_heff(self): pass class purificationtwositeu tenpy.algorithms.purification",
    "tokens": 47
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.purification.PurificationApplyMPO",
    "content": "# API Definition: tenpy.algorithms.purification.PurificationApplyMPO\nclass PurificationApplyMPO:\n    \"\"\"Variant of `VariationalApplyMPO` suitable for purification.\"\"\"\n    def update_local(self, _, optimize=True):\n        \"\"\"Perform local update.\"\"\"\n    def update_new_psi(self, theta): pass",
    "search_text": "tenpy.algorithms.purification.purificationapplympo # api definition: tenpy.algorithms.purification.purificationapplympo\nclass purificationapplympo:\n    \"\"\"variant of `variationalapplympo` suitable for purification.\"\"\"\n    def update_local(self, _, optimize=true):\n        \"\"\"perform local update.\"\"\"\n    def update_new_psi(self, theta): pass class purificationapplympo tenpy.algorithms.purification",
    "tokens": 67
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.purification.PurificationTEBD",
    "content": "# API Definition: tenpy.algorithms.purification.PurificationTEBD\nclass PurificationTEBD:\n    \"\"\"Time evolving block decimation (TEBD) for purification MPS.\"\"\"\n    def __init__(self, psi, model, options, **kwargs): pass\n    def run_imaginary(self, beta):\n        \"\"\"Run imaginary time evolution to cool down by the given `beta`.\"\"\"\n    def disent_iterations(self):\n        \"\"\"For each bond the total number of iterations performed in any Disentangler.\"\"\"\n    def calc_U(self, order, delta_t, type_evo='real', E_offset=None):\n        \"\"\"See :meth:`~tenpy.algorithms.tebd.eng.calc_U`\"\"\"\n    def update_bond(self, i, U_bond):\n        \"\"\"Updates the B matrices on a given bond.\"\"\"\n    def update_bond_imag(self, i, U_bond):\n        \"\"\"Update a bond with a (possibly non-unitary) `U_bond`.\"\"\"\n    def disentangle(self, theta):\n        \"\"\"Disentangle `theta` before splitting with svd.\"\"\"\n    def disentangle_global(self, pair=None):\n        \"\"\"Try global disentangling by determining the maximally entangled pairs of sites.\"\"\"\n    def disentangle_global_nsite(self, n=2):\n        \"\"\"Perform a sweep through the system and disentangle with :meth:`disentangle_n_site`.\"\"\"\n    def disentangle_n_site(self, i, n, theta):\n        \"\"\"Generalization of :meth:`disentangle` to `n` sites.\"\"\"",
    "search_text": "tenpy.algorithms.purification.purificationtebd # api definition: tenpy.algorithms.purification.purificationtebd\nclass purificationtebd:\n    \"\"\"time evolving block decimation (tebd) for purification mps.\"\"\"\n    def __init__(self, psi, model, options, **kwargs): pass\n    def run_imaginary(self, beta):\n        \"\"\"run imaginary time evolution to cool down by the given `beta`.\"\"\"\n    def disent_iterations(self):\n        \"\"\"for each bond the total number of iterations performed in any disentangler.\"\"\"\n    def calc_u(self, order, delta_t, type_evo='real', e_offset=none):\n        \"\"\"see :meth:`~tenpy.algorithms.tebd.eng.calc_u`\"\"\"\n    def update_bond(self, i, u_bond):\n        \"\"\"updates the b matrices on a given bond.\"\"\"\n    def update_bond_imag(self, i, u_bond):\n        \"\"\"update a bond with a (possibly non-unitary) `u_bond`.\"\"\"\n    def disentangle(self, theta):\n        \"\"\"disentangle `theta` before splitting with svd.\"\"\"\n    def disentangle_global(self, pair=none):\n        \"\"\"try global disentangling by determining the maximally entangled pairs of sites.\"\"\"\n    def disentangle_global_nsite(self, n=2):\n        \"\"\"perform a sweep through the system and disentangle with :meth:`disentangle_n_site`.\"\"\"\n    def disentangle_n_site(self, i, n, theta):\n        \"\"\"generalization of :meth:`disentangle` to `n` sites.\"\"\" class purificationtebd tenpy.algorithms.purification",
    "tokens": 322
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.purification.PurificationTEBD2",
    "content": "# API Definition: tenpy.algorithms.purification.PurificationTEBD2\nclass PurificationTEBD2:\n    \"\"\"Similar as PurificationTEBD, but perform sweeps instead of brickwall.\"\"\"\n    def update(self, N_steps):\n        \"\"\"Evolve by ``N_steps * U_param['dt']``.\"\"\"\n    def update_step(self, U_idx_dt, odd):\n        \"\"\"Updates bonds in unit cell.\"\"\"",
    "search_text": "tenpy.algorithms.purification.purificationtebd2 # api definition: tenpy.algorithms.purification.purificationtebd2\nclass purificationtebd2:\n    \"\"\"similar as purificationtebd, but perform sweeps instead of brickwall.\"\"\"\n    def update(self, n_steps):\n        \"\"\"evolve by ``n_steps * u_param['dt']``.\"\"\"\n    def update_step(self, u_idx_dt, odd):\n        \"\"\"updates bonds in unit cell.\"\"\" class purificationtebd2 tenpy.algorithms.purification",
    "tokens": 86
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.mpo_evolution.ExpMPOEvolution",
    "content": "# API Definition: tenpy.algorithms.mpo_evolution.ExpMPOEvolution\nclass ExpMPOEvolution:\n    \"\"\"Time evolution of an MPS using the W_I or W_II approximation for ``exp(H dt)``.\"\"\"\n    def __init__(self, psi, model, options, **kwargs): pass\n    def prepare_evolve(self, dt): pass\n    def calc_U(self, dt, order=2, approximation='II'):\n        \"\"\"Calculate ``self._U_MPO``.\"\"\"\n    def evolve_step(self, dt): pass",
    "search_text": "tenpy.algorithms.mpo_evolution.expmpoevolution # api definition: tenpy.algorithms.mpo_evolution.expmpoevolution\nclass expmpoevolution:\n    \"\"\"time evolution of an mps using the w_i or w_ii approximation for ``exp(h dt)``.\"\"\"\n    def __init__(self, psi, model, options, **kwargs): pass\n    def prepare_evolve(self, dt): pass\n    def calc_u(self, dt, order=2, approximation='ii'):\n        \"\"\"calculate ``self._u_mpo``.\"\"\"\n    def evolve_step(self, dt): pass class expmpoevolution tenpy.algorithms.mpo_evolution",
    "tokens": 114
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.mpo_evolution.TimeDependentExpMPOEvolution",
    "content": "# API Definition: tenpy.algorithms.mpo_evolution.TimeDependentExpMPOEvolution\nclass TimeDependentExpMPOEvolution:\n    \"\"\"Variant of :class:`ExpMPOEvolution` that can handle time-dependent hamiltonians.\"\"\"\n",
    "search_text": "tenpy.algorithms.mpo_evolution.timedependentexpmpoevolution # api definition: tenpy.algorithms.mpo_evolution.timedependentexpmpoevolution\nclass timedependentexpmpoevolution:\n    \"\"\"variant of :class:`expmpoevolution` that can handle time-dependent hamiltonians.\"\"\"\n class timedependentexpmpoevolution tenpy.algorithms.mpo_evolution",
    "tokens": 53
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.tdvp.TDVPEngine",
    "content": "# API Definition: tenpy.algorithms.tdvp.TDVPEngine\nclass TDVPEngine:\n    \"\"\"Time dependent variational principle algorithm for MPS.\"\"\"\n    def __init__(self, psi, model, options, **kwargs): pass\n    def lanczos_options(self):\n        \"\"\"Deprecated alias of :attr:`lanczos_params`.\"\"\"\n    def prepare_evolve(self, dt):\n        \"\"\"Expand the basis using Krylov or random vectors using the algorithm from :cite:`yang2020`.\"\"\"\n    def evolve(self, N_steps, dt):\n        \"\"\"Evolve by ``N_steps * dt``.\"\"\"",
    "search_text": "tenpy.algorithms.tdvp.tdvpengine # api definition: tenpy.algorithms.tdvp.tdvpengine\nclass tdvpengine:\n    \"\"\"time dependent variational principle algorithm for mps.\"\"\"\n    def __init__(self, psi, model, options, **kwargs): pass\n    def lanczos_options(self):\n        \"\"\"deprecated alias of :attr:`lanczos_params`.\"\"\"\n    def prepare_evolve(self, dt):\n        \"\"\"expand the basis using krylov or random vectors using the algorithm from :cite:`yang2020`.\"\"\"\n    def evolve(self, n_steps, dt):\n        \"\"\"evolve by ``n_steps * dt``.\"\"\" class tdvpengine tenpy.algorithms.tdvp",
    "tokens": 127
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.tdvp.TwoSiteTDVPEngine",
    "content": "# API Definition: tenpy.algorithms.tdvp.TwoSiteTDVPEngine\nclass TwoSiteTDVPEngine:\n    \"\"\"Engine for the two-site TDVP algorithm.\"\"\"\n    def __init__(self, psi, model, options, **kwargs): pass\n    def get_sweep_schedule(self):\n        \"\"\"Slightly different sweep schedule than DMRG\"\"\"\n    def update_local(self, theta, **kwargs): pass\n    def update_env(self, **update_data):\n        \"\"\"Do nothing; super().update_env() is called explicitly in :meth:`update_local`.\"\"\"\n    def one_site_update(self, i, dt): pass",
    "search_text": "tenpy.algorithms.tdvp.twositetdvpengine # api definition: tenpy.algorithms.tdvp.twositetdvpengine\nclass twositetdvpengine:\n    \"\"\"engine for the two-site tdvp algorithm.\"\"\"\n    def __init__(self, psi, model, options, **kwargs): pass\n    def get_sweep_schedule(self):\n        \"\"\"slightly different sweep schedule than dmrg\"\"\"\n    def update_local(self, theta, **kwargs): pass\n    def update_env(self, **update_data):\n        \"\"\"do nothing; super().update_env() is called explicitly in :meth:`update_local`.\"\"\"\n    def one_site_update(self, i, dt): pass class twositetdvpengine tenpy.algorithms.tdvp",
    "tokens": 132
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.tdvp.SingleSiteTDVPEngine",
    "content": "# API Definition: tenpy.algorithms.tdvp.SingleSiteTDVPEngine\nclass SingleSiteTDVPEngine:\n    \"\"\"Engine for the single-site TDVP algorithm.\"\"\"\n    def get_sweep_schedule(self):\n        \"\"\"Slightly different sweep schedule than DMRG\"\"\"\n    def update_local(self, theta, **kwargs): pass\n    def right_moving_update(self, i0, theta): pass\n    def left_moving_update(self, i0, theta): pass\n    def update_env(self, **update_data):\n        \"\"\"Do nothing; super().update_env() is called explicitly in :meth:`update_local`.\"\"\"\n    def zero_site_update(self, i, theta, dt):\n        \"\"\"Zero-site update on the left of site `i`.\"\"\"\n    def post_update_local(self, **update_data): pass",
    "search_text": "tenpy.algorithms.tdvp.singlesitetdvpengine # api definition: tenpy.algorithms.tdvp.singlesitetdvpengine\nclass singlesitetdvpengine:\n    \"\"\"engine for the single-site tdvp algorithm.\"\"\"\n    def get_sweep_schedule(self):\n        \"\"\"slightly different sweep schedule than dmrg\"\"\"\n    def update_local(self, theta, **kwargs): pass\n    def right_moving_update(self, i0, theta): pass\n    def left_moving_update(self, i0, theta): pass\n    def update_env(self, **update_data):\n        \"\"\"do nothing; super().update_env() is called explicitly in :meth:`update_local`.\"\"\"\n    def zero_site_update(self, i, theta, dt):\n        \"\"\"zero-site update on the left of site `i`.\"\"\"\n    def post_update_local(self, **update_data): pass class singlesitetdvpengine tenpy.algorithms.tdvp",
    "tokens": 170
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.tdvp.TimeDependentSingleSiteTDVP",
    "content": "# API Definition: tenpy.algorithms.tdvp.TimeDependentSingleSiteTDVP\nclass TimeDependentSingleSiteTDVP:\n    \"\"\"Variant of :class:`SingleSiteTDVPEngine` that can handle time-dependent Hamiltonians.\"\"\"\n    def reinit_model(self): pass",
    "search_text": "tenpy.algorithms.tdvp.timedependentsinglesitetdvp # api definition: tenpy.algorithms.tdvp.timedependentsinglesitetdvp\nclass timedependentsinglesitetdvp:\n    \"\"\"variant of :class:`singlesitetdvpengine` that can handle time-dependent hamiltonians.\"\"\"\n    def reinit_model(self): pass class timedependentsinglesitetdvp tenpy.algorithms.tdvp",
    "tokens": 58
  },
  {
    "category": "api",
    "name": "tenpy.algorithms.tdvp.TimeDependentTwoSiteTDVP",
    "content": "# API Definition: tenpy.algorithms.tdvp.TimeDependentTwoSiteTDVP\nclass TimeDependentTwoSiteTDVP:\n    \"\"\"Variant of :class:`TwoSiteTDVPEngine` that can handle time-dependent Hamiltonians.\"\"\"\n    def reinit_model(self): pass",
    "search_text": "tenpy.algorithms.tdvp.timedependenttwositetdvp # api definition: tenpy.algorithms.tdvp.timedependenttwositetdvp\nclass timedependenttwositetdvp:\n    \"\"\"variant of :class:`twositetdvpengine` that can handle time-dependent hamiltonians.\"\"\"\n    def reinit_model(self): pass class timedependenttwositetdvp tenpy.algorithms.tdvp",
    "tokens": 58
  },
  {
    "category": "api",
    "name": "tenpy.tools.prediction.linear_prediction",
    "content": "# API Function: tenpy.tools.prediction.linear_prediction\ndef linear_prediction(x, *args, **kwargs):\n    \"\"\"Apply linear prediction to a multidimensional time series along an axis.\"\"\"",
    "search_text": "tenpy.tools.prediction.linear_prediction # api function: tenpy.tools.prediction.linear_prediction\ndef linear_prediction(x, *args, **kwargs):\n    \"\"\"apply linear prediction to a multidimensional time series along an axis.\"\"\" function linear_prediction",
    "tokens": 38
  },
  {
    "category": "api",
    "name": "tenpy.tools.prediction.simple_linear_prediction_1d",
    "content": "# API Function: tenpy.tools.prediction.simple_linear_prediction_1d\ndef simple_linear_prediction_1d(x: np.ndarray, rel_prediction_time: float=1, rel_num_points: float=0.3, truncation_mode: str='renormalize', rel_split: float=0):\n    \"\"\"Linear prediction of a one-dimensional time series data.\"\"\"",
    "search_text": "tenpy.tools.prediction.simple_linear_prediction_1d # api function: tenpy.tools.prediction.simple_linear_prediction_1d\ndef simple_linear_prediction_1d(x: np.ndarray, rel_prediction_time: float=1, rel_num_points: float=0.3, truncation_mode: str='renormalize', rel_split: float=0):\n    \"\"\"linear prediction of a one-dimensional time series data.\"\"\" function simple_linear_prediction_1d",
    "tokens": 75
  },
  {
    "category": "api",
    "name": "tenpy.tools.prediction.get_lpc",
    "content": "# API Function: tenpy.tools.prediction.get_lpc\ndef get_lpc(x, p):\n    \"\"\"Obtain the linear prediction coefficients (lpc) from correlations.\"\"\"",
    "search_text": "tenpy.tools.prediction.get_lpc # api function: tenpy.tools.prediction.get_lpc\ndef get_lpc(x, p):\n    \"\"\"obtain the linear prediction coefficients (lpc) from correlations.\"\"\" function get_lpc",
    "tokens": 36
  },
  {
    "category": "api",
    "name": "tenpy.tools.prediction.get_alpha_and_c",
    "content": "# API Function: tenpy.tools.prediction.get_alpha_and_c\ndef get_alpha_and_c(x, lpc, truncation_mode='cutoff', epsilon=1e-06):\n    \"\"\"Get the eigenvalues and coefficients from a vector of linear prediction coefficients.\"\"\"",
    "search_text": "tenpy.tools.prediction.get_alpha_and_c # api function: tenpy.tools.prediction.get_alpha_and_c\ndef get_alpha_and_c(x, lpc, truncation_mode='cutoff', epsilon=1e-06):\n    \"\"\"get the eigenvalues and coefficients from a vector of linear prediction coefficients.\"\"\" function get_alpha_and_c",
    "tokens": 54
  },
  {
    "category": "api",
    "name": "tenpy.tools.optimization.OptimizationFlag",
    "content": "# API Definition: tenpy.tools.optimization.OptimizationFlag\nclass OptimizationFlag:\n    \"\"\"Options for the global 'optimization level' used for dynamical optimizations.\"\"\"\n    def from_bytes(cls, bytes, byteorder):\n        \"\"\"Like ``int.from_bytes``, which has a docstring which sphinx cant parse\"\"\"\n    def to_bytes(self, length=1, byteorder='big'):\n        \"\"\"Like ``int.to_bytes``, which has a docstring which sphinx cant parse\"\"\"",
    "search_text": "tenpy.tools.optimization.optimizationflag # api definition: tenpy.tools.optimization.optimizationflag\nclass optimizationflag:\n    \"\"\"options for the global 'optimization level' used for dynamical optimizations.\"\"\"\n    def from_bytes(cls, bytes, byteorder):\n        \"\"\"like ``int.from_bytes``, which has a docstring which sphinx cant parse\"\"\"\n    def to_bytes(self, length=1, byteorder='big'):\n        \"\"\"like ``int.to_bytes``, which has a docstring which sphinx cant parse\"\"\" class optimizationflag tenpy.tools.optimization",
    "tokens": 99
  },
  {
    "category": "api",
    "name": "tenpy.tools.optimization.temporary_level",
    "content": "# API Definition: tenpy.tools.optimization.temporary_level\nclass temporary_level:\n    \"\"\"Context manager to temporarily set the optimization level to a different value.\"\"\"\n    def __init__(self, temporary_level): pass",
    "search_text": "tenpy.tools.optimization.temporary_level # api definition: tenpy.tools.optimization.temporary_level\nclass temporary_level:\n    \"\"\"context manager to temporarily set the optimization level to a different value.\"\"\"\n    def __init__(self, temporary_level): pass class temporary_level tenpy.tools.optimization",
    "tokens": 43
  },
  {
    "category": "api",
    "name": "tenpy.tools.optimization.to_OptimizationFlag",
    "content": "# API Function: tenpy.tools.optimization.to_OptimizationFlag\ndef to_OptimizationFlag(level):\n    \"\"\"Convert strings and int to a valid OptimizationFlag.\"\"\"",
    "search_text": "tenpy.tools.optimization.to_optimizationflag # api function: tenpy.tools.optimization.to_optimizationflag\ndef to_optimizationflag(level):\n    \"\"\"convert strings and int to a valid optimizationflag.\"\"\" function to_optimizationflag",
    "tokens": 35
  },
  {
    "category": "api",
    "name": "tenpy.tools.optimization.set_level",
    "content": "# API Function: tenpy.tools.optimization.set_level\ndef set_level(level=1):\n    \"\"\"Set the global optimization level.\"\"\"",
    "search_text": "tenpy.tools.optimization.set_level # api function: tenpy.tools.optimization.set_level\ndef set_level(level=1):\n    \"\"\"set the global optimization level.\"\"\" function set_level",
    "tokens": 27
  },
  {
    "category": "api",
    "name": "tenpy.tools.optimization.get_level",
    "content": "# API Function: tenpy.tools.optimization.get_level\ndef get_level():\n    \"\"\"Return the global optimization level.\"\"\"",
    "search_text": "tenpy.tools.optimization.get_level # api function: tenpy.tools.optimization.get_level\ndef get_level():\n    \"\"\"return the global optimization level.\"\"\" function get_level",
    "tokens": 24
  },
  {
    "category": "api",
    "name": "tenpy.tools.optimization.optimize",
    "content": "# API Function: tenpy.tools.optimization.optimize\ndef optimize(level_compare=OptimizationFlag.default):\n    \"\"\"Called by algorithms to check whether it should (try to) do some optimizations.\"\"\"",
    "search_text": "tenpy.tools.optimization.optimize # api function: tenpy.tools.optimization.optimize\ndef optimize(level_compare=optimizationflag.default):\n    \"\"\"called by algorithms to check whether it should (try to) do some optimizations.\"\"\" function optimize",
    "tokens": 39
  },
  {
    "category": "api",
    "name": "tenpy.tools.optimization.use_cython",
    "content": "# API Function: tenpy.tools.optimization.use_cython\ndef use_cython(func=None, replacement=None, check_doc=True):\n    \"\"\"Decorator to replace a function with a Cython-equivalent from _npc_helper.pyx.\"\"\"",
    "search_text": "tenpy.tools.optimization.use_cython # api function: tenpy.tools.optimization.use_cython\ndef use_cython(func=none, replacement=none, check_doc=true):\n    \"\"\"decorator to replace a function with a cython-equivalent from _npc_helper.pyx.\"\"\" function use_cython",
    "tokens": 47
  },
  {
    "category": "api",
    "name": "tenpy.tools.fit.alg_decay",
    "content": "# API Function: tenpy.tools.fit.alg_decay\ndef alg_decay(x, a, b, c):\n    \"\"\"Algebraic decay function :math :`a * x^{-b} + c`.\"\"\"",
    "search_text": "tenpy.tools.fit.alg_decay # api function: tenpy.tools.fit.alg_decay\ndef alg_decay(x, a, b, c):\n    \"\"\"algebraic decay function :math :`a * x^{-b} + c`.\"\"\" function alg_decay",
    "tokens": 44
  },
  {
    "category": "api",
    "name": "tenpy.tools.fit.linear_fit",
    "content": "# API Function: tenpy.tools.fit.linear_fit\ndef linear_fit(x, y):\n    \"\"\"Perform a linear fit `y` ~ `a * x + b`.\"\"\"",
    "search_text": "tenpy.tools.fit.linear_fit # api function: tenpy.tools.fit.linear_fit\ndef linear_fit(x, y):\n    \"\"\"perform a linear fit `y` ~ `a * x + b`.\"\"\" function linear_fit",
    "tokens": 36
  },
  {
    "category": "api",
    "name": "tenpy.tools.fit.lin_fit_res",
    "content": "# API Function: tenpy.tools.fit.lin_fit_res\ndef lin_fit_res(x, y):\n    \"\"\"Returns the least-square residue of a linear fit y vs x.\"\"\"",
    "search_text": "tenpy.tools.fit.lin_fit_res # api function: tenpy.tools.fit.lin_fit_res\ndef lin_fit_res(x, y):\n    \"\"\"returns the least-square residue of a linear fit y vs x.\"\"\" function lin_fit_res",
    "tokens": 35
  },
  {
    "category": "api",
    "name": "tenpy.tools.fit.alg_decay_fit_res",
    "content": "# API Function: tenpy.tools.fit.alg_decay_fit_res\ndef alg_decay_fit_res(log_b, x, y):\n    \"\"\"Returns the residue of an algebraic decay fit of the form ``x**(-np.exp(log_b))``.\"\"\"",
    "search_text": "tenpy.tools.fit.alg_decay_fit_res # api function: tenpy.tools.fit.alg_decay_fit_res\ndef alg_decay_fit_res(log_b, x, y):\n    \"\"\"returns the residue of an algebraic decay fit of the form ``x**(-np.exp(log_b))``.\"\"\" function alg_decay_fit_res",
    "tokens": 51
  },
  {
    "category": "api",
    "name": "tenpy.tools.fit.alg_decay_fit",
    "content": "# API Function: tenpy.tools.fit.alg_decay_fit\ndef alg_decay_fit(x, y, npts=5, power_range=(0.01, 4.0), power_mesh=[60, 10]):\n    \"\"\"Fit `y` to an algebraic decay of the form :math :`a * x^{-b} + c`.\"\"\"",
    "search_text": "tenpy.tools.fit.alg_decay_fit # api function: tenpy.tools.fit.alg_decay_fit\ndef alg_decay_fit(x, y, npts=5, power_range=(0.01, 4.0), power_mesh=[60, 10]):\n    \"\"\"fit `y` to an algebraic decay of the form :math :`a * x^{-b} + c`.\"\"\" function alg_decay_fit",
    "tokens": 74
  },
  {
    "category": "api",
    "name": "tenpy.tools.fit.alg_decay_fits",
    "content": "# API Function: tenpy.tools.fit.alg_decay_fits\ndef alg_decay_fits(x, ys, npts=5, power_range=(0.01, 4.0), power_mesh=[60, 10]):\n    \"\"\"Batched version of :func:`~tenpy.tools.fit.alg_decay`.\"\"\"",
    "search_text": "tenpy.tools.fit.alg_decay_fits # api function: tenpy.tools.fit.alg_decay_fits\ndef alg_decay_fits(x, ys, npts=5, power_range=(0.01, 4.0), power_mesh=[60, 10]):\n    \"\"\"batched version of :func:`~tenpy.tools.fit.alg_decay`.\"\"\" function alg_decay_fits",
    "tokens": 66
  },
  {
    "category": "api",
    "name": "tenpy.tools.fit.plot_alg_decay_fit",
    "content": "# API Function: tenpy.tools.fit.plot_alg_decay_fit\ndef plot_alg_decay_fit(plot_module, x, y, fit_par, xfunc=None, kwargs={}, plot_fit_args={}):\n    \"\"\"Utility function used the plot an algebraic fit function next to the data.\"\"\"",
    "search_text": "tenpy.tools.fit.plot_alg_decay_fit # api function: tenpy.tools.fit.plot_alg_decay_fit\ndef plot_alg_decay_fit(plot_module, x, y, fit_par, xfunc=none, kwargs={}, plot_fit_args={}):\n    \"\"\"utility function used the plot an algebraic fit function next to the data.\"\"\" function plot_alg_decay_fit",
    "tokens": 56
  },
  {
    "category": "api",
    "name": "tenpy.tools.fit.fit_with_sum_of_exp",
    "content": "# API Function: tenpy.tools.fit.fit_with_sum_of_exp\ndef fit_with_sum_of_exp(f, n, N=50):\n    \"\"\"Approximate a decaying function `f` with a sum of exponentials.\"\"\"",
    "search_text": "tenpy.tools.fit.fit_with_sum_of_exp # api function: tenpy.tools.fit.fit_with_sum_of_exp\ndef fit_with_sum_of_exp(f, n, n=50):\n    \"\"\"approximate a decaying function `f` with a sum of exponentials.\"\"\" function fit_with_sum_of_exp",
    "tokens": 46
  },
  {
    "category": "api",
    "name": "tenpy.tools.fit.sum_of_exp",
    "content": "# API Function: tenpy.tools.fit.sum_of_exp\ndef sum_of_exp(lambdas, prefactors, x):\n    \"\"\"Evaluate ``sum_i prefactor[i] * lambda[i]**x`` for different `x`.\"\"\"",
    "search_text": "tenpy.tools.fit.sum_of_exp # api function: tenpy.tools.fit.sum_of_exp\ndef sum_of_exp(lambdas, prefactors, x):\n    \"\"\"evaluate ``sum_i prefactor[i] * lambda[i]**x`` for different `x`.\"\"\" function sum_of_exp",
    "tokens": 47
  },
  {
    "category": "api",
    "name": "tenpy.tools.fit.entropy_profile_from_CFT",
    "content": "# API Function: tenpy.tools.fit.entropy_profile_from_CFT\ndef entropy_profile_from_CFT(size_A, L, central_charge, const):\n    \"\"\"Expected profile for the entanglement entropy at a critical point.\"\"\"",
    "search_text": "tenpy.tools.fit.entropy_profile_from_cft # api function: tenpy.tools.fit.entropy_profile_from_cft\ndef entropy_profile_from_cft(size_a, l, central_charge, const):\n    \"\"\"expected profile for the entanglement entropy at a critical point.\"\"\" function entropy_profile_from_cft",
    "tokens": 46
  },
  {
    "category": "api",
    "name": "tenpy.tools.fit.central_charge_from_S_profile",
    "content": "# API Function: tenpy.tools.fit.central_charge_from_S_profile\ndef central_charge_from_S_profile(psi, exclude=None):\n    \"\"\"Fit the entanglement entropy of a finite MPS to the expected profile for critical models.\"\"\"",
    "search_text": "tenpy.tools.fit.central_charge_from_s_profile # api function: tenpy.tools.fit.central_charge_from_s_profile\ndef central_charge_from_s_profile(psi, exclude=none):\n    \"\"\"fit the entanglement entropy of a finite mps to the expected profile for critical models.\"\"\" function central_charge_from_s_profile",
    "tokens": 46
  },
  {
    "category": "api",
    "name": "tenpy.tools.spectral_function_tools.spectral_function",
    "content": "# API Function: tenpy.tools.spectral_function_tools.spectral_function\ndef spectral_function(time_dep_corr, lat, dt: float, gaussian_window: bool=False, sigma: float=0.4, linear_predict: bool=False, rel_prediction_time: float=1, rel_num_points: float=0.3, truncation_mode: str='renormalize', rel_split: float=0, axis_time: int=0, axis_space: int=1):\n    \"\"\"Given a time dependent correlation function C(t, r), calculate its Spectral Function.\"\"\"",
    "search_text": "tenpy.tools.spectral_function_tools.spectral_function # api function: tenpy.tools.spectral_function_tools.spectral_function\ndef spectral_function(time_dep_corr, lat, dt: float, gaussian_window: bool=false, sigma: float=0.4, linear_predict: bool=false, rel_prediction_time: float=1, rel_num_points: float=0.3, truncation_mode: str='renormalize', rel_split: float=0, axis_time: int=0, axis_space: int=1):\n    \"\"\"given a time dependent correlation function c(t, r), calculate its spectral function.\"\"\" function spectral_function",
    "tokens": 116
  },
  {
    "category": "api",
    "name": "tenpy.tools.spectral_function_tools.fourier_transform_space",
    "content": "# API Function: tenpy.tools.spectral_function_tools.fourier_transform_space\ndef fourier_transform_space(lat, a, axis=1): pass",
    "search_text": "tenpy.tools.spectral_function_tools.fourier_transform_space # api function: tenpy.tools.spectral_function_tools.fourier_transform_space\ndef fourier_transform_space(lat, a, axis=1): pass function fourier_transform_space",
    "tokens": 31
  },
  {
    "category": "api",
    "name": "tenpy.tools.spectral_function_tools.fourier_transform_time",
    "content": "# API Function: tenpy.tools.spectral_function_tools.fourier_transform_time\ndef fourier_transform_time(a, dt, axis=0): pass",
    "search_text": "tenpy.tools.spectral_function_tools.fourier_transform_time # api function: tenpy.tools.spectral_function_tools.fourier_transform_time\ndef fourier_transform_time(a, dt, axis=0): pass function fourier_transform_time",
    "tokens": 31
  },
  {
    "category": "api",
    "name": "tenpy.tools.spectral_function_tools.apply_gaussian_windowing",
    "content": "# API Function: tenpy.tools.spectral_function_tools.apply_gaussian_windowing\ndef apply_gaussian_windowing(a, sigma: float=0.4, axis=0):\n    \"\"\"Simple gaussian windowing function along an axes.\"\"\"",
    "search_text": "tenpy.tools.spectral_function_tools.apply_gaussian_windowing # api function: tenpy.tools.spectral_function_tools.apply_gaussian_windowing\ndef apply_gaussian_windowing(a, sigma: float=0.4, axis=0):\n    \"\"\"simple gaussian windowing function along an axes.\"\"\" function apply_gaussian_windowing",
    "tokens": 48
  },
  {
    "category": "api",
    "name": "tenpy.tools.spectral_function_tools.to_mps_geometry",
    "content": "# API Function: tenpy.tools.spectral_function_tools.to_mps_geometry\ndef to_mps_geometry(lat, a):\n    \"\"\"Bring measurement in lattice geometry to mps geometry.\"\"\"",
    "search_text": "tenpy.tools.spectral_function_tools.to_mps_geometry # api function: tenpy.tools.spectral_function_tools.to_mps_geometry\ndef to_mps_geometry(lat, a):\n    \"\"\"bring measurement in lattice geometry to mps geometry.\"\"\" function to_mps_geometry",
    "tokens": 37
  },
  {
    "category": "api",
    "name": "tenpy.tools.spectral_function_tools.plot_correlations_on_lattice",
    "content": "# API Function: tenpy.tools.spectral_function_tools.plot_correlations_on_lattice\ndef plot_correlations_on_lattice(ax, lat, correlations, pairs='nearest_neighbors', scale=1, color_pos='r', color_neg='g', color=None, zorder=0):\n    \"\"\"Function to plot correlations on a lattice.\"\"\"",
    "search_text": "tenpy.tools.spectral_function_tools.plot_correlations_on_lattice # api function: tenpy.tools.spectral_function_tools.plot_correlations_on_lattice\ndef plot_correlations_on_lattice(ax, lat, correlations, pairs='nearest_neighbors', scale=1, color_pos='r', color_neg='g', color=none, zorder=0):\n    \"\"\"function to plot correlations on a lattice.\"\"\" function plot_correlations_on_lattice",
    "tokens": 68
  },
  {
    "category": "api",
    "name": "tenpy.tools.string.is_non_string_iterable",
    "content": "# API Function: tenpy.tools.string.is_non_string_iterable\ndef is_non_string_iterable(x):\n    \"\"\"Check if x is a non-string iterable, (e.g., list, tuple, dictionary, np.ndarray)\"\"\"",
    "search_text": "tenpy.tools.string.is_non_string_iterable # api function: tenpy.tools.string.is_non_string_iterable\ndef is_non_string_iterable(x):\n    \"\"\"check if x is a non-string iterable, (e.g., list, tuple, dictionary, np.ndarray)\"\"\" function is_non_string_iterable",
    "tokens": 47
  },
  {
    "category": "api",
    "name": "tenpy.tools.string.vert_join",
    "content": "# API Function: tenpy.tools.string.vert_join\ndef vert_join(strlist, valign='t', halign='l', delim=' '):\n    \"\"\"Join multiline strings vertically such that they appear next to each other.\"\"\"",
    "search_text": "tenpy.tools.string.vert_join # api function: tenpy.tools.string.vert_join\ndef vert_join(strlist, valign='t', halign='l', delim=' '):\n    \"\"\"join multiline strings vertically such that they appear next to each other.\"\"\" function vert_join",
    "tokens": 45
  },
  {
    "category": "api",
    "name": "tenpy.tools.string.join_as_many_as_possible",
    "content": "# API Function: tenpy.tools.string.join_as_many_as_possible\ndef join_as_many_as_possible(msgs: Sequence[str], separator: str, priorities: Sequence[int]=None, max_len: int=None, fill: str='...'):\n    \"\"\"Like ``separator.join(msgs)`` but truncated if the result is too long.\"\"\"",
    "search_text": "tenpy.tools.string.join_as_many_as_possible # api function: tenpy.tools.string.join_as_many_as_possible\ndef join_as_many_as_possible(msgs: sequence[str], separator: str, priorities: sequence[int]=none, max_len: int=none, fill: str='...'):\n    \"\"\"like ``separator.join(msgs)`` but truncated if the result is too long.\"\"\" function join_as_many_as_possible",
    "tokens": 68
  },
  {
    "category": "api",
    "name": "tenpy.tools.string.to_mathematica_lists",
    "content": "# API Function: tenpy.tools.string.to_mathematica_lists\ndef to_mathematica_lists(a):\n    \"\"\"Convert nested `a` to string readable by mathematica using curly brackets '{...}'.\"\"\"",
    "search_text": "tenpy.tools.string.to_mathematica_lists # api function: tenpy.tools.string.to_mathematica_lists\ndef to_mathematica_lists(a):\n    \"\"\"convert nested `a` to string readable by mathematica using curly brackets '{...}'.\"\"\" function to_mathematica_lists",
    "tokens": 42
  },
  {
    "category": "api",
    "name": "tenpy.tools.string.format_like_list",
    "content": "# API Function: tenpy.tools.string.format_like_list\ndef format_like_list(it):\n    \"\"\"Format elements of an iterable as if it were a plain list.\"\"\"",
    "search_text": "tenpy.tools.string.format_like_list # api function: tenpy.tools.string.format_like_list\ndef format_like_list(it):\n    \"\"\"format elements of an iterable as if it were a plain list.\"\"\" function format_like_list",
    "tokens": 33
  },
  {
    "category": "api",
    "name": "tenpy.tools.math.matvec_to_array",
    "content": "# API Function: tenpy.tools.math.matvec_to_array\ndef matvec_to_array(H):\n    \"\"\"Transform an linear operator with a `matvec` method into a dense numpy array.\"\"\"",
    "search_text": "tenpy.tools.math.matvec_to_array # api function: tenpy.tools.math.matvec_to_array\ndef matvec_to_array(h):\n    \"\"\"transform an linear operator with a `matvec` method into a dense numpy array.\"\"\" function matvec_to_array",
    "tokens": 39
  },
  {
    "category": "api",
    "name": "tenpy.tools.math.entropy",
    "content": "# API Function: tenpy.tools.math.entropy\ndef entropy(p, n=1):\n    \"\"\"Calculate the entropy of a distribution.\"\"\"",
    "search_text": "tenpy.tools.math.entropy # api function: tenpy.tools.math.entropy\ndef entropy(p, n=1):\n    \"\"\"calculate the entropy of a distribution.\"\"\" function entropy",
    "tokens": 28
  },
  {
    "category": "api",
    "name": "tenpy.tools.math.gcd",
    "content": "# API Function: tenpy.tools.math.gcd\ndef gcd(a, b):\n    \"\"\"Computes the greatest common divisor (GCD) of two numbers.\"\"\"",
    "search_text": "tenpy.tools.math.gcd # api function: tenpy.tools.math.gcd\ndef gcd(a, b):\n    \"\"\"computes the greatest common divisor (gcd) of two numbers.\"\"\" function gcd",
    "tokens": 33
  },
  {
    "category": "api",
    "name": "tenpy.tools.math.gcd_array",
    "content": "# API Function: tenpy.tools.math.gcd_array\ndef gcd_array(a):\n    \"\"\"Return the greatest common divisor of all of entries in `a`\"\"\"",
    "search_text": "tenpy.tools.math.gcd_array # api function: tenpy.tools.math.gcd_array\ndef gcd_array(a):\n    \"\"\"return the greatest common divisor of all of entries in `a`\"\"\" function gcd_array",
    "tokens": 33
  },
  {
    "category": "api",
    "name": "tenpy.tools.math.lcm",
    "content": "# API Function: tenpy.tools.math.lcm\ndef lcm(a, b):\n    \"\"\"Returns the least common multiple (LCM) of two positive numbers.\"\"\"",
    "search_text": "tenpy.tools.math.lcm # api function: tenpy.tools.math.lcm\ndef lcm(a, b):\n    \"\"\"returns the least common multiple (lcm) of two positive numbers.\"\"\" function lcm",
    "tokens": 33
  },
  {
    "category": "api",
    "name": "tenpy.tools.math.speigs",
    "content": "# API Function: tenpy.tools.math.speigs\ndef speigs(A, k, *args, **kwargs):\n    \"\"\"Wrapper around :func:`scipy.sparse.linalg.eigs`, lifting the restriction ``k < rank(A)-1``.\"\"\"",
    "search_text": "tenpy.tools.math.speigs # api function: tenpy.tools.math.speigs\ndef speigs(a, k, *args, **kwargs):\n    \"\"\"wrapper around :func:`scipy.sparse.linalg.eigs`, lifting the restriction ``k < rank(a)-1``.\"\"\" function speigs",
    "tokens": 51
  },
  {
    "category": "api",
    "name": "tenpy.tools.math.speigsh",
    "content": "# API Function: tenpy.tools.math.speigsh\ndef speigsh(A, k, *args, **kwargs):\n    \"\"\"Wrapper around :func:`scipy.sparse.linalg.eigsh`, lifting the restriction ``k < rank(A)-1``.\"\"\"",
    "search_text": "tenpy.tools.math.speigsh # api function: tenpy.tools.math.speigsh\ndef speigsh(a, k, *args, **kwargs):\n    \"\"\"wrapper around :func:`scipy.sparse.linalg.eigsh`, lifting the restriction ``k < rank(a)-1``.\"\"\" function speigsh",
    "tokens": 54
  },
  {
    "category": "api",
    "name": "tenpy.tools.math.perm_sign",
    "content": "# API Function: tenpy.tools.math.perm_sign\ndef perm_sign(p):\n    \"\"\"Given a permutation `p` of numbers, returns its sign. (+1 or -1)\"\"\"",
    "search_text": "tenpy.tools.math.perm_sign # api function: tenpy.tools.math.perm_sign\ndef perm_sign(p):\n    \"\"\"given a permutation `p` of numbers, returns its sign. (+1 or -1)\"\"\" function perm_sign",
    "tokens": 38
  },
  {
    "category": "api",
    "name": "tenpy.tools.math.qr_li",
    "content": "# API Function: tenpy.tools.math.qr_li\ndef qr_li(A, cutoff=1e-15):\n    \"\"\"QR decomposition with cutoff to discard nearly linear dependent columns in `Q`.\"\"\"",
    "search_text": "tenpy.tools.math.qr_li # api function: tenpy.tools.math.qr_li\ndef qr_li(a, cutoff=1e-15):\n    \"\"\"qr decomposition with cutoff to discard nearly linear dependent columns in `q`.\"\"\" function qr_li",
    "tokens": 41
  },
  {
    "category": "api",
    "name": "tenpy.tools.math.rq_li",
    "content": "# API Function: tenpy.tools.math.rq_li\ndef rq_li(A, cutoff=1e-15):\n    \"\"\"RQ decomposition with cutoff to discard nearly linear dependent columns in `Q`.\"\"\"",
    "search_text": "tenpy.tools.math.rq_li # api function: tenpy.tools.math.rq_li\ndef rq_li(a, cutoff=1e-15):\n    \"\"\"rq decomposition with cutoff to discard nearly linear dependent columns in `q`.\"\"\" function rq_li",
    "tokens": 42
  },
  {
    "category": "api",
    "name": "tenpy.tools.docs.amend_parent_docstring",
    "content": "# API Function: tenpy.tools.docs.amend_parent_docstring\ndef amend_parent_docstring(parent, insert_at: str='Parameters\\n', insert_before: bool=True):\n    \"\"\"Return a decorator that facilitates docstring generation.\"\"\"",
    "search_text": "tenpy.tools.docs.amend_parent_docstring # api function: tenpy.tools.docs.amend_parent_docstring\ndef amend_parent_docstring(parent, insert_at: str='parameters\\n', insert_before: bool=true):\n    \"\"\"return a decorator that facilitates docstring generation.\"\"\" function amend_parent_docstring",
    "tokens": 46
  },
  {
    "category": "api",
    "name": "tenpy.tools.misc.to_iterable",
    "content": "# API Function: tenpy.tools.misc.to_iterable\ndef to_iterable(a):\n    \"\"\"If `a` is a not iterable or a string, return ``[a]``, else return ``a``.\"\"\"",
    "search_text": "tenpy.tools.misc.to_iterable # api function: tenpy.tools.misc.to_iterable\ndef to_iterable(a):\n    \"\"\"if `a` is a not iterable or a string, return ``[a]``, else return ``a``.\"\"\" function to_iterable",
    "tokens": 44
  },
  {
    "category": "api",
    "name": "tenpy.tools.misc.to_iterable_of_len",
    "content": "# API Function: tenpy.tools.misc.to_iterable_of_len\ndef to_iterable_of_len(a, L):\n    \"\"\"If a is a non-string iterable of length `L`, return `a`, otherwise return [a]*L.\"\"\"",
    "search_text": "tenpy.tools.misc.to_iterable_of_len # api function: tenpy.tools.misc.to_iterable_of_len\ndef to_iterable_of_len(a, l):\n    \"\"\"if a is a non-string iterable of length `l`, return `a`, otherwise return [a]*l.\"\"\" function to_iterable_of_len",
    "tokens": 49
  },
  {
    "category": "api",
    "name": "tenpy.tools.misc.to_array",
    "content": "# API Function: tenpy.tools.misc.to_array\ndef to_array(a, shape=(None,), dtype=None, allow_incommensurate=False):\n    \"\"\"Convert `a` to an numpy array and tile to matching dimension/shape.\"\"\"",
    "search_text": "tenpy.tools.misc.to_array # api function: tenpy.tools.misc.to_array\ndef to_array(a, shape=(none,), dtype=none, allow_incommensurate=false):\n    \"\"\"convert `a` to an numpy array and tile to matching dimension/shape.\"\"\" function to_array",
    "tokens": 48
  },
  {
    "category": "api",
    "name": "tenpy.tools.misc.anynan",
    "content": "# API Function: tenpy.tools.misc.anynan\ndef anynan(a):\n    \"\"\"Check whether any entry of a ndarray `a` is 'NaN'.\"\"\"",
    "search_text": "tenpy.tools.misc.anynan # api function: tenpy.tools.misc.anynan\ndef anynan(a):\n    \"\"\"check whether any entry of a ndarray `a` is 'nan'.\"\"\" function anynan",
    "tokens": 34
  },
  {
    "category": "api",
    "name": "tenpy.tools.misc.anynan",
    "content": "# API Function: tenpy.tools.misc.anynan\ndef anynan(a):\n    \"\"\"Check whether any entry of a ndarray `a` is 'NaN'.\"\"\"",
    "search_text": "tenpy.tools.misc.anynan # api function: tenpy.tools.misc.anynan\ndef anynan(a):\n    \"\"\"check whether any entry of a ndarray `a` is 'nan'.\"\"\" function anynan",
    "tokens": 34
  },
  {
    "category": "api",
    "name": "tenpy.tools.misc.argsort",
    "content": "# API Function: tenpy.tools.misc.argsort\ndef argsort(a, sort=None, **kwargs):\n    \"\"\"Wrapper around np.argsort to allow sorting ascending/descending and by magnitude.\"\"\"",
    "search_text": "tenpy.tools.misc.argsort # api function: tenpy.tools.misc.argsort\ndef argsort(a, sort=none, **kwargs):\n    \"\"\"wrapper around np.argsort to allow sorting ascending/descending and by magnitude.\"\"\" function argsort",
    "tokens": 38
  },
  {
    "category": "api",
    "name": "tenpy.tools.misc.lexsort",
    "content": "# API Function: tenpy.tools.misc.lexsort\ndef lexsort(a, axis=-1):\n    \"\"\"Wrapper around ``np.lexsort``: allow for trivial case ``a.shape[0] = 0`` without sorting\"\"\"",
    "search_text": "tenpy.tools.misc.lexsort # api function: tenpy.tools.misc.lexsort\ndef lexsort(a, axis=-1):\n    \"\"\"wrapper around ``np.lexsort``: allow for trivial case ``a.shape[0] = 0`` without sorting\"\"\" function lexsort",
    "tokens": 47
  },
  {
    "category": "api",
    "name": "tenpy.tools.misc.inverse_permutation",
    "content": "# API Function: tenpy.tools.misc.inverse_permutation\ndef inverse_permutation(perm):\n    \"\"\"Reverse sorting indices.\"\"\"",
    "search_text": "tenpy.tools.misc.inverse_permutation # api function: tenpy.tools.misc.inverse_permutation\ndef inverse_permutation(perm):\n    \"\"\"reverse sorting indices.\"\"\" function inverse_permutation",
    "tokens": 25
  },
  {
    "category": "api",
    "name": "tenpy.tools.misc.list_to_dict_list",
    "content": "# API Function: tenpy.tools.misc.list_to_dict_list\ndef list_to_dict_list(l):\n    \"\"\"Given a list `l` of objects, construct a lookup table.\"\"\"",
    "search_text": "tenpy.tools.misc.list_to_dict_list # api function: tenpy.tools.misc.list_to_dict_list\ndef list_to_dict_list(l):\n    \"\"\"given a list `l` of objects, construct a lookup table.\"\"\" function list_to_dict_list",
    "tokens": 36
  },
  {
    "category": "api",
    "name": "tenpy.tools.misc.atleast_2d_pad",
    "content": "# API Function: tenpy.tools.misc.atleast_2d_pad\ndef atleast_2d_pad(a, pad_item=0):\n    \"\"\"Transform `a` into a 2D array, filling missing places with `pad_item`.\"\"\"",
    "search_text": "tenpy.tools.misc.atleast_2d_pad # api function: tenpy.tools.misc.atleast_2d_pad\ndef atleast_2d_pad(a, pad_item=0):\n    \"\"\"transform `a` into a 2d array, filling missing places with `pad_item`.\"\"\" function atleast_2d_pad",
    "tokens": 50
  },
  {
    "category": "api",
    "name": "tenpy.tools.misc.transpose_list_list",
    "content": "# API Function: tenpy.tools.misc.transpose_list_list\ndef transpose_list_list(D, pad=None):\n    \"\"\"Returns a list of lists T, such that ``T[i][j] = D[j][i]``.\"\"\"",
    "search_text": "tenpy.tools.misc.transpose_list_list # api function: tenpy.tools.misc.transpose_list_list\ndef transpose_list_list(d, pad=none):\n    \"\"\"returns a list of lists t, such that ``t[i][j] = d[j][i]``.\"\"\" function transpose_list_list",
    "tokens": 46
  },
  {
    "category": "api",
    "name": "tenpy.tools.misc.zero_if_close",
    "content": "# API Function: tenpy.tools.misc.zero_if_close\ndef zero_if_close(a, tol=1e-15):\n    \"\"\"Set real and/or imaginary part to 0 if their absolute value is smaller than `tol`.\"\"\"",
    "search_text": "tenpy.tools.misc.zero_if_close # api function: tenpy.tools.misc.zero_if_close\ndef zero_if_close(a, tol=1e-15):\n    \"\"\"set real and/or imaginary part to 0 if their absolute value is smaller than `tol`.\"\"\" function zero_if_close",
    "tokens": 47
  },
  {
    "category": "api",
    "name": "tenpy.tools.misc.pad",
    "content": "# API Function: tenpy.tools.misc.pad\ndef pad(a, w_l=0, v_l=0, w_r=0, v_r=0, axis=0):\n    \"\"\"Pad an array along a given `axis`.\"\"\"",
    "search_text": "tenpy.tools.misc.pad # api function: tenpy.tools.misc.pad\ndef pad(a, w_l=0, v_l=0, w_r=0, v_r=0, axis=0):\n    \"\"\"pad an array along a given `axis`.\"\"\" function pad",
    "tokens": 50
  },
  {
    "category": "api",
    "name": "tenpy.tools.misc.add_with_None_0",
    "content": "# API Function: tenpy.tools.misc.add_with_None_0\ndef add_with_None_0(a, b):\n    \"\"\"Return ``a + b``, treating `None` as zero.\"\"\"",
    "search_text": "tenpy.tools.misc.add_with_none_0 # api function: tenpy.tools.misc.add_with_none_0\ndef add_with_none_0(a, b):\n    \"\"\"return ``a + b``, treating `none` as zero.\"\"\" function add_with_none_0",
    "tokens": 39
  },
  {
    "category": "api",
    "name": "tenpy.tools.misc.group_by_degeneracy",
    "content": "# API Function: tenpy.tools.misc.group_by_degeneracy\ndef group_by_degeneracy(E, *args):\n    \"\"\"Find groups of indices for which (energy) values are degenerate.\"\"\"",
    "search_text": "tenpy.tools.misc.group_by_degeneracy # api function: tenpy.tools.misc.group_by_degeneracy\ndef group_by_degeneracy(e, *args):\n    \"\"\"find groups of indices for which (energy) values are degenerate.\"\"\" function group_by_degeneracy",
    "tokens": 41
  },
  {
    "category": "api",
    "name": "tenpy.tools.misc.get_close",
    "content": "# API Function: tenpy.tools.misc.get_close\ndef get_close(values, target, default=None, eps=1e-13):\n    \"\"\"Iterate through `values` and return first entry closer than `eps`.\"\"\"",
    "search_text": "tenpy.tools.misc.get_close # api function: tenpy.tools.misc.get_close\ndef get_close(values, target, default=none, eps=1e-13):\n    \"\"\"iterate through `values` and return first entry closer than `eps`.\"\"\" function get_close",
    "tokens": 46
  },
  {
    "category": "api",
    "name": "tenpy.tools.misc.find_subclass",
    "content": "# API Function: tenpy.tools.misc.find_subclass\ndef find_subclass(base_class, subclass_name):\n    \"\"\"For a given base class, recursively find the subclass with the given name.\"\"\"",
    "search_text": "tenpy.tools.misc.find_subclass # api function: tenpy.tools.misc.find_subclass\ndef find_subclass(base_class, subclass_name):\n    \"\"\"for a given base class, recursively find the subclass with the given name.\"\"\" function find_subclass",
    "tokens": 39
  },
  {
    "category": "api",
    "name": "tenpy.tools.misc.get_recursive",
    "content": "# API Function: tenpy.tools.misc.get_recursive\ndef get_recursive(nested_data, recursive_key, separator='.', default=_UNSET):\n    \"\"\"Extract specific value from a nested data structure.\"\"\"",
    "search_text": "tenpy.tools.misc.get_recursive # api function: tenpy.tools.misc.get_recursive\ndef get_recursive(nested_data, recursive_key, separator='.', default=_unset):\n    \"\"\"extract specific value from a nested data structure.\"\"\" function get_recursive",
    "tokens": 40
  },
  {
    "category": "api",
    "name": "tenpy.tools.misc.set_recursive",
    "content": "# API Function: tenpy.tools.misc.set_recursive\ndef set_recursive(nested_data, recursive_key, value, separator='.', insert_dicts=False):\n    \"\"\"Same as :func:`get_recursive`, but set the data entry to `value`.\"\"\"",
    "search_text": "tenpy.tools.misc.set_recursive # api function: tenpy.tools.misc.set_recursive\ndef set_recursive(nested_data, recursive_key, value, separator='.', insert_dicts=false):\n    \"\"\"same as :func:`get_recursive`, but set the data entry to `value`.\"\"\" function set_recursive",
    "tokens": 50
  },
  {
    "category": "api",
    "name": "tenpy.tools.misc.update_recursive",
    "content": "# API Function: tenpy.tools.misc.update_recursive\ndef update_recursive(nested_data, update_data, separator='.', insert_dicts=True):\n    \"\"\"Wrapper around :func:`set_recursive` to allow updating multiple values at once.\"\"\"",
    "search_text": "tenpy.tools.misc.update_recursive # api function: tenpy.tools.misc.update_recursive\ndef update_recursive(nested_data, update_data, separator='.', insert_dicts=true):\n    \"\"\"wrapper around :func:`set_recursive` to allow updating multiple values at once.\"\"\" function update_recursive",
    "tokens": 46
  },
  {
    "category": "api",
    "name": "tenpy.tools.misc.merge_recursive",
    "content": "# API Function: tenpy.tools.misc.merge_recursive\ndef merge_recursive(*nested_data):\n    \"\"\"Merge nested dictionaries `nested1` and `nested2`.\"\"\"",
    "search_text": "tenpy.tools.misc.merge_recursive # api function: tenpy.tools.misc.merge_recursive\ndef merge_recursive(*nested_data):\n    \"\"\"merge nested dictionaries `nested1` and `nested2`.\"\"\" function merge_recursive",
    "tokens": 33
  },
  {
    "category": "api",
    "name": "tenpy.tools.misc.flatten",
    "content": "# API Function: tenpy.tools.misc.flatten\ndef flatten(mapping, separator='.'):\n    \"\"\"Obtain a flat dictionary with all key/value pairs of a nested data structure.\"\"\"",
    "search_text": "tenpy.tools.misc.flatten # api function: tenpy.tools.misc.flatten\ndef flatten(mapping, separator='.'):\n    \"\"\"obtain a flat dictionary with all key/value pairs of a nested data structure.\"\"\" function flatten",
    "tokens": 35
  },
  {
    "category": "api",
    "name": "tenpy.tools.misc.setup_logging",
    "content": "# API Function: tenpy.tools.misc.setup_logging\ndef setup_logging(output_filename=None):\n    \"\"\"Configure the :mod:`logging` module.\"\"\"",
    "search_text": "tenpy.tools.misc.setup_logging # api function: tenpy.tools.misc.setup_logging\ndef setup_logging(output_filename=none):\n    \"\"\"configure the :mod:`logging` module.\"\"\" function setup_logging",
    "tokens": 29
  },
  {
    "category": "api",
    "name": "tenpy.tools.misc.convert_memory_units",
    "content": "# API Function: tenpy.tools.misc.convert_memory_units\ndef convert_memory_units(value, unit_from='bytes', unit_to=None):\n    \"\"\"Convert between different memory units.\"\"\"",
    "search_text": "tenpy.tools.misc.convert_memory_units # api function: tenpy.tools.misc.convert_memory_units\ndef convert_memory_units(value, unit_from='bytes', unit_to=none):\n    \"\"\"convert between different memory units.\"\"\" function convert_memory_units",
    "tokens": 35
  },
  {
    "category": "api",
    "name": "tenpy.tools.misc.TenpyInconsistencyError",
    "content": "# API Definition: tenpy.tools.misc.TenpyInconsistencyError\nclass TenpyInconsistencyError:\n    \"\"\"Error class that is raised when a consistency check fails.\"\"\"\n",
    "search_text": "tenpy.tools.misc.tenpyinconsistencyerror # api definition: tenpy.tools.misc.tenpyinconsistencyerror\nclass tenpyinconsistencyerror:\n    \"\"\"error class that is raised when a consistency check fails.\"\"\"\n class tenpyinconsistencyerror tenpy.tools.misc",
    "tokens": 37
  },
  {
    "category": "api",
    "name": "tenpy.tools.misc.TenpyInconsistencyWarning",
    "content": "# API Definition: tenpy.tools.misc.TenpyInconsistencyWarning\nclass TenpyInconsistencyWarning:\n    \"\"\"Warning category that is emitted when a consistency check fails.\"\"\"\n",
    "search_text": "tenpy.tools.misc.tenpyinconsistencywarning # api definition: tenpy.tools.misc.tenpyinconsistencywarning\nclass tenpyinconsistencywarning:\n    \"\"\"warning category that is emitted when a consistency check fails.\"\"\"\n class tenpyinconsistencywarning tenpy.tools.misc",
    "tokens": 37
  },
  {
    "category": "api",
    "name": "tenpy.tools.misc.BetaWarning",
    "content": "# API Definition: tenpy.tools.misc.BetaWarning\nclass BetaWarning:\n    \"\"\"Warning category that we emit in new code that still needs to be tested better.\"\"\"\n",
    "search_text": "tenpy.tools.misc.betawarning # api definition: tenpy.tools.misc.betawarning\nclass betawarning:\n    \"\"\"warning category that we emit in new code that still needs to be tested better.\"\"\"\n class betawarning tenpy.tools.misc",
    "tokens": 34
  },
  {
    "category": "api",
    "name": "tenpy.tools.misc.consistency_check",
    "content": "# API Function: tenpy.tools.misc.consistency_check\ndef consistency_check(value, options, threshold_key, threshold_default, msg, compare='<='):\n    \"\"\"Perform a consistency check, raising an error if it is violated.\"\"\"",
    "search_text": "tenpy.tools.misc.consistency_check # api function: tenpy.tools.misc.consistency_check\ndef consistency_check(value, options, threshold_key, threshold_default, msg, compare='<='):\n    \"\"\"perform a consistency check, raising an error if it is violated.\"\"\" function consistency_check",
    "tokens": 46
  },
  {
    "category": "api",
    "name": "tenpy.tools.hdf5_io.parse_version",
    "content": "# API Function: tenpy.tools.hdf5_io.parse_version\ndef parse_version(version_str): pass",
    "search_text": "tenpy.tools.hdf5_io.parse_version # api function: tenpy.tools.hdf5_io.parse_version\ndef parse_version(version_str): pass function parse_version",
    "tokens": 21
  },
  {
    "category": "api",
    "name": "tenpy.tools.hdf5_io.save",
    "content": "# API Function: tenpy.tools.hdf5_io.save\ndef save(data, filename, mode='w'):\n    \"\"\"Save `data` to file with given `filename`.\"\"\"",
    "search_text": "tenpy.tools.hdf5_io.save # api function: tenpy.tools.hdf5_io.save\ndef save(data, filename, mode='w'):\n    \"\"\"save `data` to file with given `filename`.\"\"\" function save",
    "tokens": 37
  },
  {
    "category": "api",
    "name": "tenpy.tools.hdf5_io.load",
    "content": "# API Function: tenpy.tools.hdf5_io.load\ndef load(filename):\n    \"\"\"Load data from file with given `filename`.\"\"\"",
    "search_text": "tenpy.tools.hdf5_io.load # api function: tenpy.tools.hdf5_io.load\ndef load(filename):\n    \"\"\"load data from file with given `filename`.\"\"\" function load",
    "tokens": 29
  },
  {
    "category": "api",
    "name": "tenpy.tools.hdf5_io.find_global",
    "content": "# API Function: tenpy.tools.hdf5_io.find_global\ndef find_global(module, qualified_name):\n    \"\"\"Get the object of the `qualified_name` in a given python `module`.\"\"\"",
    "search_text": "tenpy.tools.hdf5_io.find_global # api function: tenpy.tools.hdf5_io.find_global\ndef find_global(module, qualified_name):\n    \"\"\"get the object of the `qualified_name` in a given python `module`.\"\"\" function find_global",
    "tokens": 41
  },
  {
    "category": "api",
    "name": "tenpy.tools.hdf5_io.valid_hdf5_path_component",
    "content": "# API Function: tenpy.tools.hdf5_io.valid_hdf5_path_component\ndef valid_hdf5_path_component(name):\n    \"\"\"Determine if `name` is a valid HDF5 path component.\"\"\"",
    "search_text": "tenpy.tools.hdf5_io.valid_hdf5_path_component # api function: tenpy.tools.hdf5_io.valid_hdf5_path_component\ndef valid_hdf5_path_component(name):\n    \"\"\"determine if `name` is a valid hdf5 path component.\"\"\" function valid_hdf5_path_component",
    "tokens": 43
  },
  {
    "category": "api",
    "name": "tenpy.tools.hdf5_io.Hdf5FormatError",
    "content": "# API Definition: tenpy.tools.hdf5_io.Hdf5FormatError\nclass Hdf5FormatError:\n    \"\"\"Common base class for errors regarding our HDF5 format.\"\"\"\n",
    "search_text": "tenpy.tools.hdf5_io.hdf5formaterror # api definition: tenpy.tools.hdf5_io.hdf5formaterror\nclass hdf5formaterror:\n    \"\"\"common base class for errors regarding our hdf5 format.\"\"\"\n class hdf5formaterror tenpy.tools.hdf5_io",
    "tokens": 37
  },
  {
    "category": "api",
    "name": "tenpy.tools.hdf5_io.Hdf5ExportError",
    "content": "# API Definition: tenpy.tools.hdf5_io.Hdf5ExportError\nclass Hdf5ExportError:\n    \"\"\"This exception is raised when something went wrong during export to hdf5.\"\"\"\n",
    "search_text": "tenpy.tools.hdf5_io.hdf5exporterror # api definition: tenpy.tools.hdf5_io.hdf5exporterror\nclass hdf5exporterror:\n    \"\"\"this exception is raised when something went wrong during export to hdf5.\"\"\"\n class hdf5exporterror tenpy.tools.hdf5_io",
    "tokens": 40
  },
  {
    "category": "api",
    "name": "tenpy.tools.hdf5_io.Hdf5ImportError",
    "content": "# API Definition: tenpy.tools.hdf5_io.Hdf5ImportError\nclass Hdf5ImportError:\n    \"\"\"This exception is raised when something went wrong during import from hdf5.\"\"\"\n",
    "search_text": "tenpy.tools.hdf5_io.hdf5importerror # api definition: tenpy.tools.hdf5_io.hdf5importerror\nclass hdf5importerror:\n    \"\"\"this exception is raised when something went wrong during import from hdf5.\"\"\"\n class hdf5importerror tenpy.tools.hdf5_io",
    "tokens": 40
  },
  {
    "category": "api",
    "name": "tenpy.tools.hdf5_io.Hdf5Exportable",
    "content": "# API Definition: tenpy.tools.hdf5_io.Hdf5Exportable\nclass Hdf5Exportable:\n    \"\"\"Interface specification for a class to be exportable to our HDF5 format.\"\"\"\n    def save_hdf5(self, hdf5_saver, h5gr, subpath):\n        \"\"\"Export `self` into a HDF5 file.\"\"\"\n    def from_hdf5(cls, hdf5_loader, h5gr, subpath):\n        \"\"\"Load instance from a HDF5 file.\"\"\"",
    "search_text": "tenpy.tools.hdf5_io.hdf5exportable # api definition: tenpy.tools.hdf5_io.hdf5exportable\nclass hdf5exportable:\n    \"\"\"interface specification for a class to be exportable to our hdf5 format.\"\"\"\n    def save_hdf5(self, hdf5_saver, h5gr, subpath):\n        \"\"\"export `self` into a hdf5 file.\"\"\"\n    def from_hdf5(cls, hdf5_loader, h5gr, subpath):\n        \"\"\"load instance from a hdf5 file.\"\"\" class hdf5exportable tenpy.tools.hdf5_io",
    "tokens": 102
  },
  {
    "category": "api",
    "name": "tenpy.tools.hdf5_io.Hdf5Ignored",
    "content": "# API Definition: tenpy.tools.hdf5_io.Hdf5Ignored\nclass Hdf5Ignored:\n    \"\"\"Placeholder for a dataset/group to be ignored during both loading and saving.\"\"\"\n    def __init__(self, name='unknown'): pass",
    "search_text": "tenpy.tools.hdf5_io.hdf5ignored # api definition: tenpy.tools.hdf5_io.hdf5ignored\nclass hdf5ignored:\n    \"\"\"placeholder for a dataset/group to be ignored during both loading and saving.\"\"\"\n    def __init__(self, name='unknown'): pass class hdf5ignored tenpy.tools.hdf5_io",
    "tokens": 52
  },
  {
    "category": "api",
    "name": "tenpy.tools.hdf5_io.Hdf5Saver",
    "content": "# API Definition: tenpy.tools.hdf5_io.Hdf5Saver\nclass Hdf5Saver:\n    \"\"\"Class to save simple enough objects into a HDF5 file.\"\"\"\n    def __init__(self, h5group, format_selection=None): pass\n    def save(self, obj, path='/'):\n        \"\"\"Save `obj` in ``self.h5group[path]``.\"\"\"\n    def create_group_for_obj(self, path, obj):\n        \"\"\"Create an HDF5 group ``self.h5group[path]`` to store `obj`.\"\"\"\n    def memorize_save(self, h5gr, obj):\n        \"\"\"Store objects already saved in the :attr:`memo_save`.\"\"\"\n    def save_reduce(self, func, args, state=None, listitems=None, dictitems=None, state_setter=None, obj=None, path=None):\n        \"\"\"Save the return values of ``obj.__reduce__`` following the pickle protocol.\"\"\"\n    def save_none(self, obj, path, type_repr):\n        \"\"\"Save the None object as a string (dataset); in dispatch table.\"\"\"\n    def save_dataset(self, obj, path, type_repr):\n        \"\"\"Save `obj` as a hdf5 dataset; in dispatch table.\"\"\"\n    def save_masked_array(self, obj, path, type_repr):\n        \"\"\"Save a (numpy) masked array.\"\"\"\n    def save_iterable(self, obj, path, type_repr):\n        \"\"\"Save an iterable `obj` like a list, tuple or set; in dispatch table.\"\"\"\n    def save_iterable_content(self, obj, h5gr, subpath):\n        \"\"\"Save contents of an iterable `obj` in the existing `h5gr`.\"\"\"\n    def save_dict(self, obj, path, type_repr):\n        \"\"\"Save the dictionary `obj`; in dispatch table.\"\"\"\n    def save_dict_content(self, obj, h5gr, subpath):\n        \"\"\"Save contents of a dictionary `obj` in the existing `h5gr`.\"\"\"\n    def save_range(self, obj, path, type_repr):\n        \"\"\"Save a range object; in dispatch table.\"\"\"\n    def save_dtype(self, obj, path, type_repr):\n        \"\"\"Save a :class:`~numpy.dtype` object; in dispatch table.\"\"\"\n    def save_ignored(self, obj, path, type_repr):\n        \"\"\"Don't save the Hdf5Ignored object; just return None.\"\"\"\n    def save_global(self, obj, path, type_repr):\n        \"\"\"Save a global object like a function or class.\"\"\"",
    "search_text": "tenpy.tools.hdf5_io.hdf5saver # api definition: tenpy.tools.hdf5_io.hdf5saver\nclass hdf5saver:\n    \"\"\"class to save simple enough objects into a hdf5 file.\"\"\"\n    def __init__(self, h5group, format_selection=none): pass\n    def save(self, obj, path='/'):\n        \"\"\"save `obj` in ``self.h5group[path]``.\"\"\"\n    def create_group_for_obj(self, path, obj):\n        \"\"\"create an hdf5 group ``self.h5group[path]`` to store `obj`.\"\"\"\n    def memorize_save(self, h5gr, obj):\n        \"\"\"store objects already saved in the :attr:`memo_save`.\"\"\"\n    def save_reduce(self, func, args, state=none, listitems=none, dictitems=none, state_setter=none, obj=none, path=none):\n        \"\"\"save the return values of ``obj.__reduce__`` following the pickle protocol.\"\"\"\n    def save_none(self, obj, path, type_repr):\n        \"\"\"save the none object as a string (dataset); in dispatch table.\"\"\"\n    def save_dataset(self, obj, path, type_repr):\n        \"\"\"save `obj` as a hdf5 dataset; in dispatch table.\"\"\"\n    def save_masked_array(self, obj, path, type_repr):\n        \"\"\"save a (numpy) masked array.\"\"\"\n    def save_iterable(self, obj, path, type_repr):\n        \"\"\"save an iterable `obj` like a list, tuple or set; in dispatch table.\"\"\"\n    def save_iterable_content(self, obj, h5gr, subpath):\n        \"\"\"save contents of an iterable `obj` in the existing `h5gr`.\"\"\"\n    def save_dict(self, obj, path, type_repr):\n        \"\"\"save the dictionary `obj`; in dispatch table.\"\"\"\n    def save_dict_content(self, obj, h5gr, subpath):\n        \"\"\"save contents of a dictionary `obj` in the existing `h5gr`.\"\"\"\n    def save_range(self, obj, path, type_repr):\n        \"\"\"save a range object; in dispatch table.\"\"\"\n    def save_dtype(self, obj, path, type_repr):\n        \"\"\"save a :class:`~numpy.dtype` object; in dispatch table.\"\"\"\n    def save_ignored(self, obj, path, type_repr):\n        \"\"\"don't save the hdf5ignored object; just return none.\"\"\"\n    def save_global(self, obj, path, type_repr):\n        \"\"\"save a global object like a function or class.\"\"\" class hdf5saver tenpy.tools.hdf5_io",
    "tokens": 514
  },
  {
    "category": "api",
    "name": "tenpy.tools.hdf5_io.Hdf5Loader",
    "content": "# API Definition: tenpy.tools.hdf5_io.Hdf5Loader\nclass Hdf5Loader:\n    \"\"\"Class to load and import object from a HDF5 file.\"\"\"\n    def __init__(self, h5group, ignore_unknown=True, exclude=None): pass\n    def load(self, path=None):\n        \"\"\"Load a Python :class:`object` from the dataset.\"\"\"\n    def memorize_load(self, h5gr, obj):\n        \"\"\"Store objects already loaded in the :attr:`memo_load`.\"\"\"\n    def get_all_hdf5_keys(self, h5_group=None):\n        \"\"\"Recursively display all keys in the given h5_group.\"\"\"\n    def get_attr(h5gr, attr_name):\n        \"\"\"Return attribute ``h5gr.attrs[attr_name]``, if existent.\"\"\"\n    def load_none(self, h5gr, type_info, subpath):\n        \"\"\"Load the ``None`` object from a dataset.\"\"\"\n    def load_dataset(self, h5gr, type_info, subpath):\n        \"\"\"Load a h5py :class:`Dataset` and convert it into the desired type.\"\"\"\n    def load_str(self, h5gr, type_info, subpath):\n        \"\"\"Load a string from a h5py :class:`Dataset`.\"\"\"\n    def load_converted_to_str(self, h5gr, type_info, subpath):\n        \"\"\"Load objects converted to string during save, in particular int > 2^64.\"\"\"\n    def load_masked_array(self, h5gr, type_info, subpath):\n        \"\"\"Load a masked array.\"\"\"\n    def load_list(self, h5gr, type_info, subpath):\n        \"\"\"Load a list.\"\"\"\n    def load_set(self, h5gr, type_info, subpath):\n        \"\"\"Load a set.\"\"\"\n    def load_tuple(self, h5gr, type_info, subpath):\n        \"\"\"Load a tuple.\"\"\"\n    def load_dict(self, h5gr, type_info, subpath):\n        \"\"\"Load a dictionary in the format according to `type_info`.\"\"\"\n    def load_general_dict(self, h5gr, type_info, subpath):\n        \"\"\"Load a dictionary with general keys.\"\"\"\n    def load_simple_dict(self, h5gr, type_info, subpath):\n        \"\"\"Load a dictionary with simple keys.\"\"\"\n    def load_range(self, h5gr, type_info, subpath):\n        \"\"\"Load a range.\"\"\"\n    def load_dtype(self, h5gr, type_info, subpath):\n        \"\"\"Load a :class:`numpy.dtype`.\"\"\"\n    def load_hdf5exportable(self, h5gr, type_info, subpath):\n        \"\"\"Load an instance of a userdefined class.\"\"\"\n    def load_ignored(self, h5gr, type_info, subpath):\n        \"\"\"Ignore the group to be loaded.\"\"\"\n    def load_global(self, h5gr, type_info, subpath):\n        \"\"\"Load a global object like a class or function from its qualified name and module.\"\"\"\n    def load_reduce(self, h5gr, type_info, subpath):\n        \"\"\"Load an object where the return values of  ``obj.__reduce__`` has been exported.\"\"\"",
    "search_text": "tenpy.tools.hdf5_io.hdf5loader # api definition: tenpy.tools.hdf5_io.hdf5loader\nclass hdf5loader:\n    \"\"\"class to load and import object from a hdf5 file.\"\"\"\n    def __init__(self, h5group, ignore_unknown=true, exclude=none): pass\n    def load(self, path=none):\n        \"\"\"load a python :class:`object` from the dataset.\"\"\"\n    def memorize_load(self, h5gr, obj):\n        \"\"\"store objects already loaded in the :attr:`memo_load`.\"\"\"\n    def get_all_hdf5_keys(self, h5_group=none):\n        \"\"\"recursively display all keys in the given h5_group.\"\"\"\n    def get_attr(h5gr, attr_name):\n        \"\"\"return attribute ``h5gr.attrs[attr_name]``, if existent.\"\"\"\n    def load_none(self, h5gr, type_info, subpath):\n        \"\"\"load the ``none`` object from a dataset.\"\"\"\n    def load_dataset(self, h5gr, type_info, subpath):\n        \"\"\"load a h5py :class:`dataset` and convert it into the desired type.\"\"\"\n    def load_str(self, h5gr, type_info, subpath):\n        \"\"\"load a string from a h5py :class:`dataset`.\"\"\"\n    def load_converted_to_str(self, h5gr, type_info, subpath):\n        \"\"\"load objects converted to string during save, in particular int > 2^64.\"\"\"\n    def load_masked_array(self, h5gr, type_info, subpath):\n        \"\"\"load a masked array.\"\"\"\n    def load_list(self, h5gr, type_info, subpath):\n        \"\"\"load a list.\"\"\"\n    def load_set(self, h5gr, type_info, subpath):\n        \"\"\"load a set.\"\"\"\n    def load_tuple(self, h5gr, type_info, subpath):\n        \"\"\"load a tuple.\"\"\"\n    def load_dict(self, h5gr, type_info, subpath):\n        \"\"\"load a dictionary in the format according to `type_info`.\"\"\"\n    def load_general_dict(self, h5gr, type_info, subpath):\n        \"\"\"load a dictionary with general keys.\"\"\"\n    def load_simple_dict(self, h5gr, type_info, subpath):\n        \"\"\"load a dictionary with simple keys.\"\"\"\n    def load_range(self, h5gr, type_info, subpath):\n        \"\"\"load a range.\"\"\"\n    def load_dtype(self, h5gr, type_info, subpath):\n        \"\"\"load a :class:`numpy.dtype`.\"\"\"\n    def load_hdf5exportable(self, h5gr, type_info, subpath):\n        \"\"\"load an instance of a userdefined class.\"\"\"\n    def load_ignored(self, h5gr, type_info, subpath):\n        \"\"\"ignore the group to be loaded.\"\"\"\n    def load_global(self, h5gr, type_info, subpath):\n        \"\"\"load a global object like a class or function from its qualified name and module.\"\"\"\n    def load_reduce(self, h5gr, type_info, subpath):\n        \"\"\"load an object where the return values of  ``obj.__reduce__`` has been exported.\"\"\" class hdf5loader tenpy.tools.hdf5_io",
    "tokens": 648
  },
  {
    "category": "api",
    "name": "tenpy.tools.hdf5_io.save_to_hdf5",
    "content": "# API Function: tenpy.tools.hdf5_io.save_to_hdf5\ndef save_to_hdf5(h5group, obj, path='/'):\n    \"\"\"Save an object `obj` into a hdf5 file or group.\"\"\"",
    "search_text": "tenpy.tools.hdf5_io.save_to_hdf5 # api function: tenpy.tools.hdf5_io.save_to_hdf5\ndef save_to_hdf5(h5group, obj, path='/'):\n    \"\"\"save an object `obj` into a hdf5 file or group.\"\"\" function save_to_hdf5",
    "tokens": 48
  },
  {
    "category": "api",
    "name": "tenpy.tools.hdf5_io.load_from_hdf5",
    "content": "# API Function: tenpy.tools.hdf5_io.load_from_hdf5\ndef load_from_hdf5(h5group, path=None, ignore_unknown=True, exclude=None):\n    \"\"\"Load an object from hdf5 file or group.\"\"\"",
    "search_text": "tenpy.tools.hdf5_io.load_from_hdf5 # api function: tenpy.tools.hdf5_io.load_from_hdf5\ndef load_from_hdf5(h5group, path=none, ignore_unknown=true, exclude=none):\n    \"\"\"load an object from hdf5 file or group.\"\"\" function load_from_hdf5",
    "tokens": 49
  },
  {
    "category": "api",
    "name": "tenpy.tools.params.Config",
    "content": "# API Definition: tenpy.tools.params.Config\nclass Config:\n    \"\"\"Dict-like wrapper class for parameter/configuration dictionaries.\"\"\"\n    def __init__(self, config, name): pass\n    def copy(self, share_unused=True):\n        \"\"\"Make a *shallow* copy, as for a dictionary.\"\"\"\n    def as_dict(self):\n        \"\"\"Return a copy of the options as a dictionary.\"\"\"\n    def save_yaml(self, filename):\n        \"\"\"Save the parameters to `filename` as a YAML file.\"\"\"\n    def from_yaml(cls, filename, name=None):\n        \"\"\"Load a `Config` instance from a YAML file containing the :attr:`options`.\"\"\"\n    def save_hdf5(self, hdf5_saver, h5gr, subpath):\n        \"\"\"Export `self` into a HDF5 file.\"\"\"\n    def from_hdf5(cls, hdf5_loader, h5gr, subpath):\n        \"\"\"Load instance from a HDF5 file.\"\"\"\n    def warn_unused(self, recursive=False):\n        \"\"\"Warn about (so far) unused options.\"\"\"\n    def keys(self): pass\n    def get(self, key, default, expect_type=None):\n        \"\"\"Find the value of `key`; really more like `setdefault` of a :class:`dict`.\"\"\"\n    def silent_get(self, key, default):\n        \"\"\"Find the value of `key`, but don't set as default value and don't print.\"\"\"\n    def setdefault(self, key, default):\n        \"\"\"Set a default value without reading it out.\"\"\"\n    def subconfig(self, key, default=None):\n        \"\"\"Get ``self[key]`` as a :class:`Config`.\"\"\"\n    def touch(self, *keys):\n        \"\"\"Mark `keys` as read out to suppress warnings about those keys being unused.\"\"\"\n    def log(self, option, action='Option', use_default=False):\n        \"\"\"Print out `option` if verbosity and other conditions are met.\"\"\"\n    def deprecated_alias(self, old_key, new_key, extra_msg=''): pass\n    def deprecated_ignore(self, *old_keys):\n        \"\"\"Issue a warning if an old, deprecated key is encountered that will be ignored.\"\"\"\n    def any_nonzero(self, keys, log_msg=None):\n        \"\"\"Check for any non-zero or non-equal entries in some parameters.\"\"\"\n    def has_nonzero(self, key):\n        \"\"\"Check whether `self` contains `key`, and if `self[key]` is nontrivial.\"\"\"",
    "search_text": "tenpy.tools.params.config # api definition: tenpy.tools.params.config\nclass config:\n    \"\"\"dict-like wrapper class for parameter/configuration dictionaries.\"\"\"\n    def __init__(self, config, name): pass\n    def copy(self, share_unused=true):\n        \"\"\"make a *shallow* copy, as for a dictionary.\"\"\"\n    def as_dict(self):\n        \"\"\"return a copy of the options as a dictionary.\"\"\"\n    def save_yaml(self, filename):\n        \"\"\"save the parameters to `filename` as a yaml file.\"\"\"\n    def from_yaml(cls, filename, name=none):\n        \"\"\"load a `config` instance from a yaml file containing the :attr:`options`.\"\"\"\n    def save_hdf5(self, hdf5_saver, h5gr, subpath):\n        \"\"\"export `self` into a hdf5 file.\"\"\"\n    def from_hdf5(cls, hdf5_loader, h5gr, subpath):\n        \"\"\"load instance from a hdf5 file.\"\"\"\n    def warn_unused(self, recursive=false):\n        \"\"\"warn about (so far) unused options.\"\"\"\n    def keys(self): pass\n    def get(self, key, default, expect_type=none):\n        \"\"\"find the value of `key`; really more like `setdefault` of a :class:`dict`.\"\"\"\n    def silent_get(self, key, default):\n        \"\"\"find the value of `key`, but don't set as default value and don't print.\"\"\"\n    def setdefault(self, key, default):\n        \"\"\"set a default value without reading it out.\"\"\"\n    def subconfig(self, key, default=none):\n        \"\"\"get ``self[key]`` as a :class:`config`.\"\"\"\n    def touch(self, *keys):\n        \"\"\"mark `keys` as read out to suppress warnings about those keys being unused.\"\"\"\n    def log(self, option, action='option', use_default=false):\n        \"\"\"print out `option` if verbosity and other conditions are met.\"\"\"\n    def deprecated_alias(self, old_key, new_key, extra_msg=''): pass\n    def deprecated_ignore(self, *old_keys):\n        \"\"\"issue a warning if an old, deprecated key is encountered that will be ignored.\"\"\"\n    def any_nonzero(self, keys, log_msg=none):\n        \"\"\"check for any non-zero or non-equal entries in some parameters.\"\"\"\n    def has_nonzero(self, key):\n        \"\"\"check whether `self` contains `key`, and if `self[key]` is nontrivial.\"\"\" class config tenpy.tools.params",
    "tokens": 499
  },
  {
    "category": "api",
    "name": "tenpy.tools.params.asConfig",
    "content": "# API Function: tenpy.tools.params.asConfig\ndef asConfig(config, name):\n    \"\"\"Convert a dict-like `config` to a :class:`Config`.\"\"\"",
    "search_text": "tenpy.tools.params.asconfig # api function: tenpy.tools.params.asconfig\ndef asconfig(config, name):\n    \"\"\"convert a dict-like `config` to a :class:`config`.\"\"\" function asconfig",
    "tokens": 35
  },
  {
    "category": "api",
    "name": "tenpy.tools.params.load_yaml_with_py_eval",
    "content": "# API Function: tenpy.tools.params.load_yaml_with_py_eval\ndef load_yaml_with_py_eval(filename=None, yaml_content=None, context={'np': numpy}):\n    \"\"\"Load a yaml file with support for an additional `!py_eval` tag.\"\"\"",
    "search_text": "tenpy.tools.params.load_yaml_with_py_eval # api function: tenpy.tools.params.load_yaml_with_py_eval\ndef load_yaml_with_py_eval(filename=none, yaml_content=none, context={'np': numpy}):\n    \"\"\"load a yaml file with support for an additional `!py_eval` tag.\"\"\" function load_yaml_with_py_eval",
    "tokens": 52
  },
  {
    "category": "api",
    "name": "tenpy.tools.cache.DictCache",
    "content": "# API Definition: tenpy.tools.cache.DictCache\nclass DictCache:\n    \"\"\"Cache with dict-like interface.\"\"\"\n    def __init__(self, storage): pass\n    def trivial(cls):\n        \"\"\"Create a trivial storage that keeps everything in RAM.\"\"\"\n    def create_subcache(self, name):\n        \"\"\"Create another :class:`DictCache` based on the same storage resource.\"\"\"\n    def get(self, key, default=None):\n        \"\"\"Same as ``self[key]``, but return `default` if `key` is not in `self`.\"\"\"\n    def set_short_term_keys(self, *keys):\n        \"\"\"Set keys for data which should be kept in RAM for a while.\"\"\"\n    def preload(self, *keys):\n        \"\"\"Pre-load the data for one or more keys from disk to RAM.\"\"\"",
    "search_text": "tenpy.tools.cache.dictcache # api definition: tenpy.tools.cache.dictcache\nclass dictcache:\n    \"\"\"cache with dict-like interface.\"\"\"\n    def __init__(self, storage): pass\n    def trivial(cls):\n        \"\"\"create a trivial storage that keeps everything in ram.\"\"\"\n    def create_subcache(self, name):\n        \"\"\"create another :class:`dictcache` based on the same storage resource.\"\"\"\n    def get(self, key, default=none):\n        \"\"\"same as ``self[key]``, but return `default` if `key` is not in `self`.\"\"\"\n    def set_short_term_keys(self, *keys):\n        \"\"\"set keys for data which should be kept in ram for a while.\"\"\"\n    def preload(self, *keys):\n        \"\"\"pre-load the data for one or more keys from disk to ram.\"\"\" class dictcache tenpy.tools.cache",
    "tokens": 163
  },
  {
    "category": "api",
    "name": "tenpy.tools.cache.CacheFile",
    "content": "# API Definition: tenpy.tools.cache.CacheFile\nclass CacheFile:\n    \"\"\"Subclass of :class:`DictCache` to handle opening and closing resources.\"\"\"\n    def open(cls, storage_class='Storage', use_threading=False, delete=True, max_queue_size=2, **storage_kwargs):\n        \"\"\"Interface for opening a :class:`Storage` and creating a :class:`DictCache` from it.\"\"\"\n    def close(self):\n        \"\"\"Close the associated storage container and shut down.\"\"\"",
    "search_text": "tenpy.tools.cache.cachefile # api definition: tenpy.tools.cache.cachefile\nclass cachefile:\n    \"\"\"subclass of :class:`dictcache` to handle opening and closing resources.\"\"\"\n    def open(cls, storage_class='storage', use_threading=false, delete=true, max_queue_size=2, **storage_kwargs):\n        \"\"\"interface for opening a :class:`storage` and creating a :class:`dictcache` from it.\"\"\"\n    def close(self):\n        \"\"\"close the associated storage container and shut down.\"\"\" class cachefile tenpy.tools.cache",
    "tokens": 100
  },
  {
    "category": "api",
    "name": "tenpy.tools.cache.Storage",
    "content": "# API Definition: tenpy.tools.cache.Storage\nclass Storage:\n    \"\"\"A container interface for saving data to disk.\"\"\"\n    def __init__(self): pass\n    def open(cls, delete=None): pass\n    def close(self):\n        \"\"\"Close opened files, free memory and clean up temporary files/directories.\"\"\"\n    def subcontainer(self, name):\n        \"\"\"Create another instance of the same class saving in a subdirectory/subgroup.\"\"\"\n    def load(self, key):\n        \"\"\"Interface for loading data from disk in subclasses.\"\"\"\n    def save(self, key, val):\n        \"\"\"Interface for saving data to disk in subclasses.\"\"\"\n    def delete(self, key):\n        \"\"\"Interface for cleaning up a previously saved data from disk in subclasses.\"\"\"\n    def preload(self, key):\n        \"\"\"Interface for preloading data into the given dictionary `into`.\"\"\"",
    "search_text": "tenpy.tools.cache.storage # api definition: tenpy.tools.cache.storage\nclass storage:\n    \"\"\"a container interface for saving data to disk.\"\"\"\n    def __init__(self): pass\n    def open(cls, delete=none): pass\n    def close(self):\n        \"\"\"close opened files, free memory and clean up temporary files/directories.\"\"\"\n    def subcontainer(self, name):\n        \"\"\"create another instance of the same class saving in a subdirectory/subgroup.\"\"\"\n    def load(self, key):\n        \"\"\"interface for loading data from disk in subclasses.\"\"\"\n    def save(self, key, val):\n        \"\"\"interface for saving data to disk in subclasses.\"\"\"\n    def delete(self, key):\n        \"\"\"interface for cleaning up a previously saved data from disk in subclasses.\"\"\"\n    def preload(self, key):\n        \"\"\"interface for preloading data into the given dictionary `into`.\"\"\" class storage tenpy.tools.cache",
    "tokens": 172
  },
  {
    "category": "api",
    "name": "tenpy.tools.cache.PickleStorage",
    "content": "# API Definition: tenpy.tools.cache.PickleStorage\nclass PickleStorage:\n    \"\"\"Subclass of :class:`Storage` which saves long-term data on disk with :mod:`pickle`.\"\"\"\n    def __init__(self, directory): pass\n    def open(cls, directory=None, tmpdir=None, delete=True):\n        \"\"\"Create a directory and use it to initialize a :class:`PickleCache`.\"\"\"\n    def close(self): pass\n    def subcontainer(self, name): pass\n    def load(self, key): pass\n    def save(self, key, value): pass\n    def delete(self, key): pass",
    "search_text": "tenpy.tools.cache.picklestorage # api definition: tenpy.tools.cache.picklestorage\nclass picklestorage:\n    \"\"\"subclass of :class:`storage` which saves long-term data on disk with :mod:`pickle`.\"\"\"\n    def __init__(self, directory): pass\n    def open(cls, directory=none, tmpdir=none, delete=true):\n        \"\"\"create a directory and use it to initialize a :class:`picklecache`.\"\"\"\n    def close(self): pass\n    def subcontainer(self, name): pass\n    def load(self, key): pass\n    def save(self, key, value): pass\n    def delete(self, key): pass class picklestorage tenpy.tools.cache",
    "tokens": 131
  },
  {
    "category": "api",
    "name": "tenpy.tools.cache.Hdf5Storage",
    "content": "# API Definition: tenpy.tools.cache.Hdf5Storage\nclass Hdf5Storage:\n    \"\"\"Subclass of :class:`Storage` which saves long-term data on disk with :mod:`h5py`.\"\"\"\n    def __init__(self, h5group): pass\n    def open(cls, filename=None, subgroup=None, mode='w-', delete=True, tmpdir=None):\n        \"\"\"Create an hdf5 file and use it to initialize an :class:`Hdf5Cache`.\"\"\"\n    def close(self): pass\n    def subcontainer(self, name): pass\n    def load(self, key): pass\n    def save(self, key, value): pass\n    def delete(self, key): pass",
    "search_text": "tenpy.tools.cache.hdf5storage # api definition: tenpy.tools.cache.hdf5storage\nclass hdf5storage:\n    \"\"\"subclass of :class:`storage` which saves long-term data on disk with :mod:`h5py`.\"\"\"\n    def __init__(self, h5group): pass\n    def open(cls, filename=none, subgroup=none, mode='w-', delete=true, tmpdir=none):\n        \"\"\"create an hdf5 file and use it to initialize an :class:`hdf5cache`.\"\"\"\n    def close(self): pass\n    def subcontainer(self, name): pass\n    def load(self, key): pass\n    def save(self, key, value): pass\n    def delete(self, key): pass class hdf5storage tenpy.tools.cache",
    "tokens": 147
  },
  {
    "category": "api",
    "name": "tenpy.tools.cache.ThreadedStorage",
    "content": "# API Definition: tenpy.tools.cache.ThreadedStorage\nclass ThreadedStorage:\n    \"\"\"Wrapper around a :class:`Storage` (or subclass) with thread-parallelization.\"\"\"\n    def __init__(self, worker, disk_storage): pass\n    def open(cls, disk_storage, max_queue_size=2):\n        \"\"\"Setup and start a :class:`Worker` subthread.\"\"\"\n    def close(self): pass\n    def subcontainer(self, name): pass\n    def load(self, key): pass\n    def preload(self, key): pass\n    def save(self, key, value): pass\n    def delete(self, key): pass",
    "search_text": "tenpy.tools.cache.threadedstorage # api definition: tenpy.tools.cache.threadedstorage\nclass threadedstorage:\n    \"\"\"wrapper around a :class:`storage` (or subclass) with thread-parallelization.\"\"\"\n    def __init__(self, worker, disk_storage): pass\n    def open(cls, disk_storage, max_queue_size=2):\n        \"\"\"setup and start a :class:`worker` subthread.\"\"\"\n    def close(self): pass\n    def subcontainer(self, name): pass\n    def load(self, key): pass\n    def preload(self, key): pass\n    def save(self, key, value): pass\n    def delete(self, key): pass class threadedstorage tenpy.tools.cache",
    "tokens": 133
  },
  {
    "category": "api",
    "name": "tenpy.tools.thread.WorkerDied",
    "content": "# API Definition: tenpy.tools.thread.WorkerDied\nclass WorkerDied:\n    \"\"\"Exception thrown if the main thread detects that the worker subthread died.\"\"\"\n",
    "search_text": "tenpy.tools.thread.workerdied # api definition: tenpy.tools.thread.workerdied\nclass workerdied:\n    \"\"\"exception thrown if the main thread detects that the worker subthread died.\"\"\"\n class workerdied tenpy.tools.thread",
    "tokens": 34
  },
  {
    "category": "api",
    "name": "tenpy.tools.thread.Worker",
    "content": "# API Definition: tenpy.tools.thread.Worker\nclass Worker:\n    \"\"\"Manager for a worker thread.\"\"\"\n    def __init__(self, name='tenpy worker', max_queue_size=0, daemon=None): pass\n    def run(self):\n        \"\"\"Main function for worker thread.\"\"\"\n    def put_task(self, fct, *args, **kwargs):\n        \"\"\"Add a task to be done by the worker.\"\"\"\n    def join_tasks(self):\n        \"\"\"Block until all worker tasks are finished.\"\"\"",
    "search_text": "tenpy.tools.thread.worker # api definition: tenpy.tools.thread.worker\nclass worker:\n    \"\"\"manager for a worker thread.\"\"\"\n    def __init__(self, name='tenpy worker', max_queue_size=0, daemon=none): pass\n    def run(self):\n        \"\"\"main function for worker thread.\"\"\"\n    def put_task(self, fct, *args, **kwargs):\n        \"\"\"add a task to be done by the worker.\"\"\"\n    def join_tasks(self):\n        \"\"\"block until all worker tasks are finished.\"\"\" class worker tenpy.tools.thread",
    "tokens": 102
  },
  {
    "category": "api",
    "name": "tenpy.tools.events.EventHandler",
    "content": "# API Definition: tenpy.tools.events.EventHandler\nclass EventHandler:\n    \"\"\"Handler for an event represented by an instance of this class.\"\"\"\n    def __init__(self, arg_descr=None): pass\n    def copy(self):\n        \"\"\"Make a (shallow) copy.\"\"\"\n    def id_of_last_connected(self): pass\n    def connect(self, callback=None, priority=0, extra_kwargs=None):\n        \"\"\"Register a `callback` function as a listener to the event.\"\"\"\n    def connect_by_name(self, module_name, func_name, extra_kwargs=None, priority=0):\n        \"\"\"Connect to a function given by the name in a module, optionally inserting arguments.\"\"\"\n    def disconnect(self, listener_id):\n        \"\"\"De-register a listener.\"\"\"\n    def emit(self, *args, **kwargs):\n        \"\"\"Call the `callback` functions of all listeners.\"\"\"\n    def emit_until_result(self, *args, **kwargs):\n        \"\"\"Call the listeners `callback` until one returns not `None`.\"\"\"",
    "search_text": "tenpy.tools.events.eventhandler # api definition: tenpy.tools.events.eventhandler\nclass eventhandler:\n    \"\"\"handler for an event represented by an instance of this class.\"\"\"\n    def __init__(self, arg_descr=none): pass\n    def copy(self):\n        \"\"\"make a (shallow) copy.\"\"\"\n    def id_of_last_connected(self): pass\n    def connect(self, callback=none, priority=0, extra_kwargs=none):\n        \"\"\"register a `callback` function as a listener to the event.\"\"\"\n    def connect_by_name(self, module_name, func_name, extra_kwargs=none, priority=0):\n        \"\"\"connect to a function given by the name in a module, optionally inserting arguments.\"\"\"\n    def disconnect(self, listener_id):\n        \"\"\"de-register a listener.\"\"\"\n    def emit(self, *args, **kwargs):\n        \"\"\"call the `callback` functions of all listeners.\"\"\"\n    def emit_until_result(self, *args, **kwargs):\n        \"\"\"call the listeners `callback` until one returns not `none`.\"\"\" class eventhandler tenpy.tools.events",
    "tokens": 202
  },
  {
    "category": "api",
    "name": "tenpy.tools.process.memory_usage",
    "content": "# API Function: tenpy.tools.process.memory_usage\ndef memory_usage():\n    \"\"\"Return memory usage of the running python process.\"\"\"",
    "search_text": "tenpy.tools.process.memory_usage # api function: tenpy.tools.process.memory_usage\ndef memory_usage():\n    \"\"\"return memory usage of the running python process.\"\"\" function memory_usage",
    "tokens": 26
  },
  {
    "category": "api",
    "name": "tenpy.tools.process.load_omp_library",
    "content": "# API Function: tenpy.tools.process.load_omp_library\ndef load_omp_library(libs=['libiomp5.so', find_library('libiomp5md'), find_library('gomp')], verbose=True):\n    \"\"\"Tries to load openMP library.\"\"\"",
    "search_text": "tenpy.tools.process.load_omp_library # api function: tenpy.tools.process.load_omp_library\ndef load_omp_library(libs=['libiomp5.so', find_library('libiomp5md'), find_library('gomp')], verbose=true):\n    \"\"\"tries to load openmp library.\"\"\" function load_omp_library",
    "tokens": 56
  },
  {
    "category": "api",
    "name": "tenpy.tools.process.omp_get_nthreads",
    "content": "# API Function: tenpy.tools.process.omp_get_nthreads\ndef omp_get_nthreads():\n    \"\"\"Wrapper around OpenMP ``get_max_threads``.\"\"\"",
    "search_text": "tenpy.tools.process.omp_get_nthreads # api function: tenpy.tools.process.omp_get_nthreads\ndef omp_get_nthreads():\n    \"\"\"wrapper around openmp ``get_max_threads``.\"\"\" function omp_get_nthreads",
    "tokens": 32
  },
  {
    "category": "api",
    "name": "tenpy.tools.process.omp_set_nthreads",
    "content": "# API Function: tenpy.tools.process.omp_set_nthreads\ndef omp_set_nthreads(n):\n    \"\"\"Wrapper around OpenMP ``set_nthreads``.\"\"\"",
    "search_text": "tenpy.tools.process.omp_set_nthreads # api function: tenpy.tools.process.omp_set_nthreads\ndef omp_set_nthreads(n):\n    \"\"\"wrapper around openmp ``set_nthreads``.\"\"\" function omp_set_nthreads",
    "tokens": 33
  },
  {
    "category": "api",
    "name": "tenpy.tools.process.mkl_get_nthreads",
    "content": "# API Function: tenpy.tools.process.mkl_get_nthreads\ndef mkl_get_nthreads():\n    \"\"\"Wrapper around MKL ``get_max_threads``.\"\"\"",
    "search_text": "tenpy.tools.process.mkl_get_nthreads # api function: tenpy.tools.process.mkl_get_nthreads\ndef mkl_get_nthreads():\n    \"\"\"wrapper around mkl ``get_max_threads``.\"\"\" function mkl_get_nthreads",
    "tokens": 33
  },
  {
    "category": "api",
    "name": "tenpy.tools.process.mkl_set_nthreads",
    "content": "# API Function: tenpy.tools.process.mkl_set_nthreads\ndef mkl_set_nthreads(n):\n    \"\"\"Wrapper around MKL ``set_num_threads``.\"\"\"",
    "search_text": "tenpy.tools.process.mkl_set_nthreads # api function: tenpy.tools.process.mkl_set_nthreads\ndef mkl_set_nthreads(n):\n    \"\"\"wrapper around mkl ``set_num_threads``.\"\"\" function mkl_set_nthreads",
    "tokens": 34
  },
  {
    "category": "api",
    "name": "tenpy.models.xxz_chain.XXZChain",
    "content": "# API Definition: tenpy.models.xxz_chain.XXZChain\nclass XXZChain:\n    \"\"\"Spin-1/2 XXZ chain with Sz conservation.\"\"\"\n    def __init__(self, model_params): pass",
    "search_text": "tenpy.models.xxz_chain.xxzchain # api definition: tenpy.models.xxz_chain.xxzchain\nclass xxzchain:\n    \"\"\"spin-1/2 xxz chain with sz conservation.\"\"\"\n    def __init__(self, model_params): pass class xxzchain tenpy.models.xxz_chain",
    "tokens": 45
  },
  {
    "category": "api",
    "name": "tenpy.models.xxz_chain.XXZChain2",
    "content": "# API Definition: tenpy.models.xxz_chain.XXZChain2\nclass XXZChain2:\n    \"\"\"Another implementation of the Spin-1/2 XXZ chain with Sz conservation.\"\"\"\n    def init_sites(self, model_params): pass\n    def init_terms(self, model_params): pass",
    "search_text": "tenpy.models.xxz_chain.xxzchain2 # api definition: tenpy.models.xxz_chain.xxzchain2\nclass xxzchain2:\n    \"\"\"another implementation of the spin-1/2 xxz chain with sz conservation.\"\"\"\n    def init_sites(self, model_params): pass\n    def init_terms(self, model_params): pass class xxzchain2 tenpy.models.xxz_chain",
    "tokens": 61
  },
  {
    "category": "api",
    "name": "tenpy.models.toric_code.DualSquare",
    "content": "# API Definition: tenpy.models.toric_code.DualSquare\nclass DualSquare:\n    \"\"\"The dual lattice of the square lattice (again square).\"\"\"\n    def __init__(self, Lx, Ly, sites, **kwargs): pass\n    def ordering(self, order):\n        \"\"\"Provide possible orderings of the `N` lattice sites.\"\"\"",
    "search_text": "tenpy.models.toric_code.dualsquare # api definition: tenpy.models.toric_code.dualsquare\nclass dualsquare:\n    \"\"\"the dual lattice of the square lattice (again square).\"\"\"\n    def __init__(self, lx, ly, sites, **kwargs): pass\n    def ordering(self, order):\n        \"\"\"provide possible orderings of the `n` lattice sites.\"\"\" class dualsquare tenpy.models.toric_code",
    "tokens": 72
  },
  {
    "category": "api",
    "name": "tenpy.models.toric_code.ToricCode",
    "content": "# API Definition: tenpy.models.toric_code.ToricCode\nclass ToricCode:\n    \"\"\"Toric code model.\"\"\"\n    def init_sites(self, model_params): pass\n    def init_terms(self, model_params): pass",
    "search_text": "tenpy.models.toric_code.toriccode # api definition: tenpy.models.toric_code.toriccode\nclass toriccode:\n    \"\"\"toric code model.\"\"\"\n    def init_sites(self, model_params): pass\n    def init_terms(self, model_params): pass class toriccode tenpy.models.toric_code",
    "tokens": 47
  },
  {
    "category": "api",
    "name": "tenpy.models.mixed_xk.MixedXKLattice",
    "content": "# API Definition: tenpy.models.mixed_xk.MixedXKLattice\nclass MixedXKLattice:\n    \"\"\"Lattice for fermions with mixed real and momentum space on a cylinder.\"\"\"\n    def __init__(self, N_rings, Ly, N_orb, sites, ring_order=None, orbital_names=None, orbital_values=None, **kwargs): pass\n    def from_charges_of_orbitals(cls, N_rings, Ly, N_orb, chinfo, charges, conserve_k=True, ring_order=None, **kwargs):\n        \"\"\"Initialize from charges, defining default Sites.\"\"\"\n    def save_hdf5(self, hdf5_saver, h5gr, subpath):\n        \"\"\"Export `self` into a HDF5 file.\"\"\"\n    def from_hdf5(cls, hdf5_loader, h5gr, subpath):\n        \"\"\"Load instance from a HDF5 file.\"\"\"\n    def get_u(self, k, l):\n        \"\"\"Return unit cell index `u` as a function of momentum index `k` and orbital `l`.\"\"\"\n    def get_k(self, u):\n        \"\"\"Return momentum index `k` for given unit cell index `u`.\"\"\"\n    def get_l(self, u):\n        \"\"\"Return orbital index `l` for given unit cell index `u`.\"\"\"\n    def get_exp_ik(self, ky):\n        \"\"\"Return :math:`\\exp(\\frac{2 pi i }{L_y} ky)`.\"\"\"\n    def mps2lat_values_k(self, A, axes=0):\n        \"\"\"Like :meth:`Lattice.mps2lat_values`, but introduce `k` as separate lattice index.\"\"\"\n    def mps2lat_values_masked_k(self, A, axes=-1, mps_inds=None, include_u=None):\n        \"\"\"Like :meth:`mps2lat_values_masked`, but introduce `k` as separate lattice index.\"\"\"",
    "search_text": "tenpy.models.mixed_xk.mixedxklattice # api definition: tenpy.models.mixed_xk.mixedxklattice\nclass mixedxklattice:\n    \"\"\"lattice for fermions with mixed real and momentum space on a cylinder.\"\"\"\n    def __init__(self, n_rings, ly, n_orb, sites, ring_order=none, orbital_names=none, orbital_values=none, **kwargs): pass\n    def from_charges_of_orbitals(cls, n_rings, ly, n_orb, chinfo, charges, conserve_k=true, ring_order=none, **kwargs):\n        \"\"\"initialize from charges, defining default sites.\"\"\"\n    def save_hdf5(self, hdf5_saver, h5gr, subpath):\n        \"\"\"export `self` into a hdf5 file.\"\"\"\n    def from_hdf5(cls, hdf5_loader, h5gr, subpath):\n        \"\"\"load instance from a hdf5 file.\"\"\"\n    def get_u(self, k, l):\n        \"\"\"return unit cell index `u` as a function of momentum index `k` and orbital `l`.\"\"\"\n    def get_k(self, u):\n        \"\"\"return momentum index `k` for given unit cell index `u`.\"\"\"\n    def get_l(self, u):\n        \"\"\"return orbital index `l` for given unit cell index `u`.\"\"\"\n    def get_exp_ik(self, ky):\n        \"\"\"return :math:`\\exp(\\frac{2 pi i }{l_y} ky)`.\"\"\"\n    def mps2lat_values_k(self, a, axes=0):\n        \"\"\"like :meth:`lattice.mps2lat_values`, but introduce `k` as separate lattice index.\"\"\"\n    def mps2lat_values_masked_k(self, a, axes=-1, mps_inds=none, include_u=none):\n        \"\"\"like :meth:`mps2lat_values_masked`, but introduce `k` as separate lattice index.\"\"\" class mixedxklattice tenpy.models.mixed_xk",
    "tokens": 390
  },
  {
    "category": "api",
    "name": "tenpy.models.mixed_xk.MixedXKModel",
    "content": "# API Definition: tenpy.models.mixed_xk.MixedXKModel\nclass MixedXKModel:\n    \"\"\"Base class for a Hamiltonian represented in mixed x-k-space on a cylinder.\"\"\"\n    def init_lattice(self, model_params, N_orb, chinfo, charges):\n        \"\"\"Initialize a MixedXKLattice for the given model parameters.\"\"\"\n    def add_intra_ring_hopping(self, couplings):\n        \"\"\"Add hopping terms within each ring.\"\"\"\n    def add_inter_ring_hopping(self, couplings, dx=+1):\n        \"\"\"Add hopping terms between different rings.\"\"\"\n    def add_intra_ring_interaction(self, couplings, operators=('Cd', 'C', 'Cd', 'C')):\n        \"\"\"Add intra-ring interaction terms.\"\"\"\n    def add_inter_ring_interaction(self, couplings, dx, operators=('Cd', 'C', 'Cd', 'C')):\n        \"\"\"Add inter-ring interaction terms.\"\"\"\n    def real_to_mixed_onsite(self, A, A_coord):\n        \"\"\"Terms to be measured in x-k space for real space onsite observables.\"\"\"\n    def real_to_mixed_two_site(self, A, A_coord, B, B_coord):\n        \"\"\"Terms to be measured in x-k-space for real space correlation functions.\"\"\"\n    def real_to_mixed_n_site(self, orbital_coeffs, rs_coords):\n        \"\"\"Terms to be measured in x-k-space for real space correlation functions.\"\"\"\n    def real_to_mixed_correlations_any(self, ops, coeff_orbitals, rs_coords):\n        \"\"\"Terms to be measured in x-k-space for real space correlation functions.\"\"\"",
    "search_text": "tenpy.models.mixed_xk.mixedxkmodel # api definition: tenpy.models.mixed_xk.mixedxkmodel\nclass mixedxkmodel:\n    \"\"\"base class for a hamiltonian represented in mixed x-k-space on a cylinder.\"\"\"\n    def init_lattice(self, model_params, n_orb, chinfo, charges):\n        \"\"\"initialize a mixedxklattice for the given model parameters.\"\"\"\n    def add_intra_ring_hopping(self, couplings):\n        \"\"\"add hopping terms within each ring.\"\"\"\n    def add_inter_ring_hopping(self, couplings, dx=+1):\n        \"\"\"add hopping terms between different rings.\"\"\"\n    def add_intra_ring_interaction(self, couplings, operators=('cd', 'c', 'cd', 'c')):\n        \"\"\"add intra-ring interaction terms.\"\"\"\n    def add_inter_ring_interaction(self, couplings, dx, operators=('cd', 'c', 'cd', 'c')):\n        \"\"\"add inter-ring interaction terms.\"\"\"\n    def real_to_mixed_onsite(self, a, a_coord):\n        \"\"\"terms to be measured in x-k space for real space onsite observables.\"\"\"\n    def real_to_mixed_two_site(self, a, a_coord, b, b_coord):\n        \"\"\"terms to be measured in x-k-space for real space correlation functions.\"\"\"\n    def real_to_mixed_n_site(self, orbital_coeffs, rs_coords):\n        \"\"\"terms to be measured in x-k-space for real space correlation functions.\"\"\"\n    def real_to_mixed_correlations_any(self, ops, coeff_orbitals, rs_coords):\n        \"\"\"terms to be measured in x-k-space for real space correlation functions.\"\"\" class mixedxkmodel tenpy.models.mixed_xk",
    "tokens": 327
  },
  {
    "category": "api",
    "name": "tenpy.models.mixed_xk.SpinlessMixedXKSquare",
    "content": "# API Definition: tenpy.models.mixed_xk.SpinlessMixedXKSquare\nclass SpinlessMixedXKSquare:\n    \"\"\"Spin-less fermionic Hubbard model on a square lattice in x-k-basis.\"\"\"\n    def init_lattice(self, model_params): pass\n    def init_terms(self, model_params): pass",
    "search_text": "tenpy.models.mixed_xk.spinlessmixedxksquare # api definition: tenpy.models.mixed_xk.spinlessmixedxksquare\nclass spinlessmixedxksquare:\n    \"\"\"spin-less fermionic hubbard model on a square lattice in x-k-basis.\"\"\"\n    def init_lattice(self, model_params): pass\n    def init_terms(self, model_params): pass class spinlessmixedxksquare tenpy.models.mixed_xk",
    "tokens": 67
  },
  {
    "category": "api",
    "name": "tenpy.models.mixed_xk.HubbardMixedXKSquare",
    "content": "# API Definition: tenpy.models.mixed_xk.HubbardMixedXKSquare\nclass HubbardMixedXKSquare:\n    \"\"\"Example: Spin-full Hubbard model on a square lattice in x-k-Basis.\"\"\"\n    def init_lattice(self, model_params): pass\n    def init_terms(self, model_params): pass",
    "search_text": "tenpy.models.mixed_xk.hubbardmixedxksquare # api definition: tenpy.models.mixed_xk.hubbardmixedxksquare\nclass hubbardmixedxksquare:\n    \"\"\"example: spin-full hubbard model on a square lattice in x-k-basis.\"\"\"\n    def init_lattice(self, model_params): pass\n    def init_terms(self, model_params): pass class hubbardmixedxksquare tenpy.models.mixed_xk",
    "tokens": 66
  },
  {
    "category": "api",
    "name": "tenpy.models.fermions_spinless.FermionModel",
    "content": "# API Definition: tenpy.models.fermions_spinless.FermionModel\nclass FermionModel:\n    \"\"\"Spinless fermions with particle number conservation.\"\"\"\n    def init_sites(self, model_params): pass\n    def init_terms(self, model_params): pass",
    "search_text": "tenpy.models.fermions_spinless.fermionmodel # api definition: tenpy.models.fermions_spinless.fermionmodel\nclass fermionmodel:\n    \"\"\"spinless fermions with particle number conservation.\"\"\"\n    def init_sites(self, model_params): pass\n    def init_terms(self, model_params): pass class fermionmodel tenpy.models.fermions_spinless",
    "tokens": 55
  },
  {
    "category": "api",
    "name": "tenpy.models.fermions_spinless.FermionChain",
    "content": "# API Definition: tenpy.models.fermions_spinless.FermionChain\nclass FermionChain:\n    \"\"\"The :class:`FermionModel` on a Chain, suitable for TEBD.\"\"\"\n",
    "search_text": "tenpy.models.fermions_spinless.fermionchain # api definition: tenpy.models.fermions_spinless.fermionchain\nclass fermionchain:\n    \"\"\"the :class:`fermionmodel` on a chain, suitable for tebd.\"\"\"\n class fermionchain tenpy.models.fermions_spinless",
    "tokens": 44
  },
  {
    "category": "api",
    "name": "tenpy.models.tj_model.tJModel",
    "content": "# API Definition: tenpy.models.tj_model.tJModel\nclass tJModel:\n    \"\"\"Spin-1/2 t-J model.\"\"\"\n    def init_sites(self, model_params): pass\n    def init_terms(self, model_params): pass",
    "search_text": "tenpy.models.tj_model.tjmodel # api definition: tenpy.models.tj_model.tjmodel\nclass tjmodel:\n    \"\"\"spin-1/2 t-j model.\"\"\"\n    def init_sites(self, model_params): pass\n    def init_terms(self, model_params): pass class tjmodel tenpy.models.tj_model",
    "tokens": 51
  },
  {
    "category": "api",
    "name": "tenpy.models.tj_model.tJChain",
    "content": "# API Definition: tenpy.models.tj_model.tJChain\nclass tJChain:\n    \"\"\"The :class:`tJModel` on a Chain, suitable for TEBD.\"\"\"\n",
    "search_text": "tenpy.models.tj_model.tjchain # api definition: tenpy.models.tj_model.tjchain\nclass tjchain:\n    \"\"\"the :class:`tjmodel` on a chain, suitable for tebd.\"\"\"\n class tjchain tenpy.models.tj_model",
    "tokens": 39
  },
  {
    "category": "api",
    "name": "tenpy.models.hubbard.BoseHubbardModel",
    "content": "# API Definition: tenpy.models.hubbard.BoseHubbardModel\nclass BoseHubbardModel:\n    \"\"\"Spinless Bose-Hubbard model.\"\"\"\n    def init_sites(self, model_params): pass\n    def init_terms(self, model_params): pass",
    "search_text": "tenpy.models.hubbard.bosehubbardmodel # api definition: tenpy.models.hubbard.bosehubbardmodel\nclass bosehubbardmodel:\n    \"\"\"spinless bose-hubbard model.\"\"\"\n    def init_sites(self, model_params): pass\n    def init_terms(self, model_params): pass class bosehubbardmodel tenpy.models.hubbard",
    "tokens": 53
  },
  {
    "category": "api",
    "name": "tenpy.models.hubbard.BoseHubbardChain",
    "content": "# API Definition: tenpy.models.hubbard.BoseHubbardChain\nclass BoseHubbardChain:\n    \"\"\"The :class:`BoseHubbardModel` on a Chain, suitable for TEBD.\"\"\"\n    def __init__(self, model_params): pass\n    def estimate_RAM_saving_factor(self):\n        \"\"\"Returns the expected saving factor for RAM based on charge conservation.\"\"\"",
    "search_text": "tenpy.models.hubbard.bosehubbardchain # api definition: tenpy.models.hubbard.bosehubbardchain\nclass bosehubbardchain:\n    \"\"\"the :class:`bosehubbardmodel` on a chain, suitable for tebd.\"\"\"\n    def __init__(self, model_params): pass\n    def estimate_ram_saving_factor(self):\n        \"\"\"returns the expected saving factor for ram based on charge conservation.\"\"\" class bosehubbardchain tenpy.models.hubbard",
    "tokens": 79
  },
  {
    "category": "api",
    "name": "tenpy.models.hubbard.FermiHubbardModel",
    "content": "# API Definition: tenpy.models.hubbard.FermiHubbardModel\nclass FermiHubbardModel:\n    \"\"\"Spin-1/2 Fermi-Hubbard model.\"\"\"\n    def init_sites(self, model_params): pass\n    def init_terms(self, model_params): pass",
    "search_text": "tenpy.models.hubbard.fermihubbardmodel # api definition: tenpy.models.hubbard.fermihubbardmodel\nclass fermihubbardmodel:\n    \"\"\"spin-1/2 fermi-hubbard model.\"\"\"\n    def init_sites(self, model_params): pass\n    def init_terms(self, model_params): pass class fermihubbardmodel tenpy.models.hubbard",
    "tokens": 59
  },
  {
    "category": "api",
    "name": "tenpy.models.hubbard.FermiHubbardChain",
    "content": "# API Definition: tenpy.models.hubbard.FermiHubbardChain\nclass FermiHubbardChain:\n    \"\"\"The :class:`FermiHubbardModel` on a Chain, suitable for TEBD.\"\"\"\n",
    "search_text": "tenpy.models.hubbard.fermihubbardchain # api definition: tenpy.models.hubbard.fermihubbardchain\nclass fermihubbardchain:\n    \"\"\"the :class:`fermihubbardmodel` on a chain, suitable for tebd.\"\"\"\n class fermihubbardchain tenpy.models.hubbard",
    "tokens": 47
  },
  {
    "category": "api",
    "name": "tenpy.models.hubbard.FermiHubbardModel2",
    "content": "# API Definition: tenpy.models.hubbard.FermiHubbardModel2\nclass FermiHubbardModel2:\n    \"\"\"Another implementation of the :class:`FermiHubbardModel`, but with local dimension 2.\"\"\"\n    def init_sites(self, model_params): pass\n    def init_terms(self, model_params): pass",
    "search_text": "tenpy.models.hubbard.fermihubbardmodel2 # api definition: tenpy.models.hubbard.fermihubbardmodel2\nclass fermihubbardmodel2:\n    \"\"\"another implementation of the :class:`fermihubbardmodel`, but with local dimension 2.\"\"\"\n    def init_sites(self, model_params): pass\n    def init_terms(self, model_params): pass class fermihubbardmodel2 tenpy.models.hubbard",
    "tokens": 70
  },
  {
    "category": "api",
    "name": "tenpy.models.hubbard.DipolarBoseHubbardChain",
    "content": "# API Definition: tenpy.models.hubbard.DipolarBoseHubbardChain\nclass DipolarBoseHubbardChain:\n    \"\"\"Dipole-conserving spinless Bose-Hubbard model.\"\"\"\n    def init_lattice(self, model_params):\n        \"\"\"Initialize a 1D lattice\"\"\"\n    def init_terms(self, model_params):\n        \"\"\"Add the onsite and coupling terms to the model\"\"\"",
    "search_text": "tenpy.models.hubbard.dipolarbosehubbardchain # api definition: tenpy.models.hubbard.dipolarbosehubbardchain\nclass dipolarbosehubbardchain:\n    \"\"\"dipole-conserving spinless bose-hubbard model.\"\"\"\n    def init_lattice(self, model_params):\n        \"\"\"initialize a 1d lattice\"\"\"\n    def init_terms(self, model_params):\n        \"\"\"add the onsite and coupling terms to the model\"\"\" class dipolarbosehubbardchain tenpy.models.hubbard",
    "tokens": 83
  },
  {
    "category": "api",
    "name": "tenpy.models.tf_ising.TFIModel",
    "content": "# API Definition: tenpy.models.tf_ising.TFIModel\nclass TFIModel:\n    \"\"\"Transverse field Ising model on a general lattice.\"\"\"\n    def init_sites(self, model_params): pass\n    def init_terms(self, model_params): pass",
    "search_text": "tenpy.models.tf_ising.tfimodel # api definition: tenpy.models.tf_ising.tfimodel\nclass tfimodel:\n    \"\"\"transverse field ising model on a general lattice.\"\"\"\n    def init_sites(self, model_params): pass\n    def init_terms(self, model_params): pass class tfimodel tenpy.models.tf_ising",
    "tokens": 53
  },
  {
    "category": "api",
    "name": "tenpy.models.tf_ising.TFIChain",
    "content": "# API Definition: tenpy.models.tf_ising.TFIChain\nclass TFIChain:\n    \"\"\"The :class:`TFIModel` on a Chain, suitable for TEBD.\"\"\"\n",
    "search_text": "tenpy.models.tf_ising.tfichain # api definition: tenpy.models.tf_ising.tfichain\nclass tfichain:\n    \"\"\"the :class:`tfimodel` on a chain, suitable for tebd.\"\"\"\n class tfichain tenpy.models.tf_ising",
    "tokens": 39
  },
  {
    "category": "api",
    "name": "tenpy.models.model.Model",
    "content": "# API Definition: tenpy.models.model.Model\nclass Model:\n    \"\"\"Base class for all models.\"\"\"\n    def __init__(self, lattice): pass\n    def rng(self):\n        \"\"\"Reproducible numpy pseudo random number generator.\"\"\"\n    def copy(self):\n        \"\"\"Shallow copy of self.\"\"\"\n    def save_hdf5(self, hdf5_saver, h5gr, subpath):\n        \"\"\"Export `self` into a HDF5 file.\"\"\"\n    def from_hdf5(cls, hdf5_loader, h5gr, subpath):\n        \"\"\"Load instance from a HDF5 file.\"\"\"\n    def extract_segment(self, first=0, last=None, enlarge=None):\n        \"\"\"Return a (shallow) copy with extracted segment of MPS.\"\"\"\n    def enlarge_mps_unit_cell(self, factor=2):\n        \"\"\"Repeat the unit cell for infinite MPS boundary conditions; in place.\"\"\"\n    def group_sites(self, n=2, grouped_sites=None):\n        \"\"\"Modify `self` in place to group sites.\"\"\"\n    def get_extra_default_measurements(self):\n        \"\"\"Get list of model-dependent extra default measurements.\"\"\"\n    def update_time_parameter(self, new_time):\n        \"\"\"Reconstruct Hamiltonian for time-dependent models, potentially (!) in-place.\"\"\"\n    def estimate_RAM_saving_factor(self):\n        \"\"\"Returns the expected saving factor for RAM based on charge conservation.\"\"\"",
    "search_text": "tenpy.models.model.model # api definition: tenpy.models.model.model\nclass model:\n    \"\"\"base class for all models.\"\"\"\n    def __init__(self, lattice): pass\n    def rng(self):\n        \"\"\"reproducible numpy pseudo random number generator.\"\"\"\n    def copy(self):\n        \"\"\"shallow copy of self.\"\"\"\n    def save_hdf5(self, hdf5_saver, h5gr, subpath):\n        \"\"\"export `self` into a hdf5 file.\"\"\"\n    def from_hdf5(cls, hdf5_loader, h5gr, subpath):\n        \"\"\"load instance from a hdf5 file.\"\"\"\n    def extract_segment(self, first=0, last=none, enlarge=none):\n        \"\"\"return a (shallow) copy with extracted segment of mps.\"\"\"\n    def enlarge_mps_unit_cell(self, factor=2):\n        \"\"\"repeat the unit cell for infinite mps boundary conditions; in place.\"\"\"\n    def group_sites(self, n=2, grouped_sites=none):\n        \"\"\"modify `self` in place to group sites.\"\"\"\n    def get_extra_default_measurements(self):\n        \"\"\"get list of model-dependent extra default measurements.\"\"\"\n    def update_time_parameter(self, new_time):\n        \"\"\"reconstruct hamiltonian for time-dependent models, potentially (!) in-place.\"\"\"\n    def estimate_ram_saving_factor(self):\n        \"\"\"returns the expected saving factor for ram based on charge conservation.\"\"\" class model tenpy.models.model",
    "tokens": 277
  },
  {
    "category": "api",
    "name": "tenpy.models.model.NearestNeighborModel",
    "content": "# API Definition: tenpy.models.model.NearestNeighborModel\nclass NearestNeighborModel:\n    \"\"\"Base class for a model of nearest neighbor interactions w.r.t. the MPS index.\"\"\"\n    def __init__(self, lattice, H_bond): pass\n    def from_MPOModel(cls, mpo_model):\n        \"\"\"Initialize a NearestNeighborModel from a model class defining an MPO.\"\"\"\n    def test_sanity(self): pass\n    def trivial_like_NNModel(self):\n        \"\"\"Return a NearestNeighborModel with same lattice, but trivial (H=0) bonds.\"\"\"\n    def bond_energies(self, psi):\n        \"\"\"Calculate bond energies <psi|H_bond|psi>.\"\"\"\n    def extract_segment(self, *args, **kwargs): pass\n    def enlarge_mps_unit_cell(self, factor=2):\n        \"\"\"Repeat the unit cell for infinite MPS boundary conditions; in place.\"\"\"\n    def group_sites(self, n=2, grouped_sites=None):\n        \"\"\"Modify `self` in place to group sites.\"\"\"\n    def calc_H_MPO_from_bond(self, tol_zero=1e-15):\n        \"\"\"Calculate the MPO Hamiltonian from the bond Hamiltonian.\"\"\"\n    def get_extra_default_measurements(self): pass",
    "search_text": "tenpy.models.model.nearestneighbormodel # api definition: tenpy.models.model.nearestneighbormodel\nclass nearestneighbormodel:\n    \"\"\"base class for a model of nearest neighbor interactions w.r.t. the mps index.\"\"\"\n    def __init__(self, lattice, h_bond): pass\n    def from_mpomodel(cls, mpo_model):\n        \"\"\"initialize a nearestneighbormodel from a model class defining an mpo.\"\"\"\n    def test_sanity(self): pass\n    def trivial_like_nnmodel(self):\n        \"\"\"return a nearestneighbormodel with same lattice, but trivial (h=0) bonds.\"\"\"\n    def bond_energies(self, psi):\n        \"\"\"calculate bond energies <psi|h_bond|psi>.\"\"\"\n    def extract_segment(self, *args, **kwargs): pass\n    def enlarge_mps_unit_cell(self, factor=2):\n        \"\"\"repeat the unit cell for infinite mps boundary conditions; in place.\"\"\"\n    def group_sites(self, n=2, grouped_sites=none):\n        \"\"\"modify `self` in place to group sites.\"\"\"\n    def calc_h_mpo_from_bond(self, tol_zero=1e-15):\n        \"\"\"calculate the mpo hamiltonian from the bond hamiltonian.\"\"\"\n    def get_extra_default_measurements(self): pass class nearestneighbormodel tenpy.models.model",
    "tokens": 258
  },
  {
    "category": "api",
    "name": "tenpy.models.model.MPOModel",
    "content": "# API Definition: tenpy.models.model.MPOModel\nclass MPOModel:\n    \"\"\"Base class for a model with an MPO representation of the Hamiltonian.\"\"\"\n    def __init__(self, lattice, H_MPO): pass\n    def copy(self): pass\n    def test_sanity(self): pass\n    def extract_segment(self, *args, **kwargs): pass\n    def enlarge_mps_unit_cell(self, factor=2):\n        \"\"\"Repeat the unit cell for infinite MPS boundary conditions; in place.\"\"\"\n    def group_sites(self, n=2, grouped_sites=None):\n        \"\"\"Modify `self` in place to group sites.\"\"\"\n    def calc_H_bond_from_MPO(self, tol_zero=1e-15):\n        \"\"\"Calculate the bond Hamiltonian from the MPO Hamiltonian.\"\"\"\n    def get_extra_default_measurements(self): pass",
    "search_text": "tenpy.models.model.mpomodel # api definition: tenpy.models.model.mpomodel\nclass mpomodel:\n    \"\"\"base class for a model with an mpo representation of the hamiltonian.\"\"\"\n    def __init__(self, lattice, h_mpo): pass\n    def copy(self): pass\n    def test_sanity(self): pass\n    def extract_segment(self, *args, **kwargs): pass\n    def enlarge_mps_unit_cell(self, factor=2):\n        \"\"\"repeat the unit cell for infinite mps boundary conditions; in place.\"\"\"\n    def group_sites(self, n=2, grouped_sites=none):\n        \"\"\"modify `self` in place to group sites.\"\"\"\n    def calc_h_bond_from_mpo(self, tol_zero=1e-15):\n        \"\"\"calculate the bond hamiltonian from the mpo hamiltonian.\"\"\"\n    def get_extra_default_measurements(self): pass class mpomodel tenpy.models.model",
    "tokens": 176
  },
  {
    "category": "api",
    "name": "tenpy.models.model.CouplingModel",
    "content": "# API Definition: tenpy.models.model.CouplingModel\nclass CouplingModel:\n    \"\"\"Base class for a general model of a Hamiltonian consisting of two-site couplings.\"\"\"\n    def __init__(self, lattice, explicit_plus_hc=False): pass\n    def test_sanity(self):\n        \"\"\"Sanity check, raises ValueErrors, if something is wrong.\"\"\"\n    def add_local_term(self, strength, term, category=None, plus_hc=False):\n        \"\"\"Add a single term to `self`.\"\"\"\n    def add_onsite(self, strength, u, opname, category=None, plus_hc=False):\n        \"\"\"Add onsite terms to :attr:`onsite_terms`.\"\"\"\n    def add_onsite_term(self, strength, i, op, category=None, plus_hc=False):\n        \"\"\"Add an onsite term on a given MPS site.\"\"\"\n    def all_onsite_terms(self):\n        \"\"\"Sum of all :attr:`onsite_terms`.\"\"\"\n    def add_coupling(self, strength, u1, op1, u2, op2, dx, op_string=None, category=None, plus_hc=False):\n        \"\"\"Add two-site coupling terms to the Hamiltonian, summing over lattice sites.\"\"\"\n    def add_coupling_term(self, strength, i, j, op_i, op_j, op_string='Id', category=None, plus_hc=False):\n        \"\"\"Add a two-site coupling term on given MPS sites.\"\"\"\n    def all_coupling_terms(self):\n        \"\"\"Sum of all :attr:`coupling_terms`.\"\"\"\n    def add_multi_coupling(self, strength, ops, op_string=None, category=None, plus_hc=False, switchLR='middle_i'):\n        \"\"\"Add multi-site coupling terms to the Hamiltonian, summing over lattice sites.\"\"\"\n    def add_multi_coupling_term(self, strength, ijkl, ops_ijkl, op_string, category=None, plus_hc=False, switchLR='middle_i'):\n        \"\"\"Add a general M-site coupling term on given MPS sites.\"\"\"\n    def add_exponentially_decaying_coupling(self, strength, lambda_, op_i, op_j, subsites=None, subsites_start=None, op_string=None, plus_hc=False):\n        \"\"\"Add an exponentially decaying long-range coupling.\"\"\"\n    def add_exponentially_decaying_centered_terms(self, strength, lambda_, op_i, op_j, i, subsites=None, op_string=None, plus_hc=False):\n        \"\"\"Add exponentially decaying terms centered around a single site. Only for finite systems.\"\"\"\n    def calc_H_bond(self, tol_zero=1e-15):\n        \"\"\"Calculate `H_bond` from :attr:`coupling_terms` and :attr:`onsite_terms`.\"\"\"\n    def calc_H_MPO(self, tol_zero=1e-15):\n        \"\"\"Calculate MPO representation of the Hamiltonian.\"\"\"\n    def coupling_strength_add_ext_flux(self, strength, dx, phase):\n        \"\"\"Add an external flux to the coupling strength.\"\"\"",
    "search_text": "tenpy.models.model.couplingmodel # api definition: tenpy.models.model.couplingmodel\nclass couplingmodel:\n    \"\"\"base class for a general model of a hamiltonian consisting of two-site couplings.\"\"\"\n    def __init__(self, lattice, explicit_plus_hc=false): pass\n    def test_sanity(self):\n        \"\"\"sanity check, raises valueerrors, if something is wrong.\"\"\"\n    def add_local_term(self, strength, term, category=none, plus_hc=false):\n        \"\"\"add a single term to `self`.\"\"\"\n    def add_onsite(self, strength, u, opname, category=none, plus_hc=false):\n        \"\"\"add onsite terms to :attr:`onsite_terms`.\"\"\"\n    def add_onsite_term(self, strength, i, op, category=none, plus_hc=false):\n        \"\"\"add an onsite term on a given mps site.\"\"\"\n    def all_onsite_terms(self):\n        \"\"\"sum of all :attr:`onsite_terms`.\"\"\"\n    def add_coupling(self, strength, u1, op1, u2, op2, dx, op_string=none, category=none, plus_hc=false):\n        \"\"\"add two-site coupling terms to the hamiltonian, summing over lattice sites.\"\"\"\n    def add_coupling_term(self, strength, i, j, op_i, op_j, op_string='id', category=none, plus_hc=false):\n        \"\"\"add a two-site coupling term on given mps sites.\"\"\"\n    def all_coupling_terms(self):\n        \"\"\"sum of all :attr:`coupling_terms`.\"\"\"\n    def add_multi_coupling(self, strength, ops, op_string=none, category=none, plus_hc=false, switchlr='middle_i'):\n        \"\"\"add multi-site coupling terms to the hamiltonian, summing over lattice sites.\"\"\"\n    def add_multi_coupling_term(self, strength, ijkl, ops_ijkl, op_string, category=none, plus_hc=false, switchlr='middle_i'):\n        \"\"\"add a general m-site coupling term on given mps sites.\"\"\"\n    def add_exponentially_decaying_coupling(self, strength, lambda_, op_i, op_j, subsites=none, subsites_start=none, op_string=none, plus_hc=false):\n        \"\"\"add an exponentially decaying long-range coupling.\"\"\"\n    def add_exponentially_decaying_centered_terms(self, strength, lambda_, op_i, op_j, i, subsites=none, op_string=none, plus_hc=false):\n        \"\"\"add exponentially decaying terms centered around a single site. only for finite systems.\"\"\"\n    def calc_h_bond(self, tol_zero=1e-15):\n        \"\"\"calculate `h_bond` from :attr:`coupling_terms` and :attr:`onsite_terms`.\"\"\"\n    def calc_h_mpo(self, tol_zero=1e-15):\n        \"\"\"calculate mpo representation of the hamiltonian.\"\"\"\n    def coupling_strength_add_ext_flux(self, strength, dx, phase):\n        \"\"\"add an external flux to the coupling strength.\"\"\" class couplingmodel tenpy.models.model",
    "tokens": 618
  },
  {
    "category": "api",
    "name": "tenpy.models.model.CouplingMPOModel",
    "content": "# API Definition: tenpy.models.model.CouplingMPOModel\nclass CouplingMPOModel:\n    \"\"\"Combination of the :class:`CouplingModel` and :class:`MPOModel`.\"\"\"\n    def __init__(self, model_params): pass\n    def init_H_from_terms(self):\n        \"\"\"Initialize `H_MPO` (and `H_bond`) from the terms of the `CouplingModel`.\"\"\"\n    def init_lattice(self, model_params):\n        \"\"\"Initialize a lattice for the given model parameters.\"\"\"\n    def init_sites(self, model_params):\n        \"\"\"Define the local Hilbert space and operators; needs to be implemented in subclasses.\"\"\"\n    def init_terms(self, model_params):\n        \"\"\"Add the onsite and coupling terms to the model; subclasses should implement this.\"\"\"",
    "search_text": "tenpy.models.model.couplingmpomodel # api definition: tenpy.models.model.couplingmpomodel\nclass couplingmpomodel:\n    \"\"\"combination of the :class:`couplingmodel` and :class:`mpomodel`.\"\"\"\n    def __init__(self, model_params): pass\n    def init_h_from_terms(self):\n        \"\"\"initialize `h_mpo` (and `h_bond`) from the terms of the `couplingmodel`.\"\"\"\n    def init_lattice(self, model_params):\n        \"\"\"initialize a lattice for the given model parameters.\"\"\"\n    def init_sites(self, model_params):\n        \"\"\"define the local hilbert space and operators; needs to be implemented in subclasses.\"\"\"\n    def init_terms(self, model_params):\n        \"\"\"add the onsite and coupling terms to the model; subclasses should implement this.\"\"\" class couplingmpomodel tenpy.models.model",
    "tokens": 164
  },
  {
    "category": "api",
    "name": "tenpy.models.hofstadter.hopping_phases",
    "content": "# API Function: tenpy.models.hofstadter.hopping_phases\ndef hopping_phases(p: int, q: int, Lx: int, Ly: int, pbc_x: bool, pbc_y: bool, gauge):\n    \"\"\"Calculate the complex hopping phases for Hofstadter models.\"\"\"",
    "search_text": "tenpy.models.hofstadter.hopping_phases # api function: tenpy.models.hofstadter.hopping_phases\ndef hopping_phases(p: int, q: int, lx: int, ly: int, pbc_x: bool, pbc_y: bool, gauge):\n    \"\"\"calculate the complex hopping phases for hofstadter models.\"\"\" function hopping_phases",
    "tokens": 64
  },
  {
    "category": "api",
    "name": "tenpy.models.hofstadter.HofstadterFermions",
    "content": "# API Definition: tenpy.models.hofstadter.HofstadterFermions\nclass HofstadterFermions:\n    \"\"\"Fermions on a square lattice with uniform magnetic flux.\"\"\"\n    def init_sites(self, model_params): pass\n    def init_terms(self, model_params): pass",
    "search_text": "tenpy.models.hofstadter.hofstadterfermions # api definition: tenpy.models.hofstadter.hofstadterfermions\nclass hofstadterfermions:\n    \"\"\"fermions on a square lattice with uniform magnetic flux.\"\"\"\n    def init_sites(self, model_params): pass\n    def init_terms(self, model_params): pass class hofstadterfermions tenpy.models.hofstadter",
    "tokens": 62
  },
  {
    "category": "api",
    "name": "tenpy.models.hofstadter.HofstadterBosons",
    "content": "# API Definition: tenpy.models.hofstadter.HofstadterBosons\nclass HofstadterBosons:\n    \"\"\"Bosons on a square lattice with uniform magnetic flux.\"\"\"\n    def init_sites(self, model_params): pass\n    def init_terms(self, model_params): pass",
    "search_text": "tenpy.models.hofstadter.hofstadterbosons # api definition: tenpy.models.hofstadter.hofstadterbosons\nclass hofstadterbosons:\n    \"\"\"bosons on a square lattice with uniform magnetic flux.\"\"\"\n    def init_sites(self, model_params): pass\n    def init_terms(self, model_params): pass class hofstadterbosons tenpy.models.hofstadter",
    "tokens": 62
  },
  {
    "category": "api",
    "name": "tenpy.models.hofstadter.gauge_hopping",
    "content": "# API Function: tenpy.models.hofstadter.gauge_hopping\ndef gauge_hopping(*a, **kw): pass",
    "search_text": "tenpy.models.hofstadter.gauge_hopping # api function: tenpy.models.hofstadter.gauge_hopping\ndef gauge_hopping(*a, **kw): pass function gauge_hopping",
    "tokens": 27
  },
  {
    "category": "api",
    "name": "tenpy.models.pxp.PXPChain",
    "content": "# API Definition: tenpy.models.pxp.PXPChain\nclass PXPChain:\n    \"\"\"The PXP model as (approximately) implemented by a chain of Rydberg-blockaded atoms.\"\"\"\n    def init_sites(self, model_params): pass\n    def init_terms(self, model_params): pass",
    "search_text": "tenpy.models.pxp.pxpchain # api definition: tenpy.models.pxp.pxpchain\nclass pxpchain:\n    \"\"\"the pxp model as (approximately) implemented by a chain of rydberg-blockaded atoms.\"\"\"\n    def init_sites(self, model_params): pass\n    def init_terms(self, model_params): pass class pxpchain tenpy.models.pxp",
    "tokens": 61
  },
  {
    "category": "api",
    "name": "tenpy.models.clock.ClockModel",
    "content": "# API Definition: tenpy.models.clock.ClockModel\nclass ClockModel:\n    \"\"\"q-state Quantum clock model on a general lattice\"\"\"\n    def init_sites(self, model_params): pass\n    def init_terms(self, model_params): pass",
    "search_text": "tenpy.models.clock.clockmodel # api definition: tenpy.models.clock.clockmodel\nclass clockmodel:\n    \"\"\"q-state quantum clock model on a general lattice\"\"\"\n    def init_sites(self, model_params): pass\n    def init_terms(self, model_params): pass class clockmodel tenpy.models.clock",
    "tokens": 48
  },
  {
    "category": "api",
    "name": "tenpy.models.clock.ClockChain",
    "content": "# API Definition: tenpy.models.clock.ClockChain\nclass ClockChain:\n    \"\"\"The :class:`ClockModel` on a Chain, suitable for TEBD.\"\"\"\n",
    "search_text": "tenpy.models.clock.clockchain # api definition: tenpy.models.clock.clockchain\nclass clockchain:\n    \"\"\"the :class:`clockmodel` on a chain, suitable for tebd.\"\"\"\n class clockchain tenpy.models.clock",
    "tokens": 34
  },
  {
    "category": "api",
    "name": "tenpy.models.aklt.AKLTChain",
    "content": "# API Definition: tenpy.models.aklt.AKLTChain\nclass AKLTChain:\n    \"\"\"A simple implementation of the AKLT model.\"\"\"\n    def __init__(self, model_params): pass\n    def psi_AKLT(self):\n        \"\"\"Initialize the chi=2 MPS which is exact ground state of the AKLT model.\"\"\"",
    "search_text": "tenpy.models.aklt.akltchain # api definition: tenpy.models.aklt.akltchain\nclass akltchain:\n    \"\"\"a simple implementation of the aklt model.\"\"\"\n    def __init__(self, model_params): pass\n    def psi_aklt(self):\n        \"\"\"initialize the chi=2 mps which is exact ground state of the aklt model.\"\"\" class akltchain tenpy.models.aklt",
    "tokens": 69
  },
  {
    "category": "api",
    "name": "tenpy.models.molecular.MolecularModel",
    "content": "# API Definition: tenpy.models.molecular.MolecularModel\nclass MolecularModel:\n    \"\"\"Spin-1/2 fermion molecular Hamiltonian.\"\"\"\n    def __init__(self, params: dict): pass\n    def init_sites(self, params: Config):\n        \"\"\"Initialize sites.\"\"\"\n    def init_lattice(self, params: Config):\n        \"\"\"Initialize lattice.\"\"\"\n    def init_terms(self, params: Config):\n        \"\"\"Initialize terms.\"\"\"",
    "search_text": "tenpy.models.molecular.molecularmodel # api definition: tenpy.models.molecular.molecularmodel\nclass molecularmodel:\n    \"\"\"spin-1/2 fermion molecular hamiltonian.\"\"\"\n    def __init__(self, params: dict): pass\n    def init_sites(self, params: config):\n        \"\"\"initialize sites.\"\"\"\n    def init_lattice(self, params: config):\n        \"\"\"initialize lattice.\"\"\"\n    def init_terms(self, params: config):\n        \"\"\"initialize terms.\"\"\" class molecularmodel tenpy.models.molecular",
    "tokens": 89
  },
  {
    "category": "api",
    "name": "tenpy.models.lattice.Lattice",
    "content": "# API Definition: tenpy.models.lattice.Lattice\nclass Lattice:\n    \"\"\"A general, regular lattice.\"\"\"\n    def __init__(self, Ls, unit_cell, order='default', bc='open', bc_MPS='finite', basis=None, positions=None, pairs=None): pass\n    def test_sanity(self):\n        \"\"\"Sanity check.\"\"\"\n    def unit_cell(self): pass\n    def unit_cell(self, value): pass\n    def from_model_params(cls, model_params, sites):\n        \"\"\"Initialize by reading sizes, boundary conditions etc from `model_params`.\"\"\"\n    def copy(self):\n        \"\"\"Shallow copy of `self`.\"\"\"\n    def save_hdf5(self, hdf5_saver, h5gr, subpath):\n        \"\"\"Export `self` into a HDF5 file.\"\"\"\n    def from_hdf5(cls, hdf5_loader, h5gr, subpath):\n        \"\"\"Load instance from a HDF5 file.\"\"\"\n    def basis(self): pass\n    def basis(self, new_basis): pass\n    def dim(self):\n        \"\"\"The dimension of the lattice.\"\"\"\n    def order(self):\n        \"\"\"Defines an ordering of the lattice sites, thus mapping the lattice to a 1D chain.\"\"\"\n    def order(self, order_): pass\n    def ordering(self, order):\n        \"\"\"Provide possible orderings of the `N` lattice sites.\"\"\"\n    def boundary_conditions(self):\n        \"\"\"Human-readable list of boundary conditions from :attr:`bc` and :attr:`bc_shift`.\"\"\"\n    def boundary_conditions(self, bc): pass\n    def cylinder_axis(self):\n        \"\"\"Direction of the cylinder axis.\"\"\"\n    def extract_segment(self, first=0, last=None, enlarge=None):\n        \"\"\"Extract a finite segment from an infinite/large system.\"\"\"\n    def enlarge_mps_unit_cell(self, factor=2):\n        \"\"\"Repeat the unit cell for infinite MPS boundary conditions; in place.\"\"\"\n    def position(self, lat_idx):\n        \"\"\"Return 'space' position of one or multiple sites.\"\"\"\n    def site(self, i):\n        \"\"\"Return :class:`~tenpy.networks.site.Site` instance corresponding to an MPS index `i`\"\"\"\n    def mps_sites(self):\n        \"\"\"Return a list of sites for all MPS indices.\"\"\"\n    def mps2lat_idx(self, i):\n        \"\"\"Translate MPS index `i` to lattice indices ``(x_0, ..., x_{dim-1}, u)``.\"\"\"\n    def lat2mps_idx(self, lat_idx):\n        \"\"\"Translate lattice indices ``(x_0, ..., x_{D-1}, u)`` to MPS index `i`.\"\"\"\n    def mps_idx_fix_u(self, u=None):\n        \"\"\"Return an index array of MPS indices for which the site within the unit cell is `u`.\"\"\"\n    def mps_lat_idx_fix_u(self, u=None):\n        \"\"\"Similar as :meth:`mps_idx_fix_u`, but return also the corresponding lattice indices.\"\"\"\n    def mps2lat_values(self, A, axes=0, u=None):\n        \"\"\"Reshape/reorder `A` to replace an MPS index by lattice indices.\"\"\"\n    def mps2lat_values_masked(self, A, axes=-1, mps_inds=None, include_u=None):\n        \"\"\"Reshape/reorder an array `A` to replace an MPS index by lattice indices.\"\"\"\n    def count_neighbors(self, u=0, key='nearest_neighbors'):\n        \"\"\"Count e.g. the number of nearest neighbors for a site in the bulk.\"\"\"\n    def distance(self, u1, u2, dx):\n        \"\"\"Get the distance for a given coupling between two sites in the lattice.\"\"\"\n    def find_coupling_pairs(self, max_dx=3, cutoff=None, eps=1e-10):\n        \"\"\"Automatically find coupling pairs grouped by distances.\"\"\"\n    def coupling_shape(self, dx):\n        \"\"\"Calculate correct shape of the `strengths` for a coupling.\"\"\"\n    def possible_couplings(self, u1, u2, dx, strength=None):\n        \"\"\"Find possible MPS indices for two-site couplings.\"\"\"\n    def multi_coupling_shape(self, dx):\n        \"\"\"Calculate correct shape of the `strengths` for a multi_coupling.\"\"\"\n    def possible_multi_couplings(self, ops, strength=None):\n        \"\"\"Generalization of :meth:`possible_couplings` to couplings with more than 2 sites.\"\"\"\n    def plot_sites(self, ax, markers=['o', '^', 's', 'p', 'h', 'D'], labels=None, **kwargs):\n        \"\"\"Plot the sites of the lattice with markers.\"\"\"\n    def plot_order(self, ax, order=None, textkwargs={}, **kwargs):\n        \"\"\"Plot a line connecting sites in the specified \"order\" and text labels enumerating them.\"\"\"\n    def plot_coupling(self, ax, coupling=None, wrap=False, **kwargs):\n        \"\"\"Plot lines connecting nearest neighbors of the lattice.\"\"\"\n    def plot_basis(self, ax, origin=(0.0, 0.0), shade=None, **kwargs):\n        \"\"\"Plot arrows indicating the basis vectors of the lattice.\"\"\"\n    def plot_reciprocal_basis(self, ax, origin=(0.0, 0.0), plot_symmetric=True, **kwargs):\n        \"\"\"Plot arrows indicating the basis vectors of the reciprocal lattice.\"\"\"\n    def plot_bc_identified(self, ax, direction=-1, origin=None, cylinder_axis=False, **kwargs):\n        \"\"\"Mark two sites identified by periodic boundary conditions.\"\"\"\n    def plot_brillouin_zone(self, ax, *args, **kwargs):\n        \"\"\"Plot the Brillouin Zone of the lattice.\"\"\"\n    def reciprocal_basis(self):\n        \"\"\"Reciprocal basis vectors of the lattice.\"\"\"\n    def BZ(self):\n        \"\"\"The Brillouin Zone as :class:`SimpleBZ`\"\"\"\n    def with_grouped_sites(self, grouped_sites):\n        \"\"\"Return a lattice with sites given by `grouped_sites`.\"\"\"",
    "search_text": "tenpy.models.lattice.lattice # api definition: tenpy.models.lattice.lattice\nclass lattice:\n    \"\"\"a general, regular lattice.\"\"\"\n    def __init__(self, ls, unit_cell, order='default', bc='open', bc_mps='finite', basis=none, positions=none, pairs=none): pass\n    def test_sanity(self):\n        \"\"\"sanity check.\"\"\"\n    def unit_cell(self): pass\n    def unit_cell(self, value): pass\n    def from_model_params(cls, model_params, sites):\n        \"\"\"initialize by reading sizes, boundary conditions etc from `model_params`.\"\"\"\n    def copy(self):\n        \"\"\"shallow copy of `self`.\"\"\"\n    def save_hdf5(self, hdf5_saver, h5gr, subpath):\n        \"\"\"export `self` into a hdf5 file.\"\"\"\n    def from_hdf5(cls, hdf5_loader, h5gr, subpath):\n        \"\"\"load instance from a hdf5 file.\"\"\"\n    def basis(self): pass\n    def basis(self, new_basis): pass\n    def dim(self):\n        \"\"\"the dimension of the lattice.\"\"\"\n    def order(self):\n        \"\"\"defines an ordering of the lattice sites, thus mapping the lattice to a 1d chain.\"\"\"\n    def order(self, order_): pass\n    def ordering(self, order):\n        \"\"\"provide possible orderings of the `n` lattice sites.\"\"\"\n    def boundary_conditions(self):\n        \"\"\"human-readable list of boundary conditions from :attr:`bc` and :attr:`bc_shift`.\"\"\"\n    def boundary_conditions(self, bc): pass\n    def cylinder_axis(self):\n        \"\"\"direction of the cylinder axis.\"\"\"\n    def extract_segment(self, first=0, last=none, enlarge=none):\n        \"\"\"extract a finite segment from an infinite/large system.\"\"\"\n    def enlarge_mps_unit_cell(self, factor=2):\n        \"\"\"repeat the unit cell for infinite mps boundary conditions; in place.\"\"\"\n    def position(self, lat_idx):\n        \"\"\"return 'space' position of one or multiple sites.\"\"\"\n    def site(self, i):\n        \"\"\"return :class:`~tenpy.networks.site.site` instance corresponding to an mps index `i`\"\"\"\n    def mps_sites(self):\n        \"\"\"return a list of sites for all mps indices.\"\"\"\n    def mps2lat_idx(self, i):\n        \"\"\"translate mps index `i` to lattice indices ``(x_0, ..., x_{dim-1}, u)``.\"\"\"\n    def lat2mps_idx(self, lat_idx):\n        \"\"\"translate lattice indices ``(x_0, ..., x_{d-1}, u)`` to mps index `i`.\"\"\"\n    def mps_idx_fix_u(self, u=none):\n        \"\"\"return an index array of mps indices for which the site within the unit cell is `u`.\"\"\"\n    def mps_lat_idx_fix_u(self, u=none):\n        \"\"\"similar as :meth:`mps_idx_fix_u`, but return also the corresponding lattice indices.\"\"\"\n    def mps2lat_values(self, a, axes=0, u=none):\n        \"\"\"reshape/reorder `a` to replace an mps index by lattice indices.\"\"\"\n    def mps2lat_values_masked(self, a, axes=-1, mps_inds=none, include_u=none):\n        \"\"\"reshape/reorder an array `a` to replace an mps index by lattice indices.\"\"\"\n    def count_neighbors(self, u=0, key='nearest_neighbors'):\n        \"\"\"count e.g. the number of nearest neighbors for a site in the bulk.\"\"\"\n    def distance(self, u1, u2, dx):\n        \"\"\"get the distance for a given coupling between two sites in the lattice.\"\"\"\n    def find_coupling_pairs(self, max_dx=3, cutoff=none, eps=1e-10):\n        \"\"\"automatically find coupling pairs grouped by distances.\"\"\"\n    def coupling_shape(self, dx):\n        \"\"\"calculate correct shape of the `strengths` for a coupling.\"\"\"\n    def possible_couplings(self, u1, u2, dx, strength=none):\n        \"\"\"find possible mps indices for two-site couplings.\"\"\"\n    def multi_coupling_shape(self, dx):\n        \"\"\"calculate correct shape of the `strengths` for a multi_coupling.\"\"\"\n    def possible_multi_couplings(self, ops, strength=none):\n        \"\"\"generalization of :meth:`possible_couplings` to couplings with more than 2 sites.\"\"\"\n    def plot_sites(self, ax, markers=['o', '^', 's', 'p', 'h', 'd'], labels=none, **kwargs):\n        \"\"\"plot the sites of the lattice with markers.\"\"\"\n    def plot_order(self, ax, order=none, textkwargs={}, **kwargs):\n        \"\"\"plot a line connecting sites in the specified \"order\" and text labels enumerating them.\"\"\"\n    def plot_coupling(self, ax, coupling=none, wrap=false, **kwargs):\n        \"\"\"plot lines connecting nearest neighbors of the lattice.\"\"\"\n    def plot_basis(self, ax, origin=(0.0, 0.0), shade=none, **kwargs):\n        \"\"\"plot arrows indicating the basis vectors of the lattice.\"\"\"\n    def plot_reciprocal_basis(self, ax, origin=(0.0, 0.0), plot_symmetric=true, **kwargs):\n        \"\"\"plot arrows indicating the basis vectors of the reciprocal lattice.\"\"\"\n    def plot_bc_identified(self, ax, direction=-1, origin=none, cylinder_axis=false, **kwargs):\n        \"\"\"mark two sites identified by periodic boundary conditions.\"\"\"\n    def plot_brillouin_zone(self, ax, *args, **kwargs):\n        \"\"\"plot the brillouin zone of the lattice.\"\"\"\n    def reciprocal_basis(self):\n        \"\"\"reciprocal basis vectors of the lattice.\"\"\"\n    def bz(self):\n        \"\"\"the brillouin zone as :class:`simplebz`\"\"\"\n    def with_grouped_sites(self, grouped_sites):\n        \"\"\"return a lattice with sites given by `grouped_sites`.\"\"\" class lattice tenpy.models.lattice",
    "tokens": 1218
  },
  {
    "category": "api",
    "name": "tenpy.models.lattice.TrivialLattice",
    "content": "# API Definition: tenpy.models.lattice.TrivialLattice\nclass TrivialLattice:\n    \"\"\"Trivial lattice consisting of a single (possibly large) unit cell in 1D.\"\"\"\n    def __init__(self, mps_sites, **kwargs): pass",
    "search_text": "tenpy.models.lattice.triviallattice # api definition: tenpy.models.lattice.triviallattice\nclass triviallattice:\n    \"\"\"trivial lattice consisting of a single (possibly large) unit cell in 1d.\"\"\"\n    def __init__(self, mps_sites, **kwargs): pass class triviallattice tenpy.models.lattice",
    "tokens": 55
  },
  {
    "category": "api",
    "name": "tenpy.models.lattice.SimpleLattice",
    "content": "# API Definition: tenpy.models.lattice.SimpleLattice\nclass SimpleLattice:\n    \"\"\"A lattice with a unit cell consisting of just a single site.\"\"\"\n    def __init__(self, Ls, site, **kwargs): pass\n    def mps2lat_values(self, A, axes=0, u=None):\n        \"\"\"Same as :meth:`Lattice.mps2lat_values`, but ignore ``u``, setting it to ``0``.\"\"\"",
    "search_text": "tenpy.models.lattice.simplelattice # api definition: tenpy.models.lattice.simplelattice\nclass simplelattice:\n    \"\"\"a lattice with a unit cell consisting of just a single site.\"\"\"\n    def __init__(self, ls, site, **kwargs): pass\n    def mps2lat_values(self, a, axes=0, u=none):\n        \"\"\"same as :meth:`lattice.mps2lat_values`, but ignore ``u``, setting it to ``0``.\"\"\" class simplelattice tenpy.models.lattice",
    "tokens": 95
  },
  {
    "category": "api",
    "name": "tenpy.models.lattice.MultiSpeciesLattice",
    "content": "# API Definition: tenpy.models.lattice.MultiSpeciesLattice\nclass MultiSpeciesLattice:\n    \"\"\"A variant of a :class:`SimpleLattice` replacing the elementary site with a set of sites.\"\"\"\n    def __init__(self, simple_lattice, species_sites, species_names=None): pass\n    def ordering(self, order):\n        \"\"\"Define orderings as for the `simple_lattice` with priority for within the unit cell.\"\"\"\n    def self_u_to_simple_u(self, self_u):\n        \"\"\"Get index `u` of the `simple_lattice` from index `u` in `self`.\"\"\"\n    def self_u_to_species_idx(self, self_u):\n        \"\"\"Get species index for unit cell index.\"\"\"\n    def simple_u_to_species_u(self, simple_u, species_idx):\n        \"\"\"Get index `u` in `self` from the `u` in the `simple_lattice` and the species index.\"\"\"",
    "search_text": "tenpy.models.lattice.multispecieslattice # api definition: tenpy.models.lattice.multispecieslattice\nclass multispecieslattice:\n    \"\"\"a variant of a :class:`simplelattice` replacing the elementary site with a set of sites.\"\"\"\n    def __init__(self, simple_lattice, species_sites, species_names=none): pass\n    def ordering(self, order):\n        \"\"\"define orderings as for the `simple_lattice` with priority for within the unit cell.\"\"\"\n    def self_u_to_simple_u(self, self_u):\n        \"\"\"get index `u` of the `simple_lattice` from index `u` in `self`.\"\"\"\n    def self_u_to_species_idx(self, self_u):\n        \"\"\"get species index for unit cell index.\"\"\"\n    def simple_u_to_species_u(self, simple_u, species_idx):\n        \"\"\"get index `u` in `self` from the `u` in the `simple_lattice` and the species index.\"\"\" class multispecieslattice tenpy.models.lattice",
    "tokens": 192
  },
  {
    "category": "api",
    "name": "tenpy.models.lattice.IrregularLattice",
    "content": "# API Definition: tenpy.models.lattice.IrregularLattice\nclass IrregularLattice:\n    \"\"\"A variant of a regular lattice, where we might have extra sites or sites missing.\"\"\"\n    def __init__(self, regular_lattice, remove=None, add=None, add_unit_cell=[], add_positions=None): pass\n    def save_hdf5(self, hdf5_saver, h5gr, subpath): pass\n    def from_hdf5(cls, hdf5_loader, h5gr, subpath): pass\n    def ordering(self, order):\n        \"\"\"Provide possible orderings of the lattice sites.\"\"\"\n    def order(self, order_): pass\n    def mps_idx_fix_u(self, u=None): pass",
    "search_text": "tenpy.models.lattice.irregularlattice # api definition: tenpy.models.lattice.irregularlattice\nclass irregularlattice:\n    \"\"\"a variant of a regular lattice, where we might have extra sites or sites missing.\"\"\"\n    def __init__(self, regular_lattice, remove=none, add=none, add_unit_cell=[], add_positions=none): pass\n    def save_hdf5(self, hdf5_saver, h5gr, subpath): pass\n    def from_hdf5(cls, hdf5_loader, h5gr, subpath): pass\n    def ordering(self, order):\n        \"\"\"provide possible orderings of the lattice sites.\"\"\"\n    def order(self, order_): pass\n    def mps_idx_fix_u(self, u=none): pass class irregularlattice tenpy.models.lattice",
    "tokens": 151
  },
  {
    "category": "api",
    "name": "tenpy.models.lattice.HelicalLattice",
    "content": "# API Definition: tenpy.models.lattice.HelicalLattice\nclass HelicalLattice:\n    \"\"\"Translation invariant version of a tilted, regular 2D lattice.\"\"\"\n    def __init__(self, regular_lattice, N_unit_cells): pass\n    def save_hdf5(self, hdf5_saver, h5gr, subpath): pass\n    def from_hdf5(cls, hdf5_loader, h5gr, subpath): pass\n    def ordering(self, order):\n        \"\"\"Provide possible orderings of the lattice sites.\"\"\"\n    def order(self, order_): pass\n    def mps2lat_idx(self, i): pass\n    def lat2mps_idx(self, lat_idx): pass\n    def mps2lat_values(self, *args, **kwargs):\n        \"\"\"Not implemented, use :meth:`mps2lat_values_masked` instead.\"\"\"\n    def mps2lat_values_masked(self, *args, **kwargs): pass\n    def enlarge_mps_unit_cell(self, factor=2):\n        \"\"\"Repeat the unit cell for infinite MPS boundary conditions; in place.\"\"\"\n    def possible_couplings(self, u1, u2, dx, strength=None): pass\n    def possible_multi_couplings(self, ops, strength=None): pass\n    def plot_coupling(self, ax, coupling=None, wrap=True, **kwargs): pass",
    "search_text": "tenpy.models.lattice.helicallattice # api definition: tenpy.models.lattice.helicallattice\nclass helicallattice:\n    \"\"\"translation invariant version of a tilted, regular 2d lattice.\"\"\"\n    def __init__(self, regular_lattice, n_unit_cells): pass\n    def save_hdf5(self, hdf5_saver, h5gr, subpath): pass\n    def from_hdf5(cls, hdf5_loader, h5gr, subpath): pass\n    def ordering(self, order):\n        \"\"\"provide possible orderings of the lattice sites.\"\"\"\n    def order(self, order_): pass\n    def mps2lat_idx(self, i): pass\n    def lat2mps_idx(self, lat_idx): pass\n    def mps2lat_values(self, *args, **kwargs):\n        \"\"\"not implemented, use :meth:`mps2lat_values_masked` instead.\"\"\"\n    def mps2lat_values_masked(self, *args, **kwargs): pass\n    def enlarge_mps_unit_cell(self, factor=2):\n        \"\"\"repeat the unit cell for infinite mps boundary conditions; in place.\"\"\"\n    def possible_couplings(self, u1, u2, dx, strength=none): pass\n    def possible_multi_couplings(self, ops, strength=none): pass\n    def plot_coupling(self, ax, coupling=none, wrap=true, **kwargs): pass class helicallattice tenpy.models.lattice",
    "tokens": 284
  },
  {
    "category": "api",
    "name": "tenpy.models.lattice.Chain",
    "content": "# API Definition: tenpy.models.lattice.Chain\nclass Chain:\n    \"\"\"A chain of L equal sites.\"\"\"\n    def __init__(self, L, site, **kwargs): pass\n    def ordering(self, order):\n        \"\"\"Provide possible orderings of the `N` lattice sites.\"\"\"",
    "search_text": "tenpy.models.lattice.chain # api definition: tenpy.models.lattice.chain\nclass chain:\n    \"\"\"a chain of l equal sites.\"\"\"\n    def __init__(self, l, site, **kwargs): pass\n    def ordering(self, order):\n        \"\"\"provide possible orderings of the `n` lattice sites.\"\"\" class chain tenpy.models.lattice",
    "tokens": 60
  },
  {
    "category": "api",
    "name": "tenpy.models.lattice.Ladder",
    "content": "# API Definition: tenpy.models.lattice.Ladder\nclass Ladder:\n    \"\"\"A ladder coupling two chains.\"\"\"\n    def __init__(self, L, sites, **kwargs): pass\n    def ordering(self, order):\n        \"\"\"Provide possible orderings of the `N` lattice sites.\"\"\"",
    "search_text": "tenpy.models.lattice.ladder # api definition: tenpy.models.lattice.ladder\nclass ladder:\n    \"\"\"a ladder coupling two chains.\"\"\"\n    def __init__(self, l, sites, **kwargs): pass\n    def ordering(self, order):\n        \"\"\"provide possible orderings of the `n` lattice sites.\"\"\" class ladder tenpy.models.lattice",
    "tokens": 61
  },
  {
    "category": "api",
    "name": "tenpy.models.lattice.NLegLadder",
    "content": "# API Definition: tenpy.models.lattice.NLegLadder\nclass NLegLadder:\n    \"\"\"A ladder coupling N chains.\"\"\"\n    def __init__(self, L, N, sites, **kwargs): pass\n    def from_model_params(cls, model_params, sites):\n        \"\"\"Initialize by reading sizes, boundary conditions etc from `model_params`.\"\"\"\n    def ordering(self, order):\n        \"\"\"Provide possible orderings of the `N` lattice sites.\"\"\"",
    "search_text": "tenpy.models.lattice.nlegladder # api definition: tenpy.models.lattice.nlegladder\nclass nlegladder:\n    \"\"\"a ladder coupling n chains.\"\"\"\n    def __init__(self, l, n, sites, **kwargs): pass\n    def from_model_params(cls, model_params, sites):\n        \"\"\"initialize by reading sizes, boundary conditions etc from `model_params`.\"\"\"\n    def ordering(self, order):\n        \"\"\"provide possible orderings of the `n` lattice sites.\"\"\" class nlegladder tenpy.models.lattice",
    "tokens": 95
  },
  {
    "category": "api",
    "name": "tenpy.models.lattice.Square",
    "content": "# API Definition: tenpy.models.lattice.Square\nclass Square:\n    \"\"\"A square lattice.\"\"\"\n    def __init__(self, Lx, Ly, site, **kwargs): pass",
    "search_text": "tenpy.models.lattice.square # api definition: tenpy.models.lattice.square\nclass square:\n    \"\"\"a square lattice.\"\"\"\n    def __init__(self, lx, ly, site, **kwargs): pass class square tenpy.models.lattice",
    "tokens": 39
  },
  {
    "category": "api",
    "name": "tenpy.models.lattice.Triangular",
    "content": "# API Definition: tenpy.models.lattice.Triangular\nclass Triangular:\n    \"\"\"A triangular lattice.\"\"\"\n    def __init__(self, Lx, Ly, site, **kwargs): pass",
    "search_text": "tenpy.models.lattice.triangular # api definition: tenpy.models.lattice.triangular\nclass triangular:\n    \"\"\"a triangular lattice.\"\"\"\n    def __init__(self, lx, ly, site, **kwargs): pass class triangular tenpy.models.lattice",
    "tokens": 41
  },
  {
    "category": "api",
    "name": "tenpy.models.lattice.Honeycomb",
    "content": "# API Definition: tenpy.models.lattice.Honeycomb\nclass Honeycomb:\n    \"\"\"A honeycomb lattice.\"\"\"\n    def __init__(self, Lx, Ly, sites, **kwargs): pass\n    def ordering(self, order):\n        \"\"\"Provide possible orderings of the `N` lattice sites.\"\"\"",
    "search_text": "tenpy.models.lattice.honeycomb # api definition: tenpy.models.lattice.honeycomb\nclass honeycomb:\n    \"\"\"a honeycomb lattice.\"\"\"\n    def __init__(self, lx, ly, sites, **kwargs): pass\n    def ordering(self, order):\n        \"\"\"provide possible orderings of the `n` lattice sites.\"\"\" class honeycomb tenpy.models.lattice",
    "tokens": 64
  },
  {
    "category": "api",
    "name": "tenpy.models.lattice.Kagome",
    "content": "# API Definition: tenpy.models.lattice.Kagome\nclass Kagome:\n    \"\"\"A Kagome lattice.\"\"\"\n    def __init__(self, Lx, Ly, sites, **kwargs): pass\n    def ordering(self, order):\n        \"\"\"Provide possible orderings of the `N` lattice sites.\"\"\"",
    "search_text": "tenpy.models.lattice.kagome # api definition: tenpy.models.lattice.kagome\nclass kagome:\n    \"\"\"a kagome lattice.\"\"\"\n    def __init__(self, lx, ly, sites, **kwargs): pass\n    def ordering(self, order):\n        \"\"\"provide possible orderings of the `n` lattice sites.\"\"\" class kagome tenpy.models.lattice",
    "tokens": 64
  },
  {
    "category": "api",
    "name": "tenpy.models.lattice.SimpleBZ",
    "content": "# API Definition: tenpy.models.lattice.SimpleBZ\nclass SimpleBZ:\n    \"\"\"Helper class to provide an interface for the Brillouin Zone of a given lattice.\"\"\"\n    def __init__(self, vertices, basis, dim: int): pass\n    def order_vertices(self, vertices): pass\n    def from_recip_basis_vectors(cls, basis_vectors, dim): pass\n    def area(self): pass\n    def contains_points(self, points):\n        \"\"\"Checks whether given points lie inside the 1st Brillouin Zone.\"\"\"\n    def reduce_points(self, points):\n        \"\"\"Bring a set of points into 1st Brillouin Zone.\"\"\"\n    def plot_brillouin_zone(self, *args, **kwargs):\n        \"\"\"Plot the brillouin zone of the lattice.\"\"\"\n    def lagrange_lattice_reduction(basis):\n        \"\"\"Short implementation of Lagrange's algorithm for 2D lattice reduction.\"\"\"",
    "search_text": "tenpy.models.lattice.simplebz # api definition: tenpy.models.lattice.simplebz\nclass simplebz:\n    \"\"\"helper class to provide an interface for the brillouin zone of a given lattice.\"\"\"\n    def __init__(self, vertices, basis, dim: int): pass\n    def order_vertices(self, vertices): pass\n    def from_recip_basis_vectors(cls, basis_vectors, dim): pass\n    def area(self): pass\n    def contains_points(self, points):\n        \"\"\"checks whether given points lie inside the 1st brillouin zone.\"\"\"\n    def reduce_points(self, points):\n        \"\"\"bring a set of points into 1st brillouin zone.\"\"\"\n    def plot_brillouin_zone(self, *args, **kwargs):\n        \"\"\"plot the brillouin zone of the lattice.\"\"\"\n    def lagrange_lattice_reduction(basis):\n        \"\"\"short implementation of lagrange's algorithm for 2d lattice reduction.\"\"\" class simplebz tenpy.models.lattice",
    "tokens": 190
  },
  {
    "category": "api",
    "name": "tenpy.models.lattice.get_lattice",
    "content": "# API Function: tenpy.models.lattice.get_lattice\ndef get_lattice(lattice_name):\n    \"\"\"Given the name of a :class:`Lattice` class, get the lattice class itself.\"\"\"",
    "search_text": "tenpy.models.lattice.get_lattice # api function: tenpy.models.lattice.get_lattice\ndef get_lattice(lattice_name):\n    \"\"\"given the name of a :class:`lattice` class, get the lattice class itself.\"\"\" function get_lattice",
    "tokens": 42
  },
  {
    "category": "api",
    "name": "tenpy.models.lattice.get_order",
    "content": "# API Function: tenpy.models.lattice.get_order\ndef get_order(shape, snake_winding, priority=None):\n    \"\"\"Built the :attr:`Lattice.order` in (Snake-) C-Style for a given lattice shape.\"\"\"",
    "search_text": "tenpy.models.lattice.get_order # api function: tenpy.models.lattice.get_order\ndef get_order(shape, snake_winding, priority=none):\n    \"\"\"built the :attr:`lattice.order` in (snake-) c-style for a given lattice shape.\"\"\" function get_order",
    "tokens": 48
  },
  {
    "category": "api",
    "name": "tenpy.models.lattice.get_order_grouped",
    "content": "# API Function: tenpy.models.lattice.get_order_grouped\ndef get_order_grouped(shape, groups, priority=None):\n    \"\"\"Variant of :func:`get_order`, grouping some sites of the unit cell.\"\"\"",
    "search_text": "tenpy.models.lattice.get_order_grouped # api function: tenpy.models.lattice.get_order_grouped\ndef get_order_grouped(shape, groups, priority=none):\n    \"\"\"variant of :func:`get_order`, grouping some sites of the unit cell.\"\"\" function get_order_grouped",
    "tokens": 44
  },
  {
    "category": "api",
    "name": "tenpy.models.spins.SpinModel",
    "content": "# API Definition: tenpy.models.spins.SpinModel\nclass SpinModel:\n    \"\"\"Spin-S sites coupled by nearest neighbor interactions.\"\"\"\n    def init_sites(self, model_params): pass\n    def init_terms(self, model_params): pass",
    "search_text": "tenpy.models.spins.spinmodel # api definition: tenpy.models.spins.spinmodel\nclass spinmodel:\n    \"\"\"spin-s sites coupled by nearest neighbor interactions.\"\"\"\n    def init_sites(self, model_params): pass\n    def init_terms(self, model_params): pass class spinmodel tenpy.models.spins",
    "tokens": 49
  },
  {
    "category": "api",
    "name": "tenpy.models.spins.SpinChain",
    "content": "# API Definition: tenpy.models.spins.SpinChain\nclass SpinChain:\n    \"\"\"The :class:`SpinModel` on a Chain, suitable for TEBD.\"\"\"\n",
    "search_text": "tenpy.models.spins.spinchain # api definition: tenpy.models.spins.spinchain\nclass spinchain:\n    \"\"\"the :class:`spinmodel` on a chain, suitable for tebd.\"\"\"\n class spinchain tenpy.models.spins",
    "tokens": 36
  },
  {
    "category": "api",
    "name": "tenpy.models.spins.DipolarSpinChain",
    "content": "# API Definition: tenpy.models.spins.DipolarSpinChain\nclass DipolarSpinChain:\n    \"\"\"Dipole conserving H3-H4 spin-S chain.\"\"\"\n    def init_lattice(self, model_params):\n        \"\"\"Initialize a 1D lattice\"\"\"\n    def init_terms(self, model_params):\n        \"\"\"Add the onsite and coupling terms to the model\"\"\"",
    "search_text": "tenpy.models.spins.dipolarspinchain # api definition: tenpy.models.spins.dipolarspinchain\nclass dipolarspinchain:\n    \"\"\"dipole conserving h3-h4 spin-s chain.\"\"\"\n    def init_lattice(self, model_params):\n        \"\"\"initialize a 1d lattice\"\"\"\n    def init_terms(self, model_params):\n        \"\"\"add the onsite and coupling terms to the model\"\"\" class dipolarspinchain tenpy.models.spins",
    "tokens": 76
  },
  {
    "category": "api",
    "name": "tenpy.models.haldane.BosonicHaldaneModel",
    "content": "# API Definition: tenpy.models.haldane.BosonicHaldaneModel\nclass BosonicHaldaneModel:\n    \"\"\"Hardcore bosonic Haldane model.\"\"\"\n    def init_sites(self, model_params): pass\n    def init_terms(self, model_params): pass",
    "search_text": "tenpy.models.haldane.bosonichaldanemodel # api definition: tenpy.models.haldane.bosonichaldanemodel\nclass bosonichaldanemodel:\n    \"\"\"hardcore bosonic haldane model.\"\"\"\n    def init_sites(self, model_params): pass\n    def init_terms(self, model_params): pass class bosonichaldanemodel tenpy.models.haldane",
    "tokens": 58
  },
  {
    "category": "api",
    "name": "tenpy.models.haldane.FermionicHaldaneModel",
    "content": "# API Definition: tenpy.models.haldane.FermionicHaldaneModel\nclass FermionicHaldaneModel:\n    \"\"\"Spinless fermionic Haldane model.\"\"\"\n    def init_sites(self, model_params): pass\n    def init_terms(self, model_params): pass",
    "search_text": "tenpy.models.haldane.fermionichaldanemodel # api definition: tenpy.models.haldane.fermionichaldanemodel\nclass fermionichaldanemodel:\n    \"\"\"spinless fermionic haldane model.\"\"\"\n    def init_sites(self, model_params): pass\n    def init_terms(self, model_params): pass class fermionichaldanemodel tenpy.models.haldane",
    "tokens": 58
  },
  {
    "category": "api",
    "name": "tenpy.models.spins_nnn.SpinChainNNN",
    "content": "# API Definition: tenpy.models.spins_nnn.SpinChainNNN\nclass SpinChainNNN:\n    \"\"\"Spin-S sites coupled by (next-)nearest neighbor interactions on a `GroupedSite`.\"\"\"\n    def init_sites(self, model_params): pass\n    def init_terms(self, model_params): pass",
    "search_text": "tenpy.models.spins_nnn.spinchainnnn # api definition: tenpy.models.spins_nnn.spinchainnnn\nclass spinchainnnn:\n    \"\"\"spin-s sites coupled by (next-)nearest neighbor interactions on a `groupedsite`.\"\"\"\n    def init_sites(self, model_params): pass\n    def init_terms(self, model_params): pass class spinchainnnn tenpy.models.spins_nnn",
    "tokens": 65
  },
  {
    "category": "api",
    "name": "tenpy.models.spins_nnn.SpinChainNNN2",
    "content": "# API Definition: tenpy.models.spins_nnn.SpinChainNNN2\nclass SpinChainNNN2:\n    \"\"\"Spin-S sites coupled by next-nearest neighbor interactions.\"\"\"\n    def init_sites(self, model_params): pass\n    def init_terms(self, model_params): pass",
    "search_text": "tenpy.models.spins_nnn.spinchainnnn2 # api definition: tenpy.models.spins_nnn.spinchainnnn2\nclass spinchainnnn2:\n    \"\"\"spin-s sites coupled by next-nearest neighbor interactions.\"\"\"\n    def init_sites(self, model_params): pass\n    def init_terms(self, model_params): pass class spinchainnnn2 tenpy.models.spins_nnn",
    "tokens": 59
  },
  {
    "category": "api",
    "name": "tenpy.networks.mpo.MPO",
    "content": "# API Definition: tenpy.networks.mpo.MPO\nclass MPO:\n    \"\"\"Matrix product operator, finite (MPO) or infinite (iMPO).\"\"\"\n    def __init__(self, sites, Ws, bc='finite', IdL=None, IdR=None, max_range=None, explicit_plus_hc=False, mps_unit_cell_width=None): pass\n    def copy(self):\n        \"\"\"Make a shallow copy of `self`.\"\"\"\n    def save_hdf5(self, hdf5_saver, h5gr, subpath):\n        \"\"\"Export `self` into a HDF5 file.\"\"\"\n    def from_hdf5(cls, hdf5_loader, h5gr, subpath):\n        \"\"\"Load instance from a HDF5 file.\"\"\"\n    def from_grids(cls, sites, grids, bc='finite', IdL=None, IdR=None, Ws_qtotal=None, legs=None, max_range=None, explicit_plus_hc=False, mps_unit_cell_width=None):\n        \"\"\"Initialize an MPO from `grids`.\"\"\"\n    def from_wavepacket(cls, sites, coeff, op, eps=1e-15, unit_cell_width=None):\n        \"\"\"Create a (finite) MPO wave packet representing ``sum_i coeff[i] op_i``.\"\"\"\n    def from_Wflat(cls, sites, Wflat, bc='finite', dtype=None, permute=True, legL=None, IdL=None, IdR=None, max_range=None, unit_cell_width=None):\n        \"\"\"Construct a matrix product operator from a set of numpy array `Wflat`.\"\"\"\n    def test_sanity(self):\n        \"\"\"Sanity check, raises ValueErrors, if something is wrong.\"\"\"\n    def chi(self):\n        \"\"\"Dimensions of the virtual bonds.\"\"\"\n    def get_W(self, i, copy=False):\n        \"\"\"Return `W` at site `i`.\"\"\"\n    def set_W(self, i, W):\n        \"\"\"Set `W` at site `i`. Note that ``W`` may be modified in-place.\"\"\"\n    def get_IdL(self, i):\n        \"\"\"Return index of `IdL` at bond to the *left* of site `i`.\"\"\"\n    def get_IdR(self, i):\n        \"\"\"Return index of `IdR` at bond to the *right* of site `i`.\"\"\"\n    def enlarge_mps_unit_cell(self, factor=2):\n        \"\"\"Repeat the unit cell for infinite MPS boundary conditions; in place.\"\"\"\n    def group_sites(self, n=2, grouped_sites=None):\n        \"\"\"Modify `self` inplace to group sites.\"\"\"\n    def extract_segment(self, first, last):\n        \"\"\"Extract a segment from the MPO.\"\"\"\n    def sort_legcharges(self):\n        \"\"\"Sort virtual legs by charges. In place.\"\"\"\n    def make_U(self, dt, approximation='II'):\n        \"\"\"Creates the U_I or U_II propagator.\"\"\"\n    def make_U_I(self, dt):\n        \"\"\"Creates the :math:`U_I` propagator with `W_I` tensors.\"\"\"\n    def make_U_II(self, dt):\n        \"\"\"Creates the :math:`U_{II}` propagator.\"\"\"\n    def expectation_value(self, psi, tol=1e-10, max_range=100, init_env_data={}):\n        \"\"\"Calculate ``<psi|self|psi>/<psi|psi>`` (or density for infinite).\"\"\"\n    def expectation_value_finite(self, psi, init_env_data={}):\n        \"\"\"Calculate ``<psi|self|psi>/<psi|psi>`` for finite MPS.\"\"\"\n    def expectation_value_TM(self, psi, tol=1e-10, init_env_data={}):\n        \"\"\"Calculate ``<psi|self|psi>/<psi|psi> / L`` from the MPOTransferMatrix.\"\"\"\n    def expectation_value_power(self, psi, tol=1e-10, max_range=100):\n        \"\"\"Calculate ``<psi|self|psi>/<psi|psi>`` with a power-method.\"\"\"\n    def variance(self, psi, exp_val=None):\n        \"\"\"Calculate ``<psi|self^2|psi> - <psi|self|psi>^2``.\"\"\"\n    def prefactor(self, i, ops):\n        \"\"\"Get prefactor for a given string of operators in self.\"\"\"\n    def to_TermList(self, op_basis, start=None, max_range=None, cutoff=1e-12, ignore=['Id', 'JW']):\n        \"\"\"Obtain a `TermList` represented by self.\"\"\"\n    def dagger(self):\n        \"\"\"Return hermitian conjugate copy of self.\"\"\"\n    def is_hermitian(self, eps=1e-10, max_range=None):\n        \"\"\"Check if `self` is a hermitian MPO.\"\"\"\n    def is_equal(self, other, eps=1e-10, max_range=None):\n        \"\"\"Check if `self` and `other` represent the same MPO to precision `eps`.\"\"\"\n    def apply(self, psi, options):\n        \"\"\"Apply `self` to an MPS `psi` and compress `psi` in place.\"\"\"\n    def apply_naively(self, psi):\n        \"\"\"Applies an MPO to an MPS (in place) naively, without compression.\"\"\"\n    def apply_zipup(self, psi, options):\n        \"\"\"Applies an MPO to an MPS (in place) with the zip-up method.\"\"\"\n    def plus_identity(self, alpha, beta, sites=[0]):\n        \"\"\"Compute a new MPO :math:`alpha * 1 + beta * \\mathtt{self}`.\"\"\"\n    def overlap(self, other, understood_infinite: bool=False, num_sites: int=None):\n        \"\"\"Overlap between two MPOs.\"\"\"\n    def distance(self, other, understood_infinite: bool=False, num_sites: int=None):\n        \"\"\"The Frobenius distance induced by the inner product :meth:`overlap`.\"\"\"",
    "search_text": "tenpy.networks.mpo.mpo # api definition: tenpy.networks.mpo.mpo\nclass mpo:\n    \"\"\"matrix product operator, finite (mpo) or infinite (impo).\"\"\"\n    def __init__(self, sites, ws, bc='finite', idl=none, idr=none, max_range=none, explicit_plus_hc=false, mps_unit_cell_width=none): pass\n    def copy(self):\n        \"\"\"make a shallow copy of `self`.\"\"\"\n    def save_hdf5(self, hdf5_saver, h5gr, subpath):\n        \"\"\"export `self` into a hdf5 file.\"\"\"\n    def from_hdf5(cls, hdf5_loader, h5gr, subpath):\n        \"\"\"load instance from a hdf5 file.\"\"\"\n    def from_grids(cls, sites, grids, bc='finite', idl=none, idr=none, ws_qtotal=none, legs=none, max_range=none, explicit_plus_hc=false, mps_unit_cell_width=none):\n        \"\"\"initialize an mpo from `grids`.\"\"\"\n    def from_wavepacket(cls, sites, coeff, op, eps=1e-15, unit_cell_width=none):\n        \"\"\"create a (finite) mpo wave packet representing ``sum_i coeff[i] op_i``.\"\"\"\n    def from_wflat(cls, sites, wflat, bc='finite', dtype=none, permute=true, legl=none, idl=none, idr=none, max_range=none, unit_cell_width=none):\n        \"\"\"construct a matrix product operator from a set of numpy array `wflat`.\"\"\"\n    def test_sanity(self):\n        \"\"\"sanity check, raises valueerrors, if something is wrong.\"\"\"\n    def chi(self):\n        \"\"\"dimensions of the virtual bonds.\"\"\"\n    def get_w(self, i, copy=false):\n        \"\"\"return `w` at site `i`.\"\"\"\n    def set_w(self, i, w):\n        \"\"\"set `w` at site `i`. note that ``w`` may be modified in-place.\"\"\"\n    def get_idl(self, i):\n        \"\"\"return index of `idl` at bond to the *left* of site `i`.\"\"\"\n    def get_idr(self, i):\n        \"\"\"return index of `idr` at bond to the *right* of site `i`.\"\"\"\n    def enlarge_mps_unit_cell(self, factor=2):\n        \"\"\"repeat the unit cell for infinite mps boundary conditions; in place.\"\"\"\n    def group_sites(self, n=2, grouped_sites=none):\n        \"\"\"modify `self` inplace to group sites.\"\"\"\n    def extract_segment(self, first, last):\n        \"\"\"extract a segment from the mpo.\"\"\"\n    def sort_legcharges(self):\n        \"\"\"sort virtual legs by charges. in place.\"\"\"\n    def make_u(self, dt, approximation='ii'):\n        \"\"\"creates the u_i or u_ii propagator.\"\"\"\n    def make_u_i(self, dt):\n        \"\"\"creates the :math:`u_i` propagator with `w_i` tensors.\"\"\"\n    def make_u_ii(self, dt):\n        \"\"\"creates the :math:`u_{ii}` propagator.\"\"\"\n    def expectation_value(self, psi, tol=1e-10, max_range=100, init_env_data={}):\n        \"\"\"calculate ``<psi|self|psi>/<psi|psi>`` (or density for infinite).\"\"\"\n    def expectation_value_finite(self, psi, init_env_data={}):\n        \"\"\"calculate ``<psi|self|psi>/<psi|psi>`` for finite mps.\"\"\"\n    def expectation_value_tm(self, psi, tol=1e-10, init_env_data={}):\n        \"\"\"calculate ``<psi|self|psi>/<psi|psi> / l`` from the mpotransfermatrix.\"\"\"\n    def expectation_value_power(self, psi, tol=1e-10, max_range=100):\n        \"\"\"calculate ``<psi|self|psi>/<psi|psi>`` with a power-method.\"\"\"\n    def variance(self, psi, exp_val=none):\n        \"\"\"calculate ``<psi|self^2|psi> - <psi|self|psi>^2``.\"\"\"\n    def prefactor(self, i, ops):\n        \"\"\"get prefactor for a given string of operators in self.\"\"\"\n    def to_termlist(self, op_basis, start=none, max_range=none, cutoff=1e-12, ignore=['id', 'jw']):\n        \"\"\"obtain a `termlist` represented by self.\"\"\"\n    def dagger(self):\n        \"\"\"return hermitian conjugate copy of self.\"\"\"\n    def is_hermitian(self, eps=1e-10, max_range=none):\n        \"\"\"check if `self` is a hermitian mpo.\"\"\"\n    def is_equal(self, other, eps=1e-10, max_range=none):\n        \"\"\"check if `self` and `other` represent the same mpo to precision `eps`.\"\"\"\n    def apply(self, psi, options):\n        \"\"\"apply `self` to an mps `psi` and compress `psi` in place.\"\"\"\n    def apply_naively(self, psi):\n        \"\"\"applies an mpo to an mps (in place) naively, without compression.\"\"\"\n    def apply_zipup(self, psi, options):\n        \"\"\"applies an mpo to an mps (in place) with the zip-up method.\"\"\"\n    def plus_identity(self, alpha, beta, sites=[0]):\n        \"\"\"compute a new mpo :math:`alpha * 1 + beta * \\mathtt{self}`.\"\"\"\n    def overlap(self, other, understood_infinite: bool=false, num_sites: int=none):\n        \"\"\"overlap between two mpos.\"\"\"\n    def distance(self, other, understood_infinite: bool=false, num_sites: int=none):\n        \"\"\"the frobenius distance induced by the inner product :meth:`overlap`.\"\"\" class mpo tenpy.networks.mpo",
    "tokens": 1210
  },
  {
    "category": "api",
    "name": "tenpy.networks.mpo.make_W_II",
    "content": "# API Function: tenpy.networks.mpo.make_W_II\ndef make_W_II(t, A, B, C, D):\n    \"\"\"W_II approx to exp(t H) from MPO parts (A, B, C, D).\"\"\"",
    "search_text": "tenpy.networks.mpo.make_w_ii # api function: tenpy.networks.mpo.make_w_ii\ndef make_w_ii(t, a, b, c, d):\n    \"\"\"w_ii approx to exp(t h) from mpo parts (a, b, c, d).\"\"\" function make_w_ii",
    "tokens": 55
  },
  {
    "category": "api",
    "name": "tenpy.networks.mpo.MPOGraph",
    "content": "# API Definition: tenpy.networks.mpo.MPOGraph\nclass MPOGraph:\n    \"\"\"Representation of an MPO by a graph, based on a 'finite state machine'.\"\"\"\n    def __init__(self, sites, bc='finite', max_range=None, unit_cell_width=None): pass\n    def from_terms(cls, terms, sites, bc, insert_all_id=True, unit_cell_width=None):\n        \"\"\"Initialize an :class:`MPOGraph` from OnsiteTerms and CouplingTerms.\"\"\"\n    def from_term_list(cls, term_list, sites, bc, insert_all_id=True, unit_cell_width=None):\n        \"\"\"Initialize from a list of operator terms and prefactors.\"\"\"\n    def test_sanity(self):\n        \"\"\"Sanity check, raises ValueErrors, if something is wrong.\"\"\"\n    def add(self, i, keyL, keyR, opname, strength, check_op=True, skip_existing=False):\n        \"\"\"Insert an edge into the graph.\"\"\"\n    def add_string_left_to_right(self, i, j, key, opname='Id', check_op=True, skip_existing=True):\n        \"\"\"Insert a bunch of edges for an 'operator string' into the graph.\"\"\"\n    def add_string_right_to_left(self, j, i, key, opname='Id', check_op=True, skip_existing=True):\n        \"\"\"Insert a bunch of edges for an 'operator string' into the graph.\"\"\"\n    def add_missing_IdL_IdR(self, insert_all_id=True):\n        \"\"\"Add missing identity ('Id') edges connecting ``'IdL'->'IdL' and ``'IdR'->'IdR'``.\"\"\"\n    def has_edge(self, i, keyL, keyR):\n        \"\"\"True if there is an edge from `keyL` on bond (i-1, i) to `keyR` on bond (i, i+1).\"\"\"\n    def build_MPO(self, Ws_qtotal=None):\n        \"\"\"Build the MPO represented by the graph (`self`).\"\"\"",
    "search_text": "tenpy.networks.mpo.mpograph # api definition: tenpy.networks.mpo.mpograph\nclass mpograph:\n    \"\"\"representation of an mpo by a graph, based on a 'finite state machine'.\"\"\"\n    def __init__(self, sites, bc='finite', max_range=none, unit_cell_width=none): pass\n    def from_terms(cls, terms, sites, bc, insert_all_id=true, unit_cell_width=none):\n        \"\"\"initialize an :class:`mpograph` from onsiteterms and couplingterms.\"\"\"\n    def from_term_list(cls, term_list, sites, bc, insert_all_id=true, unit_cell_width=none):\n        \"\"\"initialize from a list of operator terms and prefactors.\"\"\"\n    def test_sanity(self):\n        \"\"\"sanity check, raises valueerrors, if something is wrong.\"\"\"\n    def add(self, i, keyl, keyr, opname, strength, check_op=true, skip_existing=false):\n        \"\"\"insert an edge into the graph.\"\"\"\n    def add_string_left_to_right(self, i, j, key, opname='id', check_op=true, skip_existing=true):\n        \"\"\"insert a bunch of edges for an 'operator string' into the graph.\"\"\"\n    def add_string_right_to_left(self, j, i, key, opname='id', check_op=true, skip_existing=true):\n        \"\"\"insert a bunch of edges for an 'operator string' into the graph.\"\"\"\n    def add_missing_idl_idr(self, insert_all_id=true):\n        \"\"\"add missing identity ('id') edges connecting ``'idl'->'idl' and ``'idr'->'idr'``.\"\"\"\n    def has_edge(self, i, keyl, keyr):\n        \"\"\"true if there is an edge from `keyl` on bond (i-1, i) to `keyr` on bond (i, i+1).\"\"\"\n    def build_mpo(self, ws_qtotal=none):\n        \"\"\"build the mpo represented by the graph (`self`).\"\"\" class mpograph tenpy.networks.mpo",
    "tokens": 415
  },
  {
    "category": "api",
    "name": "tenpy.networks.mpo.MPOEnvironment",
    "content": "# API Definition: tenpy.networks.mpo.MPOEnvironment\nclass MPOEnvironment:\n    \"\"\"Stores partial contractions of :math:`<bra|H|ket>` for an MPO `H`.\"\"\"\n    def __init__(self, bra, H, ket, cache=None, **init_env_data): pass\n    def init_first_LP_last_RP(self, init_LP=None, init_RP=None, age_LP=0, age_RP=0, start_env_sites=None, force_init_method='iter', gmres_options=None):\n        \"\"\"(Re)initialize first LP and last RP from the given data.\"\"\"\n    def test_sanity(self):\n        \"\"\"Sanity check, raises ValueErrors, if something is wrong.\"\"\"\n    def init_LP(self, i, start_env_sites=0):\n        \"\"\"Build an initial left part ``LP``.\"\"\"\n    def init_RP(self, i, start_env_sites=0):\n        \"\"\"Build initial right part ``RP`` for an MPS/MPOEnvironment.\"\"\"\n    def get_LP(self, i, store=True):\n        \"\"\"Calculate LP at given site from nearest available one (including `i`).\"\"\"\n    def get_RP(self, i, store=True):\n        \"\"\"Calculate RP at given site from nearest available one (including `i`).\"\"\"\n    def full_contraction(self, i0):\n        \"\"\"Calculate the energy by a full contraction of the network.\"\"\"",
    "search_text": "tenpy.networks.mpo.mpoenvironment # api definition: tenpy.networks.mpo.mpoenvironment\nclass mpoenvironment:\n    \"\"\"stores partial contractions of :math:`<bra|h|ket>` for an mpo `h`.\"\"\"\n    def __init__(self, bra, h, ket, cache=none, **init_env_data): pass\n    def init_first_lp_last_rp(self, init_lp=none, init_rp=none, age_lp=0, age_rp=0, start_env_sites=none, force_init_method='iter', gmres_options=none):\n        \"\"\"(re)initialize first lp and last rp from the given data.\"\"\"\n    def test_sanity(self):\n        \"\"\"sanity check, raises valueerrors, if something is wrong.\"\"\"\n    def init_lp(self, i, start_env_sites=0):\n        \"\"\"build an initial left part ``lp``.\"\"\"\n    def init_rp(self, i, start_env_sites=0):\n        \"\"\"build initial right part ``rp`` for an mps/mpoenvironment.\"\"\"\n    def get_lp(self, i, store=true):\n        \"\"\"calculate lp at given site from nearest available one (including `i`).\"\"\"\n    def get_rp(self, i, store=true):\n        \"\"\"calculate rp at given site from nearest available one (including `i`).\"\"\"\n    def full_contraction(self, i0):\n        \"\"\"calculate the energy by a full contraction of the network.\"\"\" class mpoenvironment tenpy.networks.mpo",
    "tokens": 287
  },
  {
    "category": "api",
    "name": "tenpy.networks.mpo.MPOEnvironmentBuilder",
    "content": "# API Definition: tenpy.networks.mpo.MPOEnvironmentBuilder\nclass MPOEnvironmentBuilder:\n    \"\"\"Construct boundary environments for periodic MPOEnvironments.\"\"\"\n    def __init__(self, H, psi): pass\n    def test_sanity(self):\n        \"\"\"Sanity check, raises ValueErrors, if something is wrong.\"\"\"\n    def init_LP_RP_iterative(self, which='both', calc_E=False, tol_c0=None, gmres_options=None, tol_id=1e-12):\n        \"\"\"Construct boundary environments for periodic MPO environments.\"\"\"",
    "search_text": "tenpy.networks.mpo.mpoenvironmentbuilder # api definition: tenpy.networks.mpo.mpoenvironmentbuilder\nclass mpoenvironmentbuilder:\n    \"\"\"construct boundary environments for periodic mpoenvironments.\"\"\"\n    def __init__(self, h, psi): pass\n    def test_sanity(self):\n        \"\"\"sanity check, raises valueerrors, if something is wrong.\"\"\"\n    def init_lp_rp_iterative(self, which='both', calc_e=false, tol_c0=none, gmres_options=none, tol_id=1e-12):\n        \"\"\"construct boundary environments for periodic mpo environments.\"\"\" class mpoenvironmentbuilder tenpy.networks.mpo",
    "tokens": 115
  },
  {
    "category": "api",
    "name": "tenpy.networks.mpo.MPOTransferMatrix",
    "content": "# API Definition: tenpy.networks.mpo.MPOTransferMatrix\nclass MPOTransferMatrix:\n    \"\"\"Transfermatrix of a Hamiltonian-like MPO sandwiched between canonicalized MPS.\"\"\"\n    def __init__(self, H, psi, transpose=False, guess=None, _subtraction_gauge='rho'): pass\n    def matvec(self, vec, project=True):\n        \"\"\"One matvec-operation.\"\"\"\n    def dominant_eigenvector(self, **kwargs):\n        \"\"\"Find dominant eigenvector of self using :mod:`scipy.sparse`.\"\"\"\n    def energy(self, dom_vec):\n        \"\"\"Given the dominant eigenvector, calculate the energy per MPS site.\"\"\"\n    def find_init_LP_RP(cls, H, psi, first=0, last=None, guess_init_env_data=None, calc_E=False, tol_ev0=1e-08, _subtraction_gauge='rho', **kwargs):\n        \"\"\"Find the initial LP and RP.\"\"\"",
    "search_text": "tenpy.networks.mpo.mpotransfermatrix # api definition: tenpy.networks.mpo.mpotransfermatrix\nclass mpotransfermatrix:\n    \"\"\"transfermatrix of a hamiltonian-like mpo sandwiched between canonicalized mps.\"\"\"\n    def __init__(self, h, psi, transpose=false, guess=none, _subtraction_gauge='rho'): pass\n    def matvec(self, vec, project=true):\n        \"\"\"one matvec-operation.\"\"\"\n    def dominant_eigenvector(self, **kwargs):\n        \"\"\"find dominant eigenvector of self using :mod:`scipy.sparse`.\"\"\"\n    def energy(self, dom_vec):\n        \"\"\"given the dominant eigenvector, calculate the energy per mps site.\"\"\"\n    def find_init_lp_rp(cls, h, psi, first=0, last=none, guess_init_env_data=none, calc_e=false, tol_ev0=1e-08, _subtraction_gauge='rho', **kwargs):\n        \"\"\"find the initial lp and rp.\"\"\" class mpotransfermatrix tenpy.networks.mpo",
    "tokens": 197
  },
  {
    "category": "api",
    "name": "tenpy.networks.mpo.grid_insert_ops",
    "content": "# API Function: tenpy.networks.mpo.grid_insert_ops\ndef grid_insert_ops(site, grid):\n    \"\"\"Replaces entries representing operators in a grid of ``W[i]`` with npc.Arrays.\"\"\"",
    "search_text": "tenpy.networks.mpo.grid_insert_ops # api function: tenpy.networks.mpo.grid_insert_ops\ndef grid_insert_ops(site, grid):\n    \"\"\"replaces entries representing operators in a grid of ``w[i]`` with npc.arrays.\"\"\" function grid_insert_ops",
    "tokens": 42
  },
  {
    "category": "api",
    "name": "tenpy.networks.purification_mps.PurificationMPS",
    "content": "# API Definition: tenpy.networks.purification_mps.PurificationMPS\nclass PurificationMPS:\n    \"\"\"An MPS representing a finite-temperature ensemble using purification.\"\"\"\n    def test_sanity(self):\n        \"\"\"Sanity check, raises ValueErrors, if something is wrong.\"\"\"\n    def from_density_matrix(cls, sites, rho, form=None, cutoff=1e-16, normalize=True, unit_cell_width=None):\n        \"\"\"Construct a purification from a single tensor `rho` of the density matrix.\"\"\"\n    def from_infiniteT(cls, sites, bc='finite', form='B', dtype=np.float64, unit_cell_width=None):\n        \"\"\"Initial state corresponding to grand-canonical infinite-temperature ensemble.\"\"\"\n    def from_infiniteT_canonical(cls, sites, charge_sector, dtype=np.float64, conserve_ancilla_charge=False, unit_cell_width=None):\n        \"\"\"Initial state corresponding to *canonical* infinite-temperature ensemble.\"\"\"\n    def entanglement_entropy_segment(self, segment=[0], first_site=None, n=1, legs='p'):\n        \"\"\"Calculate entanglement entropy for general geometry of the bipartition.\"\"\"\n    def mutinf_two_site(self, max_range=None, n=1, legs='p'):\n        \"\"\"Calculate the two-site mutual information :math:`I(i:j)`.\"\"\"\n    def swap_sites(self, i, swapOP='auto', trunc_par={}): pass\n    def sample_measurements(self, sample_q, first_site=0, last_site=None, ops=None, rng=None, norm_tol=1e-12, complex_amplitude=True):\n        \"\"\"Sample measurement results in the computational basis.\"\"\"",
    "search_text": "tenpy.networks.purification_mps.purificationmps # api definition: tenpy.networks.purification_mps.purificationmps\nclass purificationmps:\n    \"\"\"an mps representing a finite-temperature ensemble using purification.\"\"\"\n    def test_sanity(self):\n        \"\"\"sanity check, raises valueerrors, if something is wrong.\"\"\"\n    def from_density_matrix(cls, sites, rho, form=none, cutoff=1e-16, normalize=true, unit_cell_width=none):\n        \"\"\"construct a purification from a single tensor `rho` of the density matrix.\"\"\"\n    def from_infinitet(cls, sites, bc='finite', form='b', dtype=np.float64, unit_cell_width=none):\n        \"\"\"initial state corresponding to grand-canonical infinite-temperature ensemble.\"\"\"\n    def from_infinitet_canonical(cls, sites, charge_sector, dtype=np.float64, conserve_ancilla_charge=false, unit_cell_width=none):\n        \"\"\"initial state corresponding to *canonical* infinite-temperature ensemble.\"\"\"\n    def entanglement_entropy_segment(self, segment=[0], first_site=none, n=1, legs='p'):\n        \"\"\"calculate entanglement entropy for general geometry of the bipartition.\"\"\"\n    def mutinf_two_site(self, max_range=none, n=1, legs='p'):\n        \"\"\"calculate the two-site mutual information :math:`i(i:j)`.\"\"\"\n    def swap_sites(self, i, swapop='auto', trunc_par={}): pass\n    def sample_measurements(self, sample_q, first_site=0, last_site=none, ops=none, rng=none, norm_tol=1e-12, complex_amplitude=true):\n        \"\"\"sample measurement results in the computational basis.\"\"\" class purificationmps tenpy.networks.purification_mps",
    "tokens": 338
  },
  {
    "category": "api",
    "name": "tenpy.networks.purification_mps.convert_model_purification_canonical_conserve_ancilla_charge",
    "content": "# API Function: tenpy.networks.purification_mps.convert_model_purification_canonical_conserve_ancilla_charge\ndef convert_model_purification_canonical_conserve_ancilla_charge(model):\n    \"\"\"Extend charges of model for :meth:`PurificationMPS.from_infiniteT_canonical`.\"\"\"",
    "search_text": "tenpy.networks.purification_mps.convert_model_purification_canonical_conserve_ancilla_charge # api function: tenpy.networks.purification_mps.convert_model_purification_canonical_conserve_ancilla_charge\ndef convert_model_purification_canonical_conserve_ancilla_charge(model):\n    \"\"\"extend charges of model for :meth:`purificationmps.from_infinitet_canonical`.\"\"\" function convert_model_purification_canonical_conserve_ancilla_charge",
    "tokens": 66
  },
  {
    "category": "api",
    "name": "tenpy.networks.terms.TermList",
    "content": "# API Definition: tenpy.networks.terms.TermList\nclass TermList:\n    \"\"\"A list of terms (=operator names and sites they act on) and associated strengths.\"\"\"\n    def __init__(self, terms, strength=1.0): pass\n    def from_lattice_locations(cls, lattice, terms, strength=1.0, shift=None):\n        \"\"\"Initialize from a list of terms given in lattice indices instead of MPS indices.\"\"\"\n    def to_OnsiteTerms_CouplingTerms(self, sites):\n        \"\"\"Convert to :class:`OnsiteTerms` and :class:`CouplingTerms`\"\"\"\n    def order_combine(self, sites):\n        \"\"\"Order and combine operators in each term.\"\"\"\n    def limits(self):\n        \"\"\"Return the left-most site and right-most site any operator acts on.\"\"\"\n    def shift(self, i0):\n        \"\"\"Return a copy where `i0` is added to all indices `i` in :attr:`terms`.\"\"\"\n    def max_range(self): pass",
    "search_text": "tenpy.networks.terms.termlist # api definition: tenpy.networks.terms.termlist\nclass termlist:\n    \"\"\"a list of terms (=operator names and sites they act on) and associated strengths.\"\"\"\n    def __init__(self, terms, strength=1.0): pass\n    def from_lattice_locations(cls, lattice, terms, strength=1.0, shift=none):\n        \"\"\"initialize from a list of terms given in lattice indices instead of mps indices.\"\"\"\n    def to_onsiteterms_couplingterms(self, sites):\n        \"\"\"convert to :class:`onsiteterms` and :class:`couplingterms`\"\"\"\n    def order_combine(self, sites):\n        \"\"\"order and combine operators in each term.\"\"\"\n    def limits(self):\n        \"\"\"return the left-most site and right-most site any operator acts on.\"\"\"\n    def shift(self, i0):\n        \"\"\"return a copy where `i0` is added to all indices `i` in :attr:`terms`.\"\"\"\n    def max_range(self): pass class termlist tenpy.networks.terms",
    "tokens": 204
  },
  {
    "category": "api",
    "name": "tenpy.networks.terms.order_combine_term",
    "content": "# API Function: tenpy.networks.terms.order_combine_term\ndef order_combine_term(term, sites):\n    \"\"\"Combine operators in a term to one terms per site.\"\"\"",
    "search_text": "tenpy.networks.terms.order_combine_term # api function: tenpy.networks.terms.order_combine_term\ndef order_combine_term(term, sites):\n    \"\"\"combine operators in a term to one terms per site.\"\"\" function order_combine_term",
    "tokens": 35
  },
  {
    "category": "api",
    "name": "tenpy.networks.terms.OnsiteTerms",
    "content": "# API Definition: tenpy.networks.terms.OnsiteTerms\nclass OnsiteTerms:\n    \"\"\"Operator names, site indices and strengths representing onsite terms.\"\"\"\n    def __init__(self, L): pass\n    def max_range(self):\n        \"\"\"Maximum range of the terms.\"\"\"\n    def add_onsite_term(self, strength, i, op):\n        \"\"\"Add a onsite term on a given MPS site.\"\"\"\n    def add_to_graph(self, graph):\n        \"\"\"Add terms from :attr:`onsite_terms` to an MPOGraph.\"\"\"\n    def to_Arrays(self, sites):\n        \"\"\"Convert the :attr:`onsite_terms` into a list of np_conserved Arrays.\"\"\"\n    def remove_zeros(self, tol_zero=1e-15):\n        \"\"\"Remove entries close to 0 from :attr:`onsite_terms`.\"\"\"\n    def add_to_nn_bond_Arrays(self, H_bond, sites, finite, distribute=(0.5, 0.5)):\n        \"\"\"Add :attr:`self.onsite_terms` into nearest-neighbor bond arrays.\"\"\"\n    def to_TermList(self):\n        \"\"\"Convert :attr:`onsite_terms` into a :class:`TermList`.\"\"\"",
    "search_text": "tenpy.networks.terms.onsiteterms # api definition: tenpy.networks.terms.onsiteterms\nclass onsiteterms:\n    \"\"\"operator names, site indices and strengths representing onsite terms.\"\"\"\n    def __init__(self, l): pass\n    def max_range(self):\n        \"\"\"maximum range of the terms.\"\"\"\n    def add_onsite_term(self, strength, i, op):\n        \"\"\"add a onsite term on a given mps site.\"\"\"\n    def add_to_graph(self, graph):\n        \"\"\"add terms from :attr:`onsite_terms` to an mpograph.\"\"\"\n    def to_arrays(self, sites):\n        \"\"\"convert the :attr:`onsite_terms` into a list of np_conserved arrays.\"\"\"\n    def remove_zeros(self, tol_zero=1e-15):\n        \"\"\"remove entries close to 0 from :attr:`onsite_terms`.\"\"\"\n    def add_to_nn_bond_arrays(self, h_bond, sites, finite, distribute=(0.5, 0.5)):\n        \"\"\"add :attr:`self.onsite_terms` into nearest-neighbor bond arrays.\"\"\"\n    def to_termlist(self):\n        \"\"\"convert :attr:`onsite_terms` into a :class:`termlist`.\"\"\" class onsiteterms tenpy.networks.terms",
    "tokens": 247
  },
  {
    "category": "api",
    "name": "tenpy.networks.terms.CouplingTerms",
    "content": "# API Definition: tenpy.networks.terms.CouplingTerms\nclass CouplingTerms:\n    \"\"\"Operator names, site indices and strengths representing two-site coupling terms.\"\"\"\n    def __init__(self, L): pass\n    def max_range(self):\n        \"\"\"Determine the maximal range in :attr:`coupling_terms`.\"\"\"\n    def add_coupling_term(self, strength, i, j, op_i, op_j, op_string='Id'):\n        \"\"\"Add a two-site coupling term on given MPS sites.\"\"\"\n    def coupling_term_handle_JW(self, strength, term, sites, op_string=None):\n        \"\"\"Helping function to call before :meth:`add_coupling_term`.\"\"\"\n    def plot_coupling_terms(self, ax, lat, style_map='default', common_style={'linestyle': '--'}, text=None, text_pos=0.4):\n        \"\"\"Plot coupling terms into a given lattice.\"\"\"\n    def add_to_graph(self, graph):\n        \"\"\"Add terms from :attr:`coupling_terms` to an MPOGraph.\"\"\"\n    def to_nn_bond_Arrays(self, sites):\n        \"\"\"Convert the :attr:`coupling_terms` into Arrays on nearest neighbor bonds.\"\"\"\n    def remove_zeros(self, tol_zero=1e-15):\n        \"\"\"Remove entries close to 0 from :attr:`coupling_terms`.\"\"\"\n    def to_TermList(self):\n        \"\"\"Convert :attr:`onsite_terms` into a :class:`TermList`.\"\"\"",
    "search_text": "tenpy.networks.terms.couplingterms # api definition: tenpy.networks.terms.couplingterms\nclass couplingterms:\n    \"\"\"operator names, site indices and strengths representing two-site coupling terms.\"\"\"\n    def __init__(self, l): pass\n    def max_range(self):\n        \"\"\"determine the maximal range in :attr:`coupling_terms`.\"\"\"\n    def add_coupling_term(self, strength, i, j, op_i, op_j, op_string='id'):\n        \"\"\"add a two-site coupling term on given mps sites.\"\"\"\n    def coupling_term_handle_jw(self, strength, term, sites, op_string=none):\n        \"\"\"helping function to call before :meth:`add_coupling_term`.\"\"\"\n    def plot_coupling_terms(self, ax, lat, style_map='default', common_style={'linestyle': '--'}, text=none, text_pos=0.4):\n        \"\"\"plot coupling terms into a given lattice.\"\"\"\n    def add_to_graph(self, graph):\n        \"\"\"add terms from :attr:`coupling_terms` to an mpograph.\"\"\"\n    def to_nn_bond_arrays(self, sites):\n        \"\"\"convert the :attr:`coupling_terms` into arrays on nearest neighbor bonds.\"\"\"\n    def remove_zeros(self, tol_zero=1e-15):\n        \"\"\"remove entries close to 0 from :attr:`coupling_terms`.\"\"\"\n    def to_termlist(self):\n        \"\"\"convert :attr:`onsite_terms` into a :class:`termlist`.\"\"\" class couplingterms tenpy.networks.terms",
    "tokens": 302
  },
  {
    "category": "api",
    "name": "tenpy.networks.terms.MultiCouplingTerms",
    "content": "# API Definition: tenpy.networks.terms.MultiCouplingTerms\nclass MultiCouplingTerms:\n    \"\"\"Operator names, site indices and strengths representing general `M`-site coupling terms.\"\"\"\n    def __init__(self, L): pass\n    def max_range(self):\n        \"\"\"Determine the maximal range in :attr:`coupling_terms`.\"\"\"\n    def add_multi_coupling_term(self, strength, ijkl, ops_ijkl, op_string='Id', switchLR='middle_i'):\n        \"\"\"Add a multi-site coupling term.\"\"\"\n    def multi_coupling_term_handle_JW(self, strength, term, sites, op_string=None):\n        \"\"\"Helping function to call before :meth:`add_multi_coupling_term`.\"\"\"\n    def add_coupling_term(self, strength, i, j, op_i, op_j, op_string='Id', switchLR=None):\n        \"\"\"Add a two-site coupling term on given MPS sites.\"\"\"\n    def add_to_graph(self, graph):\n        \"\"\"Add terms represented by `self` to an MPOGraph.\"\"\"\n    def remove_zeros(self, tol_zero=1e-15):\n        \"\"\"Remove entries close to 0 from :attr:`coupling_terms`.\"\"\"\n    def to_TermList(self):\n        \"\"\"Convert :attr:`coupling_terms` into a :class:`TermList`.\"\"\"",
    "search_text": "tenpy.networks.terms.multicouplingterms # api definition: tenpy.networks.terms.multicouplingterms\nclass multicouplingterms:\n    \"\"\"operator names, site indices and strengths representing general `m`-site coupling terms.\"\"\"\n    def __init__(self, l): pass\n    def max_range(self):\n        \"\"\"determine the maximal range in :attr:`coupling_terms`.\"\"\"\n    def add_multi_coupling_term(self, strength, ijkl, ops_ijkl, op_string='id', switchlr='middle_i'):\n        \"\"\"add a multi-site coupling term.\"\"\"\n    def multi_coupling_term_handle_jw(self, strength, term, sites, op_string=none):\n        \"\"\"helping function to call before :meth:`add_multi_coupling_term`.\"\"\"\n    def add_coupling_term(self, strength, i, j, op_i, op_j, op_string='id', switchlr=none):\n        \"\"\"add a two-site coupling term on given mps sites.\"\"\"\n    def add_to_graph(self, graph):\n        \"\"\"add terms represented by `self` to an mpograph.\"\"\"\n    def remove_zeros(self, tol_zero=1e-15):\n        \"\"\"remove entries close to 0 from :attr:`coupling_terms`.\"\"\"\n    def to_termlist(self):\n        \"\"\"convert :attr:`coupling_terms` into a :class:`termlist`.\"\"\" class multicouplingterms tenpy.networks.terms",
    "tokens": 274
  },
  {
    "category": "api",
    "name": "tenpy.networks.terms.ExponentiallyDecayingTerms",
    "content": "# API Definition: tenpy.networks.terms.ExponentiallyDecayingTerms\nclass ExponentiallyDecayingTerms:\n    \"\"\"Represent a sum of exponentially decaying (long-range) couplings.\"\"\"\n    def __init__(self, L): pass\n    def is_empty(self): pass\n    def add_exponentially_decaying_coupling(self, strength, lambda_, op_i, op_j, subsites=None, subsites_start=None, op_string='Id'):\n        \"\"\"Add an exponentially decaying long-range coupling.\"\"\"\n    def add_centered_exponentially_decaying_term(self, strength, lambda_, op_i, op_j, i, subsites=None, op_string='Id'):\n        \"\"\"Add exponentially decaying terms centered around a single site.\"\"\"\n    def add_to_graph(self, graph, key='exp-decay'):\n        \"\"\"Add terms from :attr:`onsite_terms` to an MPOGraph.\"\"\"\n    def to_TermList(self, cutoff=0.01, bc='finite'):\n        \"\"\"Convert self into a :class:`TermList`.\"\"\"\n    def max_range(self):\n        \"\"\"Maximum range of the couplings.\"\"\"",
    "search_text": "tenpy.networks.terms.exponentiallydecayingterms # api definition: tenpy.networks.terms.exponentiallydecayingterms\nclass exponentiallydecayingterms:\n    \"\"\"represent a sum of exponentially decaying (long-range) couplings.\"\"\"\n    def __init__(self, l): pass\n    def is_empty(self): pass\n    def add_exponentially_decaying_coupling(self, strength, lambda_, op_i, op_j, subsites=none, subsites_start=none, op_string='id'):\n        \"\"\"add an exponentially decaying long-range coupling.\"\"\"\n    def add_centered_exponentially_decaying_term(self, strength, lambda_, op_i, op_j, i, subsites=none, op_string='id'):\n        \"\"\"add exponentially decaying terms centered around a single site.\"\"\"\n    def add_to_graph(self, graph, key='exp-decay'):\n        \"\"\"add terms from :attr:`onsite_terms` to an mpograph.\"\"\"\n    def to_termlist(self, cutoff=0.01, bc='finite'):\n        \"\"\"convert self into a :class:`termlist`.\"\"\"\n    def max_range(self):\n        \"\"\"maximum range of the couplings.\"\"\" class exponentiallydecayingterms tenpy.networks.terms",
    "tokens": 234
  },
  {
    "category": "api",
    "name": "tenpy.networks.uniform_mps.UniformMPS",
    "content": "# API Definition: tenpy.networks.uniform_mps.UniformMPS\nclass UniformMPS:\n    \"\"\"A Uniform Matrix Product State, only defined in the thermodynamic limit.\"\"\"\n    def __init__(self, sites, ALs, ARs, ACs, Cs, norm=1.0, unit_cell_width: int=None): pass\n    def test_sanity(self):\n        \"\"\"Sanity check, raises ValueErrors, if something is wrong.\"\"\"\n    def test_validity(self, cutoff=1e-08):\n        \"\"\"Check if AL C = AC and C AR = AC\"\"\"\n    def copy(self):\n        \"\"\"Returns a copy of `self`.\"\"\"\n    def save_hdf5(self, hdf5_saver, h5gr, subpath):\n        \"\"\"Export `self` into a HDF5 file.\"\"\"\n    def to_MPS(self, cutoff=1e-16, check_overlap=False):\n        \"\"\"Convert UniformMPS to MPS.\"\"\"\n    def to_diagonal_gauge(self, cutoff=1e-16, check_overlap=False):\n        \"\"\"Convert a UniformMPS to diagonal gauge, i.e. where all of the bond matrices are diagonal.\"\"\"\n    def from_hdf5(cls, hdf5_loader, h5gr, subpath):\n        \"\"\"Load instance from a HDF5 file.\"\"\"\n    def from_MPS(cls, psi):\n        \"\"\"Convert an infinite MPS to a uniform MPS.\"\"\"\n    def from_lat_product_state(cls, lat, p_state, **kwargs): pass\n    def from_product_state(cls, sites, p_state, bc='finite', dtype=np.float64, permute=True, form='B', chargeL=None): pass\n    def from_Bflat(cls, sites, ALflat, ARflat, ACflat, Cflat, dtype=None, permute=True, legL=None):\n        \"\"\"Construct a matrix product state from a set of numpy arrays and singular vals.\"\"\"\n    def from_full(cls, sites, psi, form=None, cutoff=1e-16, normalize=True, bc='finite', outer_S=None): pass\n    def from_singlets(cls, site, L, pairs, up='up', down='down', lonely=[], lonely_state='up', bc='finite'): pass\n    def chi(self):\n        \"\"\"Dimensions of the (nontrivial) virtual bonds.\"\"\"\n    def get_B(self, i, form='B', copy=False, cutoff=1e-16, label_p=None):\n        \"\"\"Return (view of) `B` at site `i` in canonical form.\"\"\"\n    def get_AL(self, i, copy=False, label_p=None):\n        \"\"\"Return (view of) `AL` at site `i` in canonical form.\"\"\"\n    def get_AR(self, i, copy=False, label_p=None):\n        \"\"\"Return (view of) `AR` at site `i` in canonical form.\"\"\"\n    def get_AC(self, i, copy=False, label_p=None):\n        \"\"\"Return (view of) `AC` at site `i` in canonical form.\"\"\"\n    def get_C(self, i, copy=False):\n        \"\"\"Return center matrix C on the left of site `i`\"\"\"\n    def set_B(self, i, B, form='B'):\n        \"\"\"Set tensor `B` at site `i`.\"\"\"\n    def set_AL(self, i, AL):\n        \"\"\"Set `AL` at site `i`\"\"\"\n    def set_AR(self, i, AR):\n        \"\"\"Set `AR` at site `i`\"\"\"\n    def set_AC(self, i, AC):\n        \"\"\"Set `AC` at site `i`\"\"\"\n    def set_C(self, i, C):\n        \"\"\"Set `C` left of site `i`\"\"\"\n    def set_svd_theta(self, i, theta, trunc_par=None, update_norm=False): pass\n    def get_SL(self, i): pass\n    def get_SR(self, i): pass\n    def set_SL(self, i, S): pass\n    def set_SR(self, i, S): pass\n    def get_theta(self, i, n=2, cutoff=1e-16, formL=1.0, formR=1.0):\n        \"\"\"Calculates the `n`-site wavefunction on ``sites[i:i+n]``.\"\"\"\n    def convert_form(self, new_form='B'): pass\n    def enlarge_mps_unit_cell(self, factor=2):\n        \"\"\"Repeat the unit cell for infinite uniform MPS boundary conditions; in place.\"\"\"\n    def roll_mps_unit_cell(self, shift=1):\n        \"\"\"Shift the section we define as unit cell of an infinite MPS; in place.\"\"\"\n    def spatial_inversion(self):\n        \"\"\"Perform a spatial inversion along the MPS.\"\"\"\n    def group_sites(self, n=2, grouped_sites=None): pass\n    def group_split(self, trunc_par=None): pass\n    def get_grouped_mps(self, blocklen): pass\n    def extract_segment(self, first, last): pass\n    def get_total_charge(self, only_physical_legs=False):\n        \"\"\"Calculate and return the `qtotal` of the whole MPS (when contracted).\"\"\"\n    def gauge_total_charge(self, qtotal=None, vL_leg=None, vR_leg=None): pass\n    def entanglement_entropy(self, n=1, bonds=None, for_matrix_S=True): pass\n    def entanglement_entropy_segment(self, segment=[0], first_site=None, n=1): pass\n    def entanglement_entropy_segment2(self, segment, n=1): pass\n    def entanglement_spectrum(self, by_charge=False): pass\n    def get_rho_segment(self, segment): pass\n    def probability_per_charge(self, bond=0): pass\n    def average_charge(self, bond=0): pass\n    def charge_variance(self, bond=0): pass\n    def mutinf_two_site(self, max_range=None, n=1): pass\n    def overlap(self, other, charge_sector=None, ignore_form=False, **kwargs):\n        \"\"\"Compute overlap ``<self|other>``.\"\"\"\n    def sample_measurements(self, first_site=0, last_site=None, ops=None, rng=None, norm_tol=1e-12): pass\n    def norm_test(self, force=False): pass\n    def canonical_form(self, **kwargs): pass\n    def canonical_form_finite(self, renormalize=True, cutoff=0.0, envs_to_update=None): pass\n    def canonical_form_infinite(self, renormalize=True, tol_xi=1000000.0): pass\n    def correlation_length(self, target=1, tol_ev0=1e-08, charge_sector=0): pass\n    def add(self, other, alpha, beta, cutoff=1e-15): pass\n    def apply_local_op(self, i, op, unitary=None, renormalize=False, cutoff=1e-13): pass\n    def apply_product_op(self, ops, unitary=None, renormalize=False): pass\n    def perturb(self, randomize_params=None, close_1=True, canonicalize=None): pass\n    def swap_sites(self, i, swap_op='auto', trunc_par=None): pass\n    def permute_sites(self, perm, swap_op='auto', trunc_par=None, verbose=None): pass\n    def compute_K(self, perm, swap_op='auto', trunc_par=None, canonicalize=1e-06, verbose=None, expected_mean_k=0.0): pass\n    def compress(self, options): pass\n    def compress_svd(self, trunc_par): pass\n    def outer_virtual_legs(self): pass",
    "search_text": "tenpy.networks.uniform_mps.uniformmps # api definition: tenpy.networks.uniform_mps.uniformmps\nclass uniformmps:\n    \"\"\"a uniform matrix product state, only defined in the thermodynamic limit.\"\"\"\n    def __init__(self, sites, als, ars, acs, cs, norm=1.0, unit_cell_width: int=none): pass\n    def test_sanity(self):\n        \"\"\"sanity check, raises valueerrors, if something is wrong.\"\"\"\n    def test_validity(self, cutoff=1e-08):\n        \"\"\"check if al c = ac and c ar = ac\"\"\"\n    def copy(self):\n        \"\"\"returns a copy of `self`.\"\"\"\n    def save_hdf5(self, hdf5_saver, h5gr, subpath):\n        \"\"\"export `self` into a hdf5 file.\"\"\"\n    def to_mps(self, cutoff=1e-16, check_overlap=false):\n        \"\"\"convert uniformmps to mps.\"\"\"\n    def to_diagonal_gauge(self, cutoff=1e-16, check_overlap=false):\n        \"\"\"convert a uniformmps to diagonal gauge, i.e. where all of the bond matrices are diagonal.\"\"\"\n    def from_hdf5(cls, hdf5_loader, h5gr, subpath):\n        \"\"\"load instance from a hdf5 file.\"\"\"\n    def from_mps(cls, psi):\n        \"\"\"convert an infinite mps to a uniform mps.\"\"\"\n    def from_lat_product_state(cls, lat, p_state, **kwargs): pass\n    def from_product_state(cls, sites, p_state, bc='finite', dtype=np.float64, permute=true, form='b', chargel=none): pass\n    def from_bflat(cls, sites, alflat, arflat, acflat, cflat, dtype=none, permute=true, legl=none):\n        \"\"\"construct a matrix product state from a set of numpy arrays and singular vals.\"\"\"\n    def from_full(cls, sites, psi, form=none, cutoff=1e-16, normalize=true, bc='finite', outer_s=none): pass\n    def from_singlets(cls, site, l, pairs, up='up', down='down', lonely=[], lonely_state='up', bc='finite'): pass\n    def chi(self):\n        \"\"\"dimensions of the (nontrivial) virtual bonds.\"\"\"\n    def get_b(self, i, form='b', copy=false, cutoff=1e-16, label_p=none):\n        \"\"\"return (view of) `b` at site `i` in canonical form.\"\"\"\n    def get_al(self, i, copy=false, label_p=none):\n        \"\"\"return (view of) `al` at site `i` in canonical form.\"\"\"\n    def get_ar(self, i, copy=false, label_p=none):\n        \"\"\"return (view of) `ar` at site `i` in canonical form.\"\"\"\n    def get_ac(self, i, copy=false, label_p=none):\n        \"\"\"return (view of) `ac` at site `i` in canonical form.\"\"\"\n    def get_c(self, i, copy=false):\n        \"\"\"return center matrix c on the left of site `i`\"\"\"\n    def set_b(self, i, b, form='b'):\n        \"\"\"set tensor `b` at site `i`.\"\"\"\n    def set_al(self, i, al):\n        \"\"\"set `al` at site `i`\"\"\"\n    def set_ar(self, i, ar):\n        \"\"\"set `ar` at site `i`\"\"\"\n    def set_ac(self, i, ac):\n        \"\"\"set `ac` at site `i`\"\"\"\n    def set_c(self, i, c):\n        \"\"\"set `c` left of site `i`\"\"\"\n    def set_svd_theta(self, i, theta, trunc_par=none, update_norm=false): pass\n    def get_sl(self, i): pass\n    def get_sr(self, i): pass\n    def set_sl(self, i, s): pass\n    def set_sr(self, i, s): pass\n    def get_theta(self, i, n=2, cutoff=1e-16, forml=1.0, formr=1.0):\n        \"\"\"calculates the `n`-site wavefunction on ``sites[i:i+n]``.\"\"\"\n    def convert_form(self, new_form='b'): pass\n    def enlarge_mps_unit_cell(self, factor=2):\n        \"\"\"repeat the unit cell for infinite uniform mps boundary conditions; in place.\"\"\"\n    def roll_mps_unit_cell(self, shift=1):\n        \"\"\"shift the section we define as unit cell of an infinite mps; in place.\"\"\"\n    def spatial_inversion(self):\n        \"\"\"perform a spatial inversion along the mps.\"\"\"\n    def group_sites(self, n=2, grouped_sites=none): pass\n    def group_split(self, trunc_par=none): pass\n    def get_grouped_mps(self, blocklen): pass\n    def extract_segment(self, first, last): pass\n    def get_total_charge(self, only_physical_legs=false):\n        \"\"\"calculate and return the `qtotal` of the whole mps (when contracted).\"\"\"\n    def gauge_total_charge(self, qtotal=none, vl_leg=none, vr_leg=none): pass\n    def entanglement_entropy(self, n=1, bonds=none, for_matrix_s=true): pass\n    def entanglement_entropy_segment(self, segment=[0], first_site=none, n=1): pass\n    def entanglement_entropy_segment2(self, segment, n=1): pass\n    def entanglement_spectrum(self, by_charge=false): pass\n    def get_rho_segment(self, segment): pass\n    def probability_per_charge(self, bond=0): pass\n    def average_charge(self, bond=0): pass\n    def charge_variance(self, bond=0): pass\n    def mutinf_two_site(self, max_range=none, n=1): pass\n    def overlap(self, other, charge_sector=none, ignore_form=false, **kwargs):\n        \"\"\"compute overlap ``<self|other>``.\"\"\"\n    def sample_measurements(self, first_site=0, last_site=none, ops=none, rng=none, norm_tol=1e-12): pass\n    def norm_test(self, force=false): pass\n    def canonical_form(self, **kwargs): pass\n    def canonical_form_finite(self, renormalize=true, cutoff=0.0, envs_to_update=none): pass\n    def canonical_form_infinite(self, renormalize=true, tol_xi=1000000.0): pass\n    def correlation_length(self, target=1, tol_ev0=1e-08, charge_sector=0): pass\n    def add(self, other, alpha, beta, cutoff=1e-15): pass\n    def apply_local_op(self, i, op, unitary=none, renormalize=false, cutoff=1e-13): pass\n    def apply_product_op(self, ops, unitary=none, renormalize=false): pass\n    def perturb(self, randomize_params=none, close_1=true, canonicalize=none): pass\n    def swap_sites(self, i, swap_op='auto', trunc_par=none): pass\n    def permute_sites(self, perm, swap_op='auto', trunc_par=none, verbose=none): pass\n    def compute_k(self, perm, swap_op='auto', trunc_par=none, canonicalize=1e-06, verbose=none, expected_mean_k=0.0): pass\n    def compress(self, options): pass\n    def compress_svd(self, trunc_par): pass\n    def outer_virtual_legs(self): pass class uniformmps tenpy.networks.uniform_mps",
    "tokens": 1590
  },
  {
    "category": "api",
    "name": "tenpy.networks.momentum_mps.MomentumMPS",
    "content": "# API Definition: tenpy.networks.momentum_mps.MomentumMPS\nclass MomentumMPS:\n    \"\"\"A Matrix Product State, finite (MPS) or infinite (iMPS).\"\"\"\n    def __init__(self, Xs, uMPS, p, n_sites=1): pass\n    def copy(self):\n        \"\"\"Returns a copy of `self`.\"\"\"\n    def save_hdf5(self, hdf5_saver, h5gr, subpath):\n        \"\"\"Export `self` into a HDF5 file.\"\"\"\n    def from_hdf5(cls, hdf5_loader, h5gr, subpath):\n        \"\"\"Load instance from a HDF5 file.\"\"\"\n    def get_X(self, i, copy=False):\n        \"\"\"Return (view of) `X` at site `i`.\"\"\"\n    def set_X(self, i, X):\n        \"\"\"Set `X` at site `i`.\"\"\"",
    "search_text": "tenpy.networks.momentum_mps.momentummps # api definition: tenpy.networks.momentum_mps.momentummps\nclass momentummps:\n    \"\"\"a matrix product state, finite (mps) or infinite (imps).\"\"\"\n    def __init__(self, xs, umps, p, n_sites=1): pass\n    def copy(self):\n        \"\"\"returns a copy of `self`.\"\"\"\n    def save_hdf5(self, hdf5_saver, h5gr, subpath):\n        \"\"\"export `self` into a hdf5 file.\"\"\"\n    def from_hdf5(cls, hdf5_loader, h5gr, subpath):\n        \"\"\"load instance from a hdf5 file.\"\"\"\n    def get_x(self, i, copy=false):\n        \"\"\"return (view of) `x` at site `i`.\"\"\"\n    def set_x(self, i, x):\n        \"\"\"set `x` at site `i`.\"\"\" class momentummps tenpy.networks.momentum_mps",
    "tokens": 190
  },
  {
    "category": "api",
    "name": "tenpy.networks.mps.MPSGeometry",
    "content": "# API Definition: tenpy.networks.mps.MPSGeometry\nclass MPSGeometry:\n    \"\"\"Base class providing methods regarding the 1D geometry of MPS-like tensornetworks.\"\"\"\n    def __init__(self, sites, bc, unit_cell_width=None): pass\n    def test_sanity(self): pass\n    def L(self):\n        \"\"\"Number of physical sites; for an iMPS the len of the MPS unit cell.\"\"\"\n    def dim(self):\n        \"\"\"List of local physical dimensions.\"\"\"\n    def finite(self):\n        \"\"\"Distinguish MPS vs iMPS.\"\"\"\n    def nontrivial_bonds(self):\n        \"\"\"Slice of the non-trivial bond indices, depending on ``self.bc``.\"\"\"\n    def N_sites_per_hor_spacing(self):\n        \"\"\"Number of sites per horizontal lattice spacing.\"\"\"\n    def shift_charges_unit_cells(self, charges, num_unit_cells):\n        \"\"\"Shift charges by an integer multiple of unit cells.\"\"\"\n    def shift_Site_unit_cells(self, site, num_unit_cells):\n        \"\"\"Shift a `site` by an integer multiple of unit cells.\"\"\"\n    def shift_Array_unit_cells(self, arr, num_unit_cells, inplace: bool=False):\n        \"\"\"Shift an Array by an integer multiple of unit cells.\"\"\"\n    def get_site(self, i):\n        \"\"\"Get the `i`-th site.\"\"\"",
    "search_text": "tenpy.networks.mps.mpsgeometry # api definition: tenpy.networks.mps.mpsgeometry\nclass mpsgeometry:\n    \"\"\"base class providing methods regarding the 1d geometry of mps-like tensornetworks.\"\"\"\n    def __init__(self, sites, bc, unit_cell_width=none): pass\n    def test_sanity(self): pass\n    def l(self):\n        \"\"\"number of physical sites; for an imps the len of the mps unit cell.\"\"\"\n    def dim(self):\n        \"\"\"list of local physical dimensions.\"\"\"\n    def finite(self):\n        \"\"\"distinguish mps vs imps.\"\"\"\n    def nontrivial_bonds(self):\n        \"\"\"slice of the non-trivial bond indices, depending on ``self.bc``.\"\"\"\n    def n_sites_per_hor_spacing(self):\n        \"\"\"number of sites per horizontal lattice spacing.\"\"\"\n    def shift_charges_unit_cells(self, charges, num_unit_cells):\n        \"\"\"shift charges by an integer multiple of unit cells.\"\"\"\n    def shift_site_unit_cells(self, site, num_unit_cells):\n        \"\"\"shift a `site` by an integer multiple of unit cells.\"\"\"\n    def shift_array_unit_cells(self, arr, num_unit_cells, inplace: bool=false):\n        \"\"\"shift an array by an integer multiple of unit cells.\"\"\"\n    def get_site(self, i):\n        \"\"\"get the `i`-th site.\"\"\" class mpsgeometry tenpy.networks.mps",
    "tokens": 272
  },
  {
    "category": "api",
    "name": "tenpy.networks.mps.BaseMPSExpectationValue",
    "content": "# API Definition: tenpy.networks.mps.BaseMPSExpectationValue\nclass BaseMPSExpectationValue:\n    \"\"\"Base class providing unified expectation value framework for MPS and MPSEnvironment.\"\"\"\n    def expectation_value(self, ops, sites=None, axes=None):\n        \"\"\"Expectation value ``<bra|ops|ket>`` of (n-site) operator(s).\"\"\"\n    def apply_JW_string_left_of_virt_leg(self, theta, virt_leg_index, i):\n        \"\"\"Apply signs on a virtual MPS leg equivalent to a Jordan-Wigner string on the left.\"\"\"\n    def expectation_value_multi_sites(self, operators, i0):\n        \"\"\"Expectation value  ``<bra|op0_{i0}op1_{i0+1}...opN_{i0+N}|ket>``.\"\"\"\n    def correlation_function(self, ops1, ops2, sites1=None, sites2=None, opstr=None, str_on_first=True, hermitian=False, autoJW=True):\n        \"\"\"Correlation function of single-site operators.\"\"\"\n    def expectation_value_term(self, term, autoJW=True):\n        \"\"\"Expectation value  ``<bra|op_{i0}op_{i1}...op_{iN}|ket>``.\"\"\"\n    def term_correlation_function_right(self, term_L, term_R, i_L=0, j_R=None, autoJW=True, opstr=None):\n        \"\"\"Correlation function between (multi-site) terms, moving the right term, fix left term.\"\"\"\n    def term_correlation_function_left(self, term_L, term_R, i_L=None, j_R=0, autoJW=True, opstr=None):\n        \"\"\"Correlation function between (multi-site) terms, moving the left term, fix right term.\"\"\"\n    def term_list_correlation_function_right(self, term_list_L, term_list_R, i_L=0, j_R=None, autoJW=True, opstr=None):\n        \"\"\"Correlation function between sums of multi-site terms, moving the right sum of term.\"\"\"\n    def get_op(self, op_list, i):\n        \"\"\"Given a list of operators, select the one corresponding to site `i`.\"\"\"",
    "search_text": "tenpy.networks.mps.basempsexpectationvalue # api definition: tenpy.networks.mps.basempsexpectationvalue\nclass basempsexpectationvalue:\n    \"\"\"base class providing unified expectation value framework for mps and mpsenvironment.\"\"\"\n    def expectation_value(self, ops, sites=none, axes=none):\n        \"\"\"expectation value ``<bra|ops|ket>`` of (n-site) operator(s).\"\"\"\n    def apply_jw_string_left_of_virt_leg(self, theta, virt_leg_index, i):\n        \"\"\"apply signs on a virtual mps leg equivalent to a jordan-wigner string on the left.\"\"\"\n    def expectation_value_multi_sites(self, operators, i0):\n        \"\"\"expectation value  ``<bra|op0_{i0}op1_{i0+1}...opn_{i0+n}|ket>``.\"\"\"\n    def correlation_function(self, ops1, ops2, sites1=none, sites2=none, opstr=none, str_on_first=true, hermitian=false, autojw=true):\n        \"\"\"correlation function of single-site operators.\"\"\"\n    def expectation_value_term(self, term, autojw=true):\n        \"\"\"expectation value  ``<bra|op_{i0}op_{i1}...op_{in}|ket>``.\"\"\"\n    def term_correlation_function_right(self, term_l, term_r, i_l=0, j_r=none, autojw=true, opstr=none):\n        \"\"\"correlation function between (multi-site) terms, moving the right term, fix left term.\"\"\"\n    def term_correlation_function_left(self, term_l, term_r, i_l=none, j_r=0, autojw=true, opstr=none):\n        \"\"\"correlation function between (multi-site) terms, moving the left term, fix right term.\"\"\"\n    def term_list_correlation_function_right(self, term_list_l, term_list_r, i_l=0, j_r=none, autojw=true, opstr=none):\n        \"\"\"correlation function between sums of multi-site terms, moving the right sum of term.\"\"\"\n    def get_op(self, op_list, i):\n        \"\"\"given a list of operators, select the one corresponding to site `i`.\"\"\" class basempsexpectationvalue tenpy.networks.mps",
    "tokens": 454
  },
  {
    "category": "api",
    "name": "tenpy.networks.mps.MPS",
    "content": "# API Definition: tenpy.networks.mps.MPS\nclass MPS:\n    \"\"\"A Matrix Product State, finite (MPS) or infinite (iMPS).\"\"\"\n    def __init__(self, sites, Bs, SVs, bc='finite', form='B', norm=1.0, unit_cell_width=None, understood_shift_symmetry: bool=False): pass\n    def test_sanity(self):\n        \"\"\"Sanity check, raises ValueErrors, if something is wrong.\"\"\"\n    def copy(self):\n        \"\"\"Returns a copy of `self`.\"\"\"\n    def save_hdf5(self, hdf5_saver, h5gr, subpath):\n        \"\"\"Export `self` into a HDF5 file.\"\"\"\n    def from_hdf5(cls, hdf5_loader, h5gr, subpath):\n        \"\"\"Load instance from a HDF5 file.\"\"\"\n    def from_lat_product_state(cls, lat, p_state, allow_incommensurate=False, **kwargs):\n        \"\"\"Construct an MPS from a product state given in lattice coordinates.\"\"\"\n    def from_product_state(cls, sites, p_state, bc='finite', dtype=np.float64, permute=True, form='B', chargeL=None, unit_cell_width=None, understood_shift_symmetry: bool=False):\n        \"\"\"Construct a matrix product state from a given product state.\"\"\"\n    def from_random_unitary_evolution(cls, sites, chi, p_state, bc='finite', dtype=np.float64, permute=True, form='B', chargeL=None, understood_shift_symmetry: bool=False):\n        \"\"\"Construct a matrix product state by evolving a product state with random unitaries.\"\"\"\n    def from_desired_bond_dimension(cls, sites, chis, bc='finite', dtype=np.float64, permute=True, chargeL=None, unit_cell_width=None, understood_shift_symmetry: bool=False):\n        \"\"\"Construct a matrix product state with given bond dimensions from random matrices.\"\"\"\n    def from_Bflat(cls, sites, Bflat, SVs=None, bc='finite', dtype=None, permute=True, form='B', legL=None, unit_cell_width=None, understood_shift_symmetry: bool=False):\n        \"\"\"Construct a matrix product state from a set of numpy arrays `Bflat` and singular vals.\"\"\"\n    def from_full(cls, sites, psi, form=None, cutoff=1e-16, normalize=True, bc='finite', outer_S=None, unit_cell_width=None, understood_shift_symmetry: bool=False):\n        \"\"\"Construct an MPS from a single tensor `psi` with one leg per physical site.\"\"\"\n    def from_singlets(cls, site, L, pairs, up='up', down='down', lonely=[], lonely_state='up', bc='finite', unit_cell_width=None, understood_shift_symmetry: bool=False):\n        \"\"\"Create an MPS of entangled singlets.\"\"\"\n    def from_product_mps_covering(cls, mps_covering, index_map, bc='finite', unit_cell_width=None, understood_shift_symmetry: bool=False):\n        \"\"\"Create an MPS as a product of (many) local mps covering all sites to be created.\"\"\"\n    def project_onto_charge_sector(cls, sites, p_state_list, charge_sector, dtype=float, bc='finite', form='B', norm=1.0, unit_cell_width=None, understood_shift_symmetry: bool=False):\n        \"\"\"Generates an MPS from a product state list which is projected onto a given charge sector.\"\"\"\n    def L(self):\n        \"\"\"Number of physical sites; for an iMPS the len of the MPS unit cell.\"\"\"\n    def dim(self):\n        \"\"\"List of local physical dimensions.\"\"\"\n    def finite(self):\n        \"\"\"Distinguish MPS vs iMPS.\"\"\"\n    def chi(self):\n        \"\"\"Dimensions of the (nontrivial) virtual bonds.\"\"\"\n    def get_B(self, i, form='B', copy=False, cutoff=1e-16, label_p=None):\n        \"\"\"Return (view of) `B` at site `i` in canonical form.\"\"\"\n    def set_B(self, i, B, form='B'):\n        \"\"\"Set `B` at site `i`.\"\"\"\n    def set_svd_theta(self, i, theta, trunc_par=None, update_norm=False):\n        \"\"\"SVD a two-site wave function `theta` and save it in `self`.\"\"\"\n    def get_SL(self, i):\n        \"\"\"Return singular values on the left of site `i`.\"\"\"\n    def get_SR(self, i):\n        \"\"\"Return singular values on the right of site `i`.\"\"\"\n    def set_SL(self, i, S):\n        \"\"\"Set singular values on the left of site `i`. No copy is made!\"\"\"\n    def set_SR(self, i, S):\n        \"\"\"Set singular values on the right of site `i`. No copy is made!\"\"\"\n    def get_theta(self, i, n=2, cutoff=1e-16, formL=1.0, formR=1.0):\n        \"\"\"Calculates the `n`-site wavefunction on ``sites[i:i+n]``.\"\"\"\n    def convert_form(self, new_form='B'):\n        \"\"\"Transform self into different canonical form (by scaling the legs with singular values).\"\"\"\n    def enlarge_mps_unit_cell(self, factor=2):\n        \"\"\"Repeat the unit cell for infinite MPS boundary conditions; in place.\"\"\"\n    def roll_mps_unit_cell(self, shift=1):\n        \"\"\"Shift the section we define as unit cell of an infinite MPS; in place.\"\"\"\n    def overlap_translate_finite(self, psi, shift=1):\n        \"\"\"Contract ``<self|T^N|psi>`` for translation `T` with finite, periodic boundaries.\"\"\"\n    def enlarge_chi(self, extra_legs, random_fct=np.random.normal):\n        \"\"\"Artificially enlarge the bond dimension by the specified extra legs/charges. In place.\"\"\"\n    def spatial_inversion(self):\n        \"\"\"Perform a spatial inversion along the MPS.\"\"\"\n    def group_sites(self, n=2, grouped_sites=None):\n        \"\"\"Modify `self` inplace to group sites.\"\"\"\n    def group_split(self, trunc_par=None):\n        \"\"\"Modify `self` inplace to split previously grouped sites.\"\"\"\n    def get_grouped_mps(self, blocklen):\n        \"\"\"Like :meth:`group_sites`, but make a copy.\"\"\"\n    def extract_segment(self, first, last):\n        \"\"\"Extract an segment from a finite or infinite MPS.\"\"\"\n    def extract_enlarged_segment(self, psi_left, psi_right, first, last, add_unitcells=None, new_first_last=None, cutoff=1e-14):\n        \"\"\"Extract an enlarged segment from an initially smaller segment MPS.\"\"\"\n    def get_total_charge(self, only_physical_legs=False):\n        \"\"\"Calculate and return the `qtotal` of the whole MPS (when contracted).\"\"\"\n    def gauge_total_charge(self, qtotal=None, vL_leg=None, vR_leg=None):\n        \"\"\"Gauge the legcharges of the virtual bonds s.t. MPS has given `qtotal`; in place.\"\"\"\n    def entanglement_entropy(self, n=1, bonds=None, for_matrix_S=False):\n        \"\"\"Calculate the (half-chain) entanglement entropy for all nontrivial bonds.\"\"\"\n    def entanglement_entropy_segment(self, segment=[0], first_site=None, n=1):\n        \"\"\"Calculate entanglement entropy for general geometry of the bipartition.\"\"\"\n    def entanglement_entropy_segment2(self, segment, n=1):\n        \"\"\"Calculate entanglement entropy for general geometry of the bipartition.\"\"\"\n    def entanglement_spectrum(self, by_charge=False):\n        \"\"\"Return entanglement energy spectrum.\"\"\"\n    def get_rho_segment(self, segment):\n        \"\"\"Return reduced density matrix for a segment.\"\"\"\n    def probability_per_charge(self, bond=0):\n        \"\"\"Return probabilities of charge value on the left of a given bond.\"\"\"\n    def average_charge(self, bond=0):\n        \"\"\"Return the average charge for the block on the left of a given bond.\"\"\"\n    def charge_variance(self, bond=0):\n        \"\"\"Return the charge variance on the left of a given bond.\"\"\"\n    def get_charge_tree_for_given_charge_sector(sites: list, charge_sector: tuple):\n        \"\"\"Construct the charge-tree for a given charge sector.\"\"\"\n    def mutinf_two_site(self, max_range=None, n=1):\n        \"\"\"Calculate the two-site mutual information :math:`I(i:j)`.\"\"\"\n    def overlap(self, other, charge_sector=None, ignore_form=False, understood_infinite=False, **kwargs):\n        \"\"\"Compute overlap ``<self|other>``.\"\"\"\n    def expectation_value_terms_sum(self, term_list):\n        \"\"\"Calculate expectation values for a bunch of terms and sum them up.\"\"\"\n    def sample_measurements(self, first_site=0, last_site=None, ops=None, rng=None, norm_tol=1e-12, complex_amplitude=True):\n        \"\"\"Sample measurement results in the computational basis.\"\"\"\n    def norm_test(self):\n        \"\"\"Check that self is in canonical form.\"\"\"\n    def canonical_form(self, **kwargs):\n        \"\"\"Bring self into canonical 'B' form, (re-)calculate singular values; in place.\"\"\"\n    def canonical_form_finite(self, renormalize=True, cutoff=0.0, envs_to_update=None):\n        \"\"\"Bring a finite (or segment) MPS into canonical form; in place.\"\"\"\n    def canonical_form_infinite1(self, renormalize=True, tol_xi=1000000.0):\n        \"\"\"Bring an infinite MPS into canonical form; in place.\"\"\"\n    def canonical_form_infinite2(self, renormalize=True, tol=1e-15, arnoldi_params=None, cutoff=1e-15):\n        \"\"\"Convert infinite MPS to canonical form; in place.\"\"\"\n    def correlation_length2(self, target=1, tol_ev0=1e-08, charge_sector=0, return_charges=False):\n        \"\"\"Calculate the correlation length by diagonalizing the transfer matrix.\"\"\"\n    def correlation_length(self, target=1, tol_ev0=1e-08, charge_sector=0, return_charges=False):\n        \"\"\"Calculate the correlation length by diagonalizing the transfer matrix.\"\"\"\n    def correlation_length_charge_sectors(self, drop_symmetric=True, include_0=True):\n        \"\"\"Return possible `charge_sector` argument for :meth:`correlation_length`.\"\"\"\n    def add(self, other, alpha, beta, cutoff=1e-15):\n        \"\"\"Return an MPS which represents ``alpha|self> + beta |others>``.\"\"\"\n    def subspace_expansion(self, expand_into=[], trunc_par={'svd_min': 1e-08}):\n        \"\"\"Subspace expansion increasing chi without changing the represented state.\"\"\"\n    def apply_local_op(self, i, op, unitary=None, renormalize=False, cutoff=1e-13, understood_infinite=False):\n        \"\"\"Apply a local (one or multi-site) operator to `self`. In place.\"\"\"\n    def apply_product_op(self, ops, unitary=None, renormalize=False):\n        \"\"\"Apply a (global) product of local onsite operators to `self`. In place.\"\"\"\n    def apply_local_term(self, term, autoJW=True, i_offset=0, canonicalize=True, renormalize=False):\n        \"\"\"Similar as :meth:`apply_local_op`, but for a whole `term` acting on multiple sites.\"\"\"\n    def perturb(self, randomize_params=None, close_1=True, canonicalize=None):\n        \"\"\"Locally perturb the state a little bit; in place.\"\"\"\n    def swap_sites(self, i, swap_op='auto', trunc_par=None):\n        \"\"\"Swap the two neighboring sites `i` and `i+1`; in place.\"\"\"\n    def permute_sites(self, perm, swap_op='auto', trunc_par=None):\n        \"\"\"Applies the permutation perm to the state; in place.\"\"\"\n    def compute_K(self, perm, swap_op='auto', trunc_par=None, canonicalize=1e-06, expected_mean_k=0.0):\n        \"\"\"Compute the momentum quantum numbers of the entanglement spectrum for 2D states.\"\"\"\n    def compress(self, options):\n        \"\"\"Compress an MPS.\"\"\"\n    def compress_svd(self, trunc_par):\n        \"\"\"Compress `self` with a single sweep of SVDs; in place.\"\"\"\n    def outer_virtual_legs(self):\n        \"\"\"Return the virtual legs on the left and right of the MPS.\"\"\"",
    "search_text": "tenpy.networks.mps.mps # api definition: tenpy.networks.mps.mps\nclass mps:\n    \"\"\"a matrix product state, finite (mps) or infinite (imps).\"\"\"\n    def __init__(self, sites, bs, svs, bc='finite', form='b', norm=1.0, unit_cell_width=none, understood_shift_symmetry: bool=false): pass\n    def test_sanity(self):\n        \"\"\"sanity check, raises valueerrors, if something is wrong.\"\"\"\n    def copy(self):\n        \"\"\"returns a copy of `self`.\"\"\"\n    def save_hdf5(self, hdf5_saver, h5gr, subpath):\n        \"\"\"export `self` into a hdf5 file.\"\"\"\n    def from_hdf5(cls, hdf5_loader, h5gr, subpath):\n        \"\"\"load instance from a hdf5 file.\"\"\"\n    def from_lat_product_state(cls, lat, p_state, allow_incommensurate=false, **kwargs):\n        \"\"\"construct an mps from a product state given in lattice coordinates.\"\"\"\n    def from_product_state(cls, sites, p_state, bc='finite', dtype=np.float64, permute=true, form='b', chargel=none, unit_cell_width=none, understood_shift_symmetry: bool=false):\n        \"\"\"construct a matrix product state from a given product state.\"\"\"\n    def from_random_unitary_evolution(cls, sites, chi, p_state, bc='finite', dtype=np.float64, permute=true, form='b', chargel=none, understood_shift_symmetry: bool=false):\n        \"\"\"construct a matrix product state by evolving a product state with random unitaries.\"\"\"\n    def from_desired_bond_dimension(cls, sites, chis, bc='finite', dtype=np.float64, permute=true, chargel=none, unit_cell_width=none, understood_shift_symmetry: bool=false):\n        \"\"\"construct a matrix product state with given bond dimensions from random matrices.\"\"\"\n    def from_bflat(cls, sites, bflat, svs=none, bc='finite', dtype=none, permute=true, form='b', legl=none, unit_cell_width=none, understood_shift_symmetry: bool=false):\n        \"\"\"construct a matrix product state from a set of numpy arrays `bflat` and singular vals.\"\"\"\n    def from_full(cls, sites, psi, form=none, cutoff=1e-16, normalize=true, bc='finite', outer_s=none, unit_cell_width=none, understood_shift_symmetry: bool=false):\n        \"\"\"construct an mps from a single tensor `psi` with one leg per physical site.\"\"\"\n    def from_singlets(cls, site, l, pairs, up='up', down='down', lonely=[], lonely_state='up', bc='finite', unit_cell_width=none, understood_shift_symmetry: bool=false):\n        \"\"\"create an mps of entangled singlets.\"\"\"\n    def from_product_mps_covering(cls, mps_covering, index_map, bc='finite', unit_cell_width=none, understood_shift_symmetry: bool=false):\n        \"\"\"create an mps as a product of (many) local mps covering all sites to be created.\"\"\"\n    def project_onto_charge_sector(cls, sites, p_state_list, charge_sector, dtype=float, bc='finite', form='b', norm=1.0, unit_cell_width=none, understood_shift_symmetry: bool=false):\n        \"\"\"generates an mps from a product state list which is projected onto a given charge sector.\"\"\"\n    def l(self):\n        \"\"\"number of physical sites; for an imps the len of the mps unit cell.\"\"\"\n    def dim(self):\n        \"\"\"list of local physical dimensions.\"\"\"\n    def finite(self):\n        \"\"\"distinguish mps vs imps.\"\"\"\n    def chi(self):\n        \"\"\"dimensions of the (nontrivial) virtual bonds.\"\"\"\n    def get_b(self, i, form='b', copy=false, cutoff=1e-16, label_p=none):\n        \"\"\"return (view of) `b` at site `i` in canonical form.\"\"\"\n    def set_b(self, i, b, form='b'):\n        \"\"\"set `b` at site `i`.\"\"\"\n    def set_svd_theta(self, i, theta, trunc_par=none, update_norm=false):\n        \"\"\"svd a two-site wave function `theta` and save it in `self`.\"\"\"\n    def get_sl(self, i):\n        \"\"\"return singular values on the left of site `i`.\"\"\"\n    def get_sr(self, i):\n        \"\"\"return singular values on the right of site `i`.\"\"\"\n    def set_sl(self, i, s):\n        \"\"\"set singular values on the left of site `i`. no copy is made!\"\"\"\n    def set_sr(self, i, s):\n        \"\"\"set singular values on the right of site `i`. no copy is made!\"\"\"\n    def get_theta(self, i, n=2, cutoff=1e-16, forml=1.0, formr=1.0):\n        \"\"\"calculates the `n`-site wavefunction on ``sites[i:i+n]``.\"\"\"\n    def convert_form(self, new_form='b'):\n        \"\"\"transform self into different canonical form (by scaling the legs with singular values).\"\"\"\n    def enlarge_mps_unit_cell(self, factor=2):\n        \"\"\"repeat the unit cell for infinite mps boundary conditions; in place.\"\"\"\n    def roll_mps_unit_cell(self, shift=1):\n        \"\"\"shift the section we define as unit cell of an infinite mps; in place.\"\"\"\n    def overlap_translate_finite(self, psi, shift=1):\n        \"\"\"contract ``<self|t^n|psi>`` for translation `t` with finite, periodic boundaries.\"\"\"\n    def enlarge_chi(self, extra_legs, random_fct=np.random.normal):\n        \"\"\"artificially enlarge the bond dimension by the specified extra legs/charges. in place.\"\"\"\n    def spatial_inversion(self):\n        \"\"\"perform a spatial inversion along the mps.\"\"\"\n    def group_sites(self, n=2, grouped_sites=none):\n        \"\"\"modify `self` inplace to group sites.\"\"\"\n    def group_split(self, trunc_par=none):\n        \"\"\"modify `self` inplace to split previously grouped sites.\"\"\"\n    def get_grouped_mps(self, blocklen):\n        \"\"\"like :meth:`group_sites`, but make a copy.\"\"\"\n    def extract_segment(self, first, last):\n        \"\"\"extract an segment from a finite or infinite mps.\"\"\"\n    def extract_enlarged_segment(self, psi_left, psi_right, first, last, add_unitcells=none, new_first_last=none, cutoff=1e-14):\n        \"\"\"extract an enlarged segment from an initially smaller segment mps.\"\"\"\n    def get_total_charge(self, only_physical_legs=false):\n        \"\"\"calculate and return the `qtotal` of the whole mps (when contracted).\"\"\"\n    def gauge_total_charge(self, qtotal=none, vl_leg=none, vr_leg=none):\n        \"\"\"gauge the legcharges of the virtual bonds s.t. mps has given `qtotal`; in place.\"\"\"\n    def entanglement_entropy(self, n=1, bonds=none, for_matrix_s=false):\n        \"\"\"calculate the (half-chain) entanglement entropy for all nontrivial bonds.\"\"\"\n    def entanglement_entropy_segment(self, segment=[0], first_site=none, n=1):\n        \"\"\"calculate entanglement entropy for general geometry of the bipartition.\"\"\"\n    def entanglement_entropy_segment2(self, segment, n=1):\n        \"\"\"calculate entanglement entropy for general geometry of the bipartition.\"\"\"\n    def entanglement_spectrum(self, by_charge=false):\n        \"\"\"return entanglement energy spectrum.\"\"\"\n    def get_rho_segment(self, segment):\n        \"\"\"return reduced density matrix for a segment.\"\"\"\n    def probability_per_charge(self, bond=0):\n        \"\"\"return probabilities of charge value on the left of a given bond.\"\"\"\n    def average_charge(self, bond=0):\n        \"\"\"return the average charge for the block on the left of a given bond.\"\"\"\n    def charge_variance(self, bond=0):\n        \"\"\"return the charge variance on the left of a given bond.\"\"\"\n    def get_charge_tree_for_given_charge_sector(sites: list, charge_sector: tuple):\n        \"\"\"construct the charge-tree for a given charge sector.\"\"\"\n    def mutinf_two_site(self, max_range=none, n=1):\n        \"\"\"calculate the two-site mutual information :math:`i(i:j)`.\"\"\"\n    def overlap(self, other, charge_sector=none, ignore_form=false, understood_infinite=false, **kwargs):\n        \"\"\"compute overlap ``<self|other>``.\"\"\"\n    def expectation_value_terms_sum(self, term_list):\n        \"\"\"calculate expectation values for a bunch of terms and sum them up.\"\"\"\n    def sample_measurements(self, first_site=0, last_site=none, ops=none, rng=none, norm_tol=1e-12, complex_amplitude=true):\n        \"\"\"sample measurement results in the computational basis.\"\"\"\n    def norm_test(self):\n        \"\"\"check that self is in canonical form.\"\"\"\n    def canonical_form(self, **kwargs):\n        \"\"\"bring self into canonical 'b' form, (re-)calculate singular values; in place.\"\"\"\n    def canonical_form_finite(self, renormalize=true, cutoff=0.0, envs_to_update=none):\n        \"\"\"bring a finite (or segment) mps into canonical form; in place.\"\"\"\n    def canonical_form_infinite1(self, renormalize=true, tol_xi=1000000.0):\n        \"\"\"bring an infinite mps into canonical form; in place.\"\"\"\n    def canonical_form_infinite2(self, renormalize=true, tol=1e-15, arnoldi_params=none, cutoff=1e-15):\n        \"\"\"convert infinite mps to canonical form; in place.\"\"\"\n    def correlation_length2(self, target=1, tol_ev0=1e-08, charge_sector=0, return_charges=false):\n        \"\"\"calculate the correlation length by diagonalizing the transfer matrix.\"\"\"\n    def correlation_length(self, target=1, tol_ev0=1e-08, charge_sector=0, return_charges=false):\n        \"\"\"calculate the correlation length by diagonalizing the transfer matrix.\"\"\"\n    def correlation_length_charge_sectors(self, drop_symmetric=true, include_0=true):\n        \"\"\"return possible `charge_sector` argument for :meth:`correlation_length`.\"\"\"\n    def add(self, other, alpha, beta, cutoff=1e-15):\n        \"\"\"return an mps which represents ``alpha|self> + beta |others>``.\"\"\"\n    def subspace_expansion(self, expand_into=[], trunc_par={'svd_min': 1e-08}):\n        \"\"\"subspace expansion increasing chi without changing the represented state.\"\"\"\n    def apply_local_op(self, i, op, unitary=none, renormalize=false, cutoff=1e-13, understood_infinite=false):\n        \"\"\"apply a local (one or multi-site) operator to `self`. in place.\"\"\"\n    def apply_product_op(self, ops, unitary=none, renormalize=false):\n        \"\"\"apply a (global) product of local onsite operators to `self`. in place.\"\"\"\n    def apply_local_term(self, term, autojw=true, i_offset=0, canonicalize=true, renormalize=false):\n        \"\"\"similar as :meth:`apply_local_op`, but for a whole `term` acting on multiple sites.\"\"\"\n    def perturb(self, randomize_params=none, close_1=true, canonicalize=none):\n        \"\"\"locally perturb the state a little bit; in place.\"\"\"\n    def swap_sites(self, i, swap_op='auto', trunc_par=none):\n        \"\"\"swap the two neighboring sites `i` and `i+1`; in place.\"\"\"\n    def permute_sites(self, perm, swap_op='auto', trunc_par=none):\n        \"\"\"applies the permutation perm to the state; in place.\"\"\"\n    def compute_k(self, perm, swap_op='auto', trunc_par=none, canonicalize=1e-06, expected_mean_k=0.0):\n        \"\"\"compute the momentum quantum numbers of the entanglement spectrum for 2d states.\"\"\"\n    def compress(self, options):\n        \"\"\"compress an mps.\"\"\"\n    def compress_svd(self, trunc_par):\n        \"\"\"compress `self` with a single sweep of svds; in place.\"\"\"\n    def outer_virtual_legs(self):\n        \"\"\"return the virtual legs on the left and right of the mps.\"\"\" class mps tenpy.networks.mps",
    "tokens": 2574
  },
  {
    "category": "api",
    "name": "tenpy.networks.mps.BaseEnvironment",
    "content": "# API Definition: tenpy.networks.mps.BaseEnvironment\nclass BaseEnvironment:\n    \"\"\"Base class for :class:`MPSEnvironment` storing partial contractions between MPS.\"\"\"\n    def __init__(self, bra, ket, cache=None, **init_env_data): pass\n    def init_first_LP_last_RP(self, init_LP=None, init_RP=None, age_LP=0, age_RP=0, start_env_sites=0):\n        \"\"\"(Re)initialize first LP and last RP from the given data.\"\"\"\n    def test_sanity(self):\n        \"\"\"Sanity check, raises ValueErrors, if something is wrong.\"\"\"\n    def init_LP(self, i, start_env_sites=0):\n        \"\"\"Build initial left part ``LP``.\"\"\"\n    def init_RP(self, i, start_env_sites=0):\n        \"\"\"Build initial right part ``RP`` for an MPS/MPOEnvironment.\"\"\"\n    def get_LP(self, i, store=True):\n        \"\"\"Calculate LP at given site from nearest available one.\"\"\"\n    def get_RP(self, i, store=True):\n        \"\"\"Calculate RP at given site from nearest available one.\"\"\"\n    def get_LP_age(self, i):\n        \"\"\"Return number of physical sites in the contractions of get_LP(i).\"\"\"\n    def get_RP_age(self, i):\n        \"\"\"Return number of physical sites in the contractions of get_RP(i).\"\"\"\n    def set_LP(self, i, LP, age):\n        \"\"\"Store part to the left of site `i`. No copy is made!\"\"\"\n    def set_RP(self, i, RP, age):\n        \"\"\"Store part to the right of site `i`. No copy is made!\"\"\"\n    def del_LP(self, i):\n        \"\"\"Delete stored part strictly to the left of site `i`.\"\"\"\n    def del_RP(self, i):\n        \"\"\"Delete stored part strictly to the right of site `i`.\"\"\"\n    def clear(self):\n        \"\"\"Delete all partial contractions except the left-most `LP` and right-most `RP`.\"\"\"\n    def has_LP(self, i):\n        \"\"\"Return True if `LP` left of site `i` is stored.\"\"\"\n    def has_RP(self, i):\n        \"\"\"Return True if `RP` right of site `i` is stored.\"\"\"\n    def cache_optimize(self, short_term_LP=[], short_term_RP=[], preload_LP=None, preload_RP=None):\n        \"\"\"Update `short_term_keys` for the cache and possibly preload tensors.\"\"\"\n    def get_initialization_data(self, first=0, last=None, include_bra=False, include_ket=False):\n        \"\"\"Return data for (re-)initialization of the environment.\"\"\"\n    def full_contraction(self, i0):\n        \"\"\"Calculate the overlap by a full contraction of the network.\"\"\"\n    def expectation_value_terms_sum(self, term_list):\n        \"\"\"Calculate expectation values for a bunch of terms and sum them up.\"\"\"",
    "search_text": "tenpy.networks.mps.baseenvironment # api definition: tenpy.networks.mps.baseenvironment\nclass baseenvironment:\n    \"\"\"base class for :class:`mpsenvironment` storing partial contractions between mps.\"\"\"\n    def __init__(self, bra, ket, cache=none, **init_env_data): pass\n    def init_first_lp_last_rp(self, init_lp=none, init_rp=none, age_lp=0, age_rp=0, start_env_sites=0):\n        \"\"\"(re)initialize first lp and last rp from the given data.\"\"\"\n    def test_sanity(self):\n        \"\"\"sanity check, raises valueerrors, if something is wrong.\"\"\"\n    def init_lp(self, i, start_env_sites=0):\n        \"\"\"build initial left part ``lp``.\"\"\"\n    def init_rp(self, i, start_env_sites=0):\n        \"\"\"build initial right part ``rp`` for an mps/mpoenvironment.\"\"\"\n    def get_lp(self, i, store=true):\n        \"\"\"calculate lp at given site from nearest available one.\"\"\"\n    def get_rp(self, i, store=true):\n        \"\"\"calculate rp at given site from nearest available one.\"\"\"\n    def get_lp_age(self, i):\n        \"\"\"return number of physical sites in the contractions of get_lp(i).\"\"\"\n    def get_rp_age(self, i):\n        \"\"\"return number of physical sites in the contractions of get_rp(i).\"\"\"\n    def set_lp(self, i, lp, age):\n        \"\"\"store part to the left of site `i`. no copy is made!\"\"\"\n    def set_rp(self, i, rp, age):\n        \"\"\"store part to the right of site `i`. no copy is made!\"\"\"\n    def del_lp(self, i):\n        \"\"\"delete stored part strictly to the left of site `i`.\"\"\"\n    def del_rp(self, i):\n        \"\"\"delete stored part strictly to the right of site `i`.\"\"\"\n    def clear(self):\n        \"\"\"delete all partial contractions except the left-most `lp` and right-most `rp`.\"\"\"\n    def has_lp(self, i):\n        \"\"\"return true if `lp` left of site `i` is stored.\"\"\"\n    def has_rp(self, i):\n        \"\"\"return true if `rp` right of site `i` is stored.\"\"\"\n    def cache_optimize(self, short_term_lp=[], short_term_rp=[], preload_lp=none, preload_rp=none):\n        \"\"\"update `short_term_keys` for the cache and possibly preload tensors.\"\"\"\n    def get_initialization_data(self, first=0, last=none, include_bra=false, include_ket=false):\n        \"\"\"return data for (re-)initialization of the environment.\"\"\"\n    def full_contraction(self, i0):\n        \"\"\"calculate the overlap by a full contraction of the network.\"\"\"\n    def expectation_value_terms_sum(self, term_list):\n        \"\"\"calculate expectation values for a bunch of terms and sum them up.\"\"\" class baseenvironment tenpy.networks.mps",
    "tokens": 602
  },
  {
    "category": "api",
    "name": "tenpy.networks.mps.MPSEnvironment",
    "content": "# API Definition: tenpy.networks.mps.MPSEnvironment\nclass MPSEnvironment:\n    \"\"\"Class storing partial contractions between two different MPS and providing expectation values.\"\"\"\n    def full_contraction(self, i0):\n        \"\"\"Calculate the overlap by a full contraction of the network.\"\"\"",
    "search_text": "tenpy.networks.mps.mpsenvironment # api definition: tenpy.networks.mps.mpsenvironment\nclass mpsenvironment:\n    \"\"\"class storing partial contractions between two different mps and providing expectation values.\"\"\"\n    def full_contraction(self, i0):\n        \"\"\"calculate the overlap by a full contraction of the network.\"\"\" class mpsenvironment tenpy.networks.mps",
    "tokens": 61
  },
  {
    "category": "api",
    "name": "tenpy.networks.mps.TransferMatrix",
    "content": "# API Definition: tenpy.networks.mps.TransferMatrix\nclass TransferMatrix:\n    \"\"\"Transfer matrix of two MPS (bra & ket).\"\"\"\n    def __init__(self, bra, ket, shift_bra=0, shift_ket=0, transpose=False, charge_sector=0, form='B'): pass\n    def from_Ns_Ms(cls, bra_N, ket_M, transpose=False, charge_sector=0, p_label=['p'], conjugate_Ns=True, unit_cell_width=None):\n        \"\"\"Initialize a TransferMatrix directly from the MPS tensors.\"\"\"\n    def charge_sector(self): pass\n    def charge_sector(self, value): pass\n    def matvec(self, vec):\n        \"\"\"Given `vec` as an npc.Array, apply the transfer matrix.\"\"\"\n    def initial_guess(self, diag=1.0):\n        \"\"\"Return a diagonal matrix as initial guess for the eigenvector.\"\"\"\n    def eigenvectors(self, *args, **kwargs):\n        \"\"\"Find (dominant) eigenvector(s) of self using :mod:`scipy.sparse`.\"\"\"",
    "search_text": "tenpy.networks.mps.transfermatrix # api definition: tenpy.networks.mps.transfermatrix\nclass transfermatrix:\n    \"\"\"transfer matrix of two mps (bra & ket).\"\"\"\n    def __init__(self, bra, ket, shift_bra=0, shift_ket=0, transpose=false, charge_sector=0, form='b'): pass\n    def from_ns_ms(cls, bra_n, ket_m, transpose=false, charge_sector=0, p_label=['p'], conjugate_ns=true, unit_cell_width=none):\n        \"\"\"initialize a transfermatrix directly from the mps tensors.\"\"\"\n    def charge_sector(self): pass\n    def charge_sector(self, value): pass\n    def matvec(self, vec):\n        \"\"\"given `vec` as an npc.array, apply the transfer matrix.\"\"\"\n    def initial_guess(self, diag=1.0):\n        \"\"\"return a diagonal matrix as initial guess for the eigenvector.\"\"\"\n    def eigenvectors(self, *args, **kwargs):\n        \"\"\"find (dominant) eigenvector(s) of self using :mod:`scipy.sparse`.\"\"\" class transfermatrix tenpy.networks.mps",
    "tokens": 223
  },
  {
    "category": "api",
    "name": "tenpy.networks.mps.InitialStateBuilder",
    "content": "# API Definition: tenpy.networks.mps.InitialStateBuilder\nclass InitialStateBuilder:\n    \"\"\"Class to simplify providing common sets of initial states.\"\"\"\n    def __init__(self, lattice, options, model_dtype=np.float64): pass\n    def run(self):\n        \"\"\"Build an initial state from a specified method.\"\"\"\n    def check_total_charge(self, psi):\n        \"\"\"Assert that the given state has the expected charge.\"\"\"\n    def from_file(self):\n        \"\"\"Load the initial state from an existing file.\"\"\"\n    def lat_product_state(self, p_state=None):\n        \"\"\"Initialize from a lattice product state.\"\"\"\n    def mps_product_state(self, p_state=None):\n        \"\"\"Initialize from a product state.\"\"\"\n    def mps_state_in_charge_sector(self, charge_sector=None, p_state=None):\n        \"\"\"Initialize a state on a lattice already in a desired charge sector.\"\"\"\n    def desired_bond_dimension(self, chi=None):\n        \"\"\"Initialize a trivial charge MPS with desired bond dimension.\"\"\"\n    def check_filling(self, p_state):\n        \"\"\"Ensure that the filling of the product state matches `check_filling` parameter.\"\"\"\n    def fill_where(self):\n        \"\"\"Allow to specify a condition where sites should be filled.\"\"\"\n    def fill_where__get_variables(self):\n        \"\"\"Define the variables which can be used in the condition of :meth:`fill_where`.\"\"\"\n    def randomized(self):\n        \"\"\"Initialize a state with another method and then apply a RandomUnitaryEvolution.\"\"\"",
    "search_text": "tenpy.networks.mps.initialstatebuilder # api definition: tenpy.networks.mps.initialstatebuilder\nclass initialstatebuilder:\n    \"\"\"class to simplify providing common sets of initial states.\"\"\"\n    def __init__(self, lattice, options, model_dtype=np.float64): pass\n    def run(self):\n        \"\"\"build an initial state from a specified method.\"\"\"\n    def check_total_charge(self, psi):\n        \"\"\"assert that the given state has the expected charge.\"\"\"\n    def from_file(self):\n        \"\"\"load the initial state from an existing file.\"\"\"\n    def lat_product_state(self, p_state=none):\n        \"\"\"initialize from a lattice product state.\"\"\"\n    def mps_product_state(self, p_state=none):\n        \"\"\"initialize from a product state.\"\"\"\n    def mps_state_in_charge_sector(self, charge_sector=none, p_state=none):\n        \"\"\"initialize a state on a lattice already in a desired charge sector.\"\"\"\n    def desired_bond_dimension(self, chi=none):\n        \"\"\"initialize a trivial charge mps with desired bond dimension.\"\"\"\n    def check_filling(self, p_state):\n        \"\"\"ensure that the filling of the product state matches `check_filling` parameter.\"\"\"\n    def fill_where(self):\n        \"\"\"allow to specify a condition where sites should be filled.\"\"\"\n    def fill_where__get_variables(self):\n        \"\"\"define the variables which can be used in the condition of :meth:`fill_where`.\"\"\"\n    def randomized(self):\n        \"\"\"initialize a state with another method and then apply a randomunitaryevolution.\"\"\" class initialstatebuilder tenpy.networks.mps",
    "tokens": 299
  },
  {
    "category": "api",
    "name": "tenpy.networks.mps.build_initial_state",
    "content": "# API Function: tenpy.networks.mps.build_initial_state\ndef build_initial_state(size, states, filling, mode='random', seed=None):\n    \"\"\"Build an \"initial state\" list.\"\"\"",
    "search_text": "tenpy.networks.mps.build_initial_state # api function: tenpy.networks.mps.build_initial_state\ndef build_initial_state(size, states, filling, mode='random', seed=none):\n    \"\"\"build an \"initial state\" list.\"\"\" function build_initial_state",
    "tokens": 41
  },
  {
    "category": "api",
    "name": "tenpy.networks.site.Site",
    "content": "# API Definition: tenpy.networks.site.Site\nclass Site:\n    \"\"\"Collects necessary information about a single local site of a lattice.\"\"\"\n    def __init__(self, leg, state_labels=None, sort_charge=True, **site_ops): pass\n    def change_charge(self, new_leg_charge=None, permute=None):\n        \"\"\"Change the charges of the site (in place).\"\"\"\n    def sort_charge(self, bunch=True):\n        \"\"\"Sort the :attr:`leg` charges (in place).\"\"\"\n    def test_sanity(self):\n        \"\"\"Sanity check, raises ValueErrors, if something is wrong.\"\"\"\n    def dim(self):\n        \"\"\"Dimension of the local Hilbert space.\"\"\"\n    def onsite_ops(self):\n        \"\"\"Dictionary of on-site operators for iteration.\"\"\"\n    def add_op(self, name, op, need_JW=False, hc=None, permute_dense=None):\n        \"\"\"Add one on-site operators.\"\"\"\n    def rename_op(self, old_name, new_name):\n        \"\"\"Rename an added operator.\"\"\"\n    def remove_op(self, name):\n        \"\"\"Remove an added operator.\"\"\"\n    def state_index(self, label):\n        \"\"\"Return index of a basis state from its label.\"\"\"\n    def state_indices(self, labels):\n        \"\"\"Same as :meth:`state_index`, but for multiple labels.\"\"\"\n    def get_op(self, name):\n        \"\"\"Return operator of given name.\"\"\"\n    def get_hc_op_name(self, name):\n        \"\"\"Return the hermitian conjugate of a given operator.\"\"\"\n    def op_needs_JW(self, name):\n        \"\"\"Whether an (composite) onsite operator is fermionic and needs a Jordan-Wigner string.\"\"\"\n    def valid_opname(self, name):\n        \"\"\"Check whether 'name' labels a valid onsite-operator.\"\"\"\n    def multiply_op_names(self, names):\n        \"\"\"Multiply operator names together.\"\"\"\n    def multiply_operators(self, operators):\n        \"\"\"Multiply local operators (possibly given by their names) together.\"\"\"\n    def charge_to_JW_signs(self, charges):\n        \"\"\"Convert charge values to Jordan-Wigner parity.\"\"\"",
    "search_text": "tenpy.networks.site.site # api definition: tenpy.networks.site.site\nclass site:\n    \"\"\"collects necessary information about a single local site of a lattice.\"\"\"\n    def __init__(self, leg, state_labels=none, sort_charge=true, **site_ops): pass\n    def change_charge(self, new_leg_charge=none, permute=none):\n        \"\"\"change the charges of the site (in place).\"\"\"\n    def sort_charge(self, bunch=true):\n        \"\"\"sort the :attr:`leg` charges (in place).\"\"\"\n    def test_sanity(self):\n        \"\"\"sanity check, raises valueerrors, if something is wrong.\"\"\"\n    def dim(self):\n        \"\"\"dimension of the local hilbert space.\"\"\"\n    def onsite_ops(self):\n        \"\"\"dictionary of on-site operators for iteration.\"\"\"\n    def add_op(self, name, op, need_jw=false, hc=none, permute_dense=none):\n        \"\"\"add one on-site operators.\"\"\"\n    def rename_op(self, old_name, new_name):\n        \"\"\"rename an added operator.\"\"\"\n    def remove_op(self, name):\n        \"\"\"remove an added operator.\"\"\"\n    def state_index(self, label):\n        \"\"\"return index of a basis state from its label.\"\"\"\n    def state_indices(self, labels):\n        \"\"\"same as :meth:`state_index`, but for multiple labels.\"\"\"\n    def get_op(self, name):\n        \"\"\"return operator of given name.\"\"\"\n    def get_hc_op_name(self, name):\n        \"\"\"return the hermitian conjugate of a given operator.\"\"\"\n    def op_needs_jw(self, name):\n        \"\"\"whether an (composite) onsite operator is fermionic and needs a jordan-wigner string.\"\"\"\n    def valid_opname(self, name):\n        \"\"\"check whether 'name' labels a valid onsite-operator.\"\"\"\n    def multiply_op_names(self, names):\n        \"\"\"multiply operator names together.\"\"\"\n    def multiply_operators(self, operators):\n        \"\"\"multiply local operators (possibly given by their names) together.\"\"\"\n    def charge_to_jw_signs(self, charges):\n        \"\"\"convert charge values to jordan-wigner parity.\"\"\" class site tenpy.networks.site",
    "tokens": 421
  },
  {
    "category": "api",
    "name": "tenpy.networks.site.GroupedSite",
    "content": "# API Definition: tenpy.networks.site.GroupedSite\nclass GroupedSite:\n    \"\"\"Group two or more :class:`Site` into a larger one.\"\"\"\n    def __init__(self, sites, labels=None, charges='same'): pass\n    def kroneckerproduct(self, ops):\n        \"\"\"Return the Kronecker product :math:`op0 \\otimes op1` of local operators.\"\"\"",
    "search_text": "tenpy.networks.site.groupedsite # api definition: tenpy.networks.site.groupedsite\nclass groupedsite:\n    \"\"\"group two or more :class:`site` into a larger one.\"\"\"\n    def __init__(self, sites, labels=none, charges='same'): pass\n    def kroneckerproduct(self, ops):\n        \"\"\"return the kronecker product :math:`op0 \\otimes op1` of local operators.\"\"\" class groupedsite tenpy.networks.site",
    "tokens": 85
  },
  {
    "category": "api",
    "name": "tenpy.networks.site.group_sites",
    "content": "# API Function: tenpy.networks.site.group_sites\ndef group_sites(sites, n=2, labels=None, charges='same'):\n    \"\"\"Given a list of sites, group each `n` sites together.\"\"\"",
    "search_text": "tenpy.networks.site.group_sites # api function: tenpy.networks.site.group_sites\ndef group_sites(sites, n=2, labels=none, charges='same'):\n    \"\"\"given a list of sites, group each `n` sites together.\"\"\" function group_sites",
    "tokens": 45
  },
  {
    "category": "api",
    "name": "tenpy.networks.site.set_common_charges",
    "content": "# API Function: tenpy.networks.site.set_common_charges\ndef set_common_charges(sites, new_charges='same', new_names=None, new_mod=None, sort_charge=True):\n    \"\"\"Adjust the charges of the given sites *in place* such that they can be used together.\"\"\"",
    "search_text": "tenpy.networks.site.set_common_charges # api function: tenpy.networks.site.set_common_charges\ndef set_common_charges(sites, new_charges='same', new_names=none, new_mod=none, sort_charge=true):\n    \"\"\"adjust the charges of the given sites *in place* such that they can be used together.\"\"\" function set_common_charges",
    "tokens": 61
  },
  {
    "category": "api",
    "name": "tenpy.networks.site.kron",
    "content": "# API Function: tenpy.networks.site.kron\ndef kron(*ops):\n    \"\"\"Kronecker product of two or more local operators.\"\"\"",
    "search_text": "tenpy.networks.site.kron # api function: tenpy.networks.site.kron\ndef kron(*ops):\n    \"\"\"kronecker product of two or more local operators.\"\"\" function kron",
    "tokens": 30
  },
  {
    "category": "api",
    "name": "tenpy.networks.site.SpinHalfSite",
    "content": "# API Definition: tenpy.networks.site.SpinHalfSite\nclass SpinHalfSite:\n    \"\"\"Spin-1/2 site.\"\"\"\n    def __init__(self, conserve='Sz', sort_charge=True): pass",
    "search_text": "tenpy.networks.site.spinhalfsite # api definition: tenpy.networks.site.spinhalfsite\nclass spinhalfsite:\n    \"\"\"spin-1/2 site.\"\"\"\n    def __init__(self, conserve='sz', sort_charge=true): pass class spinhalfsite tenpy.networks.site",
    "tokens": 44
  },
  {
    "category": "api",
    "name": "tenpy.networks.site.SpinSite",
    "content": "# API Definition: tenpy.networks.site.SpinSite\nclass SpinSite:\n    \"\"\"General Spin S site.\"\"\"\n    def __init__(self, S=0.5, conserve='Sz', sort_charge=True): pass",
    "search_text": "tenpy.networks.site.spinsite # api definition: tenpy.networks.site.spinsite\nclass spinsite:\n    \"\"\"general spin s site.\"\"\"\n    def __init__(self, s=0.5, conserve='sz', sort_charge=true): pass class spinsite tenpy.networks.site",
    "tokens": 46
  },
  {
    "category": "api",
    "name": "tenpy.networks.site.FermionSite",
    "content": "# API Definition: tenpy.networks.site.FermionSite\nclass FermionSite:\n    \"\"\"Create a :class:`Site` for spin-less fermions.\"\"\"\n    def __init__(self, conserve='N', filling=0.5): pass",
    "search_text": "tenpy.networks.site.fermionsite # api definition: tenpy.networks.site.fermionsite\nclass fermionsite:\n    \"\"\"create a :class:`site` for spin-less fermions.\"\"\"\n    def __init__(self, conserve='n', filling=0.5): pass class fermionsite tenpy.networks.site",
    "tokens": 52
  },
  {
    "category": "api",
    "name": "tenpy.networks.site.SpinHalfFermionSite",
    "content": "# API Definition: tenpy.networks.site.SpinHalfFermionSite\nclass SpinHalfFermionSite:\n    \"\"\"Create a :class:`Site` for spinful (spin-1/2) fermions.\"\"\"\n    def __init__(self, cons_N='N', cons_Sz='Sz', filling=1.0): pass",
    "search_text": "tenpy.networks.site.spinhalffermionsite # api definition: tenpy.networks.site.spinhalffermionsite\nclass spinhalffermionsite:\n    \"\"\"create a :class:`site` for spinful (spin-1/2) fermions.\"\"\"\n    def __init__(self, cons_n='n', cons_sz='sz', filling=1.0): pass class spinhalffermionsite tenpy.networks.site",
    "tokens": 72
  },
  {
    "category": "api",
    "name": "tenpy.networks.site.SpinHalfHoleSite",
    "content": "# API Definition: tenpy.networks.site.SpinHalfHoleSite\nclass SpinHalfHoleSite:\n    \"\"\"Create a :class:`Site` for spinful (spin-1/2) fermions, restricted to empty or singly occupied sites\"\"\"\n    def __init__(self, cons_N='N', cons_Sz='Sz', filling=1.0): pass",
    "search_text": "tenpy.networks.site.spinhalfholesite # api definition: tenpy.networks.site.spinhalfholesite\nclass spinhalfholesite:\n    \"\"\"create a :class:`site` for spinful (spin-1/2) fermions, restricted to empty or singly occupied sites\"\"\"\n    def __init__(self, cons_n='n', cons_sz='sz', filling=1.0): pass class spinhalfholesite tenpy.networks.site",
    "tokens": 78
  },
  {
    "category": "api",
    "name": "tenpy.networks.site.BosonSite",
    "content": "# API Definition: tenpy.networks.site.BosonSite\nclass BosonSite:\n    \"\"\"Create a :class:`Site` for up to `Nmax` bosons.\"\"\"\n    def __init__(self, Nmax=1, conserve='N', filling=0.0): pass",
    "search_text": "tenpy.networks.site.bosonsite # api definition: tenpy.networks.site.bosonsite\nclass bosonsite:\n    \"\"\"create a :class:`site` for up to `nmax` bosons.\"\"\"\n    def __init__(self, nmax=1, conserve='n', filling=0.0): pass class bosonsite tenpy.networks.site",
    "tokens": 61
  },
  {
    "category": "api",
    "name": "tenpy.networks.site.spin_half_species",
    "content": "# API Function: tenpy.networks.site.spin_half_species\ndef spin_half_species(SpeciesSite, cons_N, cons_Sz, **kwargs):\n    \"\"\"Initialize two FermionSite to represent spin-1/2 species.\"\"\"",
    "search_text": "tenpy.networks.site.spin_half_species # api function: tenpy.networks.site.spin_half_species\ndef spin_half_species(speciessite, cons_n, cons_sz, **kwargs):\n    \"\"\"initialize two fermionsite to represent spin-1/2 species.\"\"\" function spin_half_species",
    "tokens": 47
  },
  {
    "category": "api",
    "name": "tenpy.networks.site.ClockSite",
    "content": "# API Definition: tenpy.networks.site.ClockSite\nclass ClockSite:\n    \"\"\"Quantum clock site.\"\"\"\n    def __init__(self, q, conserve='Z', sort_charge=True): pass",
    "search_text": "tenpy.networks.site.clocksite # api definition: tenpy.networks.site.clocksite\nclass clocksite:\n    \"\"\"quantum clock site.\"\"\"\n    def __init__(self, q, conserve='z', sort_charge=true): pass class clocksite tenpy.networks.site",
    "tokens": 41
  },
  {
    "category": "tutorials",
    "name": "doc.examples",
    "content": "--- DOCUMENTATION: examples ---\nExamples\n========\n\nToy codes\n---------\n\nThese \"toy codes\" are meant to give you a flavor of the different algorithms,\nwhile keeping the codes as readable and simple as possible.\nThey can be found in a separate [TeNPyToycodes]_ repository https://github.com/tenpy/tenpy_notebooks in the folder ``tenpy_toycodes/``.\nThe only requirements to run them are Python 3, Numpy, and Scipy, (and jupyter for running the notebooks).\nFor reference, we include them here as examples.\n\n    :glob:\n\n    toycode_stubs/*\n\nIt has the following tutorial notebooks.\n\n    :glob:\n    :maxdepth: 1\n\n    toycodes/*\n\nPython scripts\n--------------\n\nThese example scripts illustrate the very basic interface for calling TeNPy.\nThey are included in the [TeNPySource]_ repository in the folder ``examples/``,\nwe include them here in the documentation for reference.\nYou need to install TeNPy to call them (see :doc:`/INSTALL`), but you can copy them anywhere before execution.\n(Some scripts include other files from the same folder, though; copy those as well.)\n\n    :glob:\n\n    examples/*\n\nA bit more elaborate examples from the subfolders in ``examples/*`` are included in this list:\n\n    :glob:\n\n    examples/advanced/*\n    examples/chern_insulators/*\n\n\nYAML config examples\n--------------------\nWe also have abunch of example config files that can be used for standard simulations, see :doc:`/intro/simulations`.\n\n    :glob:\n\n    examples/yaml/*\n\n\nJupyter Notebooks\n-----------------\n\nThis is a collection of [jupyter]_ notebooks from the [TeNPyNotebooks]_ repository.\nYou need to install TeNPy to execute them (see :doc:`/INSTALL`), but you can copy them anywhere before execution.\nNote that some of them might take a while to run, as they contain more extensive examples.\n\n    :glob:\n    :maxdepth: 1\n\n    notebooks/*",
    "search_text": "doc.examples --- documentation: examples ---\nexamples\n========\n\ntoy codes\n---------\n\nthese \"toy codes\" are meant to give you a flavor of the different algorithms,\nwhile keeping the codes as readable and simple as possible.\nthey can be found in a separate [tenpytoycodes]_ repository https://github.com/tenpy/tenpy_notebooks in the folder ``tenpy_toycodes/``.\nthe only requirements to run them are python 3, numpy, and scipy, (and jupyter for running the notebooks).\nfor reference, we include them here as examples.\n\n    :glob:\n\n    toycode_stubs/*\n\nit has the following tutorial notebooks.\n\n    :glob:\n    :maxdepth: 1\n\n    toycodes/*\n\npython scripts\n--------------\n\nthese example scripts illustrate the very basic interface for calling tenpy.\nthey are included in the [tenpysource]_ repository in the folder ``examples/``,\nwe include them here in the documentation for reference.\nyou need to install tenpy to call them (see :doc:`/install`), but you can copy them anywhere before execution.\n(some scripts include other files from the same folder, though; copy those as well.)\n\n    :glob:\n\n    examples/*\n\na bit more elaborate examples from the subfolders in ``examples/*`` are included in this list:\n\n    :glob:\n\n    examples/advanced/*\n    examples/chern_insulators/*\n\n\nyaml config examples\n--------------------\nwe also have abunch of example config files that can be used for standard simulations, see :doc:`/intro/simulations`.\n\n    :glob:\n\n    examples/yaml/*\n\n\njupyter notebooks\n-----------------\n\nthis is a collection of [jupyter]_ notebooks from the [tenpynotebooks]_ repository.\nyou need to install tenpy to execute them (see :doc:`/install`), but you can copy them anywhere before execution.\nnote that some of them might take a while to run, as they contain more extensive examples.\n\n    :glob:\n    :maxdepth: 1\n\n    notebooks/* tutorial documentation examples",
    "tokens": 429
  },
  {
    "category": "tutorials",
    "name": "doc.contributing",
    "content": "--- DOCUMENTATION: contributing ---\nContributing\n============\n\nThere are lots of things where you can help, even if you don't wont to dig deep into the source code.\nYou are welcome to do any of the following things, all of them are very helpful!\n\n- Report bugs and problems, such that they can be fixed.\n- Implement new models.\n- Update and extend the documentation.\n- Provide examples of how to use TeNPy.\n- Give feedback on how you like TeNPy and what you would like to see improved.\n- Help fixing bugs.\n- Help fixing minor issues.\n- Extend the functionality by implementing new functions, methods, and algorithms.\n\nThe code is maintained in a git repository, the official repository is on `github <https://github.com/tenpy/tenpy>`_.\nEven if you're not yet on the developer team, you can still submit pull requests on github.\nIf you're unsure how or what to do, you can ask for help in the [TeNPyForum]_.\nIf you want to become a member of the developer team, just ask ;-)\n\n**Thank You**!\n\n    :maxdepth: 1\n\n    contr/guidelines\n    contr/release\n    contr/build_doc\n    contr/todo",
    "search_text": "doc.contributing --- documentation: contributing ---\ncontributing\n============\n\nthere are lots of things where you can help, even if you don't wont to dig deep into the source code.\nyou are welcome to do any of the following things, all of them are very helpful!\n\n- report bugs and problems, such that they can be fixed.\n- implement new models.\n- update and extend the documentation.\n- provide examples of how to use tenpy.\n- give feedback on how you like tenpy and what you would like to see improved.\n- help fixing bugs.\n- help fixing minor issues.\n- extend the functionality by implementing new functions, methods, and algorithms.\n\nthe code is maintained in a git repository, the official repository is on `github <https://github.com/tenpy/tenpy>`_.\neven if you're not yet on the developer team, you can still submit pull requests on github.\nif you're unsure how or what to do, you can ask for help in the [tenpyforum]_.\nif you want to become a member of the developer team, just ask ;-)\n\n**thank you**!\n\n    :maxdepth: 1\n\n    contr/guidelines\n    contr/release\n    contr/build_doc\n    contr/todo tutorial documentation contributing",
    "tokens": 255
  },
  {
    "category": "tutorials",
    "name": "doc.literature",
    "content": "--- DOCUMENTATION: literature ---\nLiterature and References\n=========================\n\nThis is a (by far non-exhaustive) list of some references for the various ideas behind the code.\nThey can be cited like this:\n\n- [TeNPyNotes]_ for TeNPy/software related sources\n- white1992 (lowercase first-author + year) for entries from `literature.bib`.\n\n.. comment\n    When you add something, please also add a reference to it, i.e., give a short comment in the top of the subsection.\n\nTeNPy related sources\n---------------------\n[TeNPyNotes]_ are lecture notes, meant as an introduction to tensor networks (focusing on MPS), and introduced TeNPy to\nthe scientific community by giving examples how to call the algorithms in TeNPy.\n[TeNPySource]_ is the location of the source code, and the place where you can report bugs.\nWe have split example notebooks into [TeNPyNotebooks]_ to keep the git history of the original repository clean.\n[TeNPyDoc]_ is where the documentation is hosted online.\n[TeNPyForum]_ is the place where you can ask questions and look for help when you are stuck with implementing something.\n\n.. [TeNPyNotes]\n    \"Efficient numerical simulations with Tensor Networks: Tensor Network Python (TeNPy)\"\n    J. Hauschild, F. Pollmann, SciPost Phys. Lect. Notes 5 (2018), 1805.00055, :doi:`10.21468/SciPostPhysLectNotes.5`\n    also below as hauschild2018a.\n.. [TeNPySource]\n    https://github.com/tenpy/tenpy\n.. [TeNPyToycodes]\n    Collection of very simple toy code python scripts and tutorial notebooks at https://github.com/tenpy/tenpy_notbooks.\n    Included in the documentation under :doc:`/examples`\n.. [TeNPyNotebooks]\n    Collection of example [jupyter]_ notebooks using TeNPy: https://github.com/tenpy/tenpy_notebooks\n.. [TeNPyDoc]\n    Online documentation, https://tenpy.readthedocs.io/\n.. [TeNPyForum]\n    Community forum for discussions, FAQ and announcements, https://tenpy.johannes-hauschild.de\n.. [TeNPyProjectTemplate]\n    Template git repository for custom projects with a simplified setup for running many simulations on a cluster,\n    https://github.com/tenpy/project_template\n\nSoftware-related\n----------------\nThe following links are not physics-related, but are good to know if you want to work with TeNPy (or more generally Python).\n\n.. [git]\n    \"git version control system\", https://git-scm.com\n    A software which we use to keep track of changes in the source code.\n\n.. [conda]\n    \"conda package manger\", https://docs.conda.io/en/latest/\n    A package and environment management system that allows to easily install (multiple version of) various software,\n    and in particular python packages like TeNPy.\n\n.. [pip]\n    \"pip - the Python Package installer\", https://pip.pypa.io/en/stable/\n    Traditional way to handle installed python packages with ``pip install ...`` and ``pip uninstall ...`` on the command line.\n\n.. [matplotlib]\n    \"Matplotlib\", https://matplotlib.org/\n    A Python 2D plotting library. Some TeNPy functions expect matplotlib.axes.Axes as arguments to plot into.\n\n.. [HDF5]\n    \"Hierarchical Data Format 5 (R)\", https://portal.hdfgroup.org/display/HDF5/HDF5\n    A file format and library for saving data (including metadata).\n    We use it through the python interface of the `h5py <https://docs.h5py.org/en/stable/>`_ library,\n    see :doc:`/intro/input_output`.\n\n.. [yaml]\n    \"YAML Ain't Markup Language\", https://yaml.org\n    A human-readable file format for configuration files.\n    TeNpy (optionally) uses it through `pyyaml <https://pyyaml.org/>`_ for reading in simulation parameters, and in some\n    places in the documentation to keep things more readable.\n\n.. [jupyter]\n    Jupyter notebooks, https://jupyter.org/\n    An amazing interface for (python) notebooks which can contain both source code, text and outputs in a single file.\n    They provide a good way to get started with python, we use them for examples.\n\nGeneral reading\n---------------\nschollwoeck2011 is an extensive introduction to MPS, DMRG and TEBD with lots of details on the implementations, and a classic read, although a bit lengthy.\nOur [TeNPyNotes]_ are a shorter summary of the important concepts, similar as orus2014.\npaeckel2019 is a very good, recent review focusing on time evolution with MPS.\nThe lecture notes of eisert2013 explain the area law as motivation for tensor networks very well.\nPEPS are for example reviewed in verstraete2008, eisert2013 and orus2014.\ncirac2020 is a recent, broad review of MPS and MPS with a focus on analytical theorems.\nstoudenmire2012 reviews the use of DMRG for 2D systems.\ncirac2009 discusses the different groups of tensor network states.\nvanderstraeten2019 is a great review on tangent space methods for infinite, uniform MPS.\n\n\nAlgorithm developments\n----------------------\n:cite:`white1992,white1993` is the invention of DMRG, which started everything.\nvidal2004 introduced TEBD.\nwhite2005 and hubig2015 solved problems for single-site DMRG.\nmcculloch2008 was a huge step forward to solve convergence problems for infinite DMRG.\n:cite:`singh2010,singh2011` explain how to incorporate Symmetries.\nhaegeman2011 introduced TDVP, again explained more accessible in haegeman2016.\nzaletel2015 is another standard method for time-evolution with long-range Hamiltonians.\nkarrasch2013 gives some tricks to do finite-temperature simulations (DMRG), which is a bit extended in hauschild2018a.\nvidal2007 introduced MERA.\nThe scaling :math:`S=c/6 log(\\chi)` at a 1D critical point is explained in pollmann2009.\nvanderstraeten2019 gives a very good introductin to infinite, uniform MPS.\n\n\nReferences\n----------\n\n    :style: custom1\n    :all:\n\n\nPhD theses\n----------\nFor inspiration, we also (somewhat randomly) list a few PhD theses related to tensor networks (accessible online) - they\noften provide a very good introduction to some specific topic.\n\n    :all:\n    :style: custom2",
    "search_text": "doc.literature --- documentation: literature ---\nliterature and references\n=========================\n\nthis is a (by far non-exhaustive) list of some references for the various ideas behind the code.\nthey can be cited like this:\n\n- [tenpynotes]_ for tenpy/software related sources\n- white1992 (lowercase first-author + year) for entries from `literature.bib`.\n\n.. comment\n    when you add something, please also add a reference to it, i.e., give a short comment in the top of the subsection.\n\ntenpy related sources\n---------------------\n[tenpynotes]_ are lecture notes, meant as an introduction to tensor networks (focusing on mps), and introduced tenpy to\nthe scientific community by giving examples how to call the algorithms in tenpy.\n[tenpysource]_ is the location of the source code, and the place where you can report bugs.\nwe have split example notebooks into [tenpynotebooks]_ to keep the git history of the original repository clean.\n[tenpydoc]_ is where the documentation is hosted online.\n[tenpyforum]_ is the place where you can ask questions and look for help when you are stuck with implementing something.\n\n.. [tenpynotes]\n    \"efficient numerical simulations with tensor networks: tensor network python (tenpy)\"\n    j. hauschild, f. pollmann, scipost phys. lect. notes 5 (2018), 1805.00055, :doi:`10.21468/scipostphyslectnotes.5`\n    also below as hauschild2018a.\n.. [tenpysource]\n    https://github.com/tenpy/tenpy\n.. [tenpytoycodes]\n    collection of very simple toy code python scripts and tutorial notebooks at https://github.com/tenpy/tenpy_notbooks.\n    included in the documentation under :doc:`/examples`\n.. [tenpynotebooks]\n    collection of example [jupyter]_ notebooks using tenpy: https://github.com/tenpy/tenpy_notebooks\n.. [tenpydoc]\n    online documentation, https://tenpy.readthedocs.io/\n.. [tenpyforum]\n    community forum for discussions, faq and announcements, https://tenpy.johannes-hauschild.de\n.. [tenpyprojecttemplate]\n    template git repository for custom projects with a simplified setup for running many simulations on a cluster,\n    https://github.com/tenpy/project_template\n\nsoftware-related\n----------------\nthe following links are not physics-related, but are good to know if you want to work with tenpy (or more generally python).\n\n.. [git]\n    \"git version control system\", https://git-scm.com\n    a software which we use to keep track of changes in the source code.\n\n.. [conda]\n    \"conda package manger\", https://docs.conda.io/en/latest/\n    a package and environment management system that allows to easily install (multiple version of) various software,\n    and in particular python packages like tenpy.\n\n.. [pip]\n    \"pip - the python package installer\", https://pip.pypa.io/en/stable/\n    traditional way to handle installed python packages with ``pip install ...`` and ``pip uninstall ...`` on the command line.\n\n.. [matplotlib]\n    \"matplotlib\", https://matplotlib.org/\n    a python 2d plotting library. some tenpy functions expect matplotlib.axes.axes as arguments to plot into.\n\n.. [hdf5]\n    \"hierarchical data format 5 (r)\", https://portal.hdfgroup.org/display/hdf5/hdf5\n    a file format and library for saving data (including metadata).\n    we use it through the python interface of the `h5py <https://docs.h5py.org/en/stable/>`_ library,\n    see :doc:`/intro/input_output`.\n\n.. [yaml]\n    \"yaml ain't markup language\", https://yaml.org\n    a human-readable file format for configuration files.\n    tenpy (optionally) uses it through `pyyaml <https://pyyaml.org/>`_ for reading in simulation parameters, and in some\n    places in the documentation to keep things more readable.\n\n.. [jupyter]\n    jupyter notebooks, https://jupyter.org/\n    an amazing interface for (python) notebooks which can contain both source code, text and outputs in a single file.\n    they provide a good way to get started with python, we use them for examples.\n\ngeneral reading\n---------------\nschollwoeck2011 is an extensive introduction to mps, dmrg and tebd with lots of details on the implementations, and a classic read, although a bit lengthy.\nour [tenpynotes]_ are a shorter summary of the important concepts, similar as orus2014.\npaeckel2019 is a very good, recent review focusing on time evolution with mps.\nthe lecture notes of eisert2013 explain the area law as motivation for tensor networks very well.\npeps are for example reviewed in verstraete2008, eisert2013 and orus2014.\ncirac2020 is a recent, broad review of mps and mps with a focus on analytical theorems.\nstoudenmire2012 reviews the use of dmrg for 2d systems.\ncirac2009 discusses the different groups of tensor network states.\nvanderstraeten2019 is a great review on tangent space methods for infinite, uniform mps.\n\n\nalgorithm developments\n----------------------\n:cite:`white1992,white1993` is the invention of dmrg, which started everything.\nvidal2004 introduced tebd.\nwhite2005 and hubig2015 solved problems for single-site dmrg.\nmcculloch2008 was a huge step forward to solve convergence problems for infinite dmrg.\n:cite:`singh2010,singh2011` explain how to incorporate symmetries.\nhaegeman2011 introduced tdvp, again explained more accessible in haegeman2016.\nzaletel2015 is another standard method for time-evolution with long-range hamiltonians.\nkarrasch2013 gives some tricks to do finite-temperature simulations (dmrg), which is a bit extended in hauschild2018a.\nvidal2007 introduced mera.\nthe scaling :math:`s=c/6 log(\\chi)` at a 1d critical point is explained in pollmann2009.\nvanderstraeten2019 gives a very good introductin to infinite, uniform mps.\n\n\nreferences\n----------\n\n    :style: custom1\n    :all:\n\n\nphd theses\n----------\nfor inspiration, we also (somewhat randomly) list a few phd theses related to tensor networks (accessible online) - they\noften provide a very good introduction to some specific topic.\n\n    :all:\n    :style: custom2 tutorial documentation literature",
    "tokens": 1447
  },
  {
    "category": "tutorials",
    "name": "doc.troubleshooting",
    "content": "--- DOCUMENTATION: troubleshooting ---\nTroubleshooting and FAQ\n=======================\n\nI updated to a new version and now I get an error/warning.\n    Take a look at the section \"Backwards incompatible changes\" in the :doc:`/releases` of the corresponding versions\n    since when you updated.\n\nWhere did all the output go?\n    Take a look at :doc:`/intro/logging`.\n\nWhat are possible parameters for ...?\n    See :doc:`/intro/options`.\n\nHow can I set the number of threads TeNPy is using?\n    Most algorithms in TeNPy don't use any parallelization besides what the underlying BLAS provides,\n    so that depends on how you installed TeNPy, numpy and scipy!\n    Using for example an ``export OMP_NUM_THREADS=4`` should limit it to 4 threads under usual setups,\n    but you might also want to ``export MKL_NUM_THREADS=4`` instead, if you are sure that you are using MKL.\n\nWhy is TeNPy not respecting MKL_NUM_THREADS?\n    It might be that it is not using MKL.\n    On linux, check whether you have installed a pip version of numpy or scipy in $HOME/.local/lib/python3.*\n    Those packages do not use MKL - you would need to install numpy and scipy from conda.\n    If you use the `conda-forge` channel as recommended in the installation, also make sure that you select\n    the BLAS provided by MKL, see the note in :doc:`/install/conda`.\n\nHow can I double check the installed TeNPy version?\n    You can call tenpy.show_config to print details about the installed tenpy version.\n    If you have multiple TeNPy/Python versions on your computer,\n    just calling ``print(tenpy)`` after an ``import tenpy`` will print the path of the used tenpy and can thus help\n    you identify which of the TeNPy installations you use.\n\n\nI get an error when ...\n-----------------------\n... I try to measure ``Sx_i Sx_j`` correlations in a state with `Sz` conservation.\n    Right now this is not possible. See the basic facts in :doc:`/intro/npc`.\n\n\nI get a warning about ...\n-------------------------\n... an unused parameter.\n    Make sure that you don't have a typo and that it is in the right parameter set!\n    Also, check the logging output whether the parameter was actually used.\n    For further details, see :doc:`/intro/options`\n\n... the overlap of infinite MPS not being what I expect naively.\n    See iMPSWarning.",
    "search_text": "doc.troubleshooting --- documentation: troubleshooting ---\ntroubleshooting and faq\n=======================\n\ni updated to a new version and now i get an error/warning.\n    take a look at the section \"backwards incompatible changes\" in the :doc:`/releases` of the corresponding versions\n    since when you updated.\n\nwhere did all the output go?\n    take a look at :doc:`/intro/logging`.\n\nwhat are possible parameters for ...?\n    see :doc:`/intro/options`.\n\nhow can i set the number of threads tenpy is using?\n    most algorithms in tenpy don't use any parallelization besides what the underlying blas provides,\n    so that depends on how you installed tenpy, numpy and scipy!\n    using for example an ``export omp_num_threads=4`` should limit it to 4 threads under usual setups,\n    but you might also want to ``export mkl_num_threads=4`` instead, if you are sure that you are using mkl.\n\nwhy is tenpy not respecting mkl_num_threads?\n    it might be that it is not using mkl.\n    on linux, check whether you have installed a pip version of numpy or scipy in $home/.local/lib/python3.*\n    those packages do not use mkl - you would need to install numpy and scipy from conda.\n    if you use the `conda-forge` channel as recommended in the installation, also make sure that you select\n    the blas provided by mkl, see the note in :doc:`/install/conda`.\n\nhow can i double check the installed tenpy version?\n    you can call tenpy.show_config to print details about the installed tenpy version.\n    if you have multiple tenpy/python versions on your computer,\n    just calling ``print(tenpy)`` after an ``import tenpy`` will print the path of the used tenpy and can thus help\n    you identify which of the tenpy installations you use.\n\n\ni get an error when ...\n-----------------------\n... i try to measure ``sx_i sx_j`` correlations in a state with `sz` conservation.\n    right now this is not possible. see the basic facts in :doc:`/intro/npc`.\n\n\ni get a warning about ...\n-------------------------\n... an unused parameter.\n    make sure that you don't have a typo and that it is in the right parameter set!\n    also, check the logging output whether the parameter was actually used.\n    for further details, see :doc:`/intro/options`\n\n... the overlap of infinite mps not being what i expect naively.\n    see impswarning. tutorial documentation troubleshooting",
    "tokens": 541
  },
  {
    "category": "tutorials",
    "name": "doc.introductions",
    "content": "--- DOCUMENTATION: introductions ---\nIntroductions\n=============\n\nThe following documents are meant as introductions to various topics relevant to TeNPy.\n\nIf you are new to TeNPy, read the :doc:`intro/overview`.\n\n    :maxdepth: 1\n\n    intro/overview\n    intro/simulations\n    intro/model\n    intro/model_details\n    intro/lattices\n    intro/input_output\n    intro/logging\n    intro/options\n    intro/measurements\n    intro/npc\n    intro/JordanWigner\n    intro/dmrg-protocol",
    "search_text": "doc.introductions --- documentation: introductions ---\nintroductions\n=============\n\nthe following documents are meant as introductions to various topics relevant to tenpy.\n\nif you are new to tenpy, read the :doc:`intro/overview`.\n\n    :maxdepth: 1\n\n    intro/overview\n    intro/simulations\n    intro/model\n    intro/model_details\n    intro/lattices\n    intro/input_output\n    intro/logging\n    intro/options\n    intro/measurements\n    intro/npc\n    intro/jordanwigner\n    intro/dmrg-protocol tutorial documentation introductions",
    "tokens": 120
  },
  {
    "category": "tutorials",
    "name": "doc.main",
    "content": "--- DOCUMENTATION: main ---\nTenpy main module\n=================\n\n- full name: tenpy\n- parent module: tenpy\n- type: module\n\n\n\n    algorithms\n    linalg\n    models\n    networks\n    tools\n    version\n\n    :show-inheritance:\n\n\n    :toctree: reference\n\n    run_simulation\n    resume_from_checkpoint\n    run_seq_simulations\n    console_main\n    show_config\n\n",
    "search_text": "doc.main --- documentation: main ---\ntenpy main module\n=================\n\n- full name: tenpy\n- parent module: tenpy\n- type: module\n\n\n\n    algorithms\n    linalg\n    models\n    networks\n    tools\n    version\n\n    :show-inheritance:\n\n\n    :toctree: reference\n\n    run_simulation\n    resume_from_checkpoint\n    run_seq_simulations\n    console_main\n    show_config\n\n tutorial documentation main",
    "tokens": 88
  },
  {
    "category": "tutorials",
    "name": "doc.papers_using_tenpy",
    "content": "--- DOCUMENTATION: papers_using_tenpy ---\nPapers using TeNPy\n==================\n\nThis page collects papers using (and citing) the TeNPy library, both as an inspiration what can be done, as well as to keep\ntrack of the usage, such that we can see how useful our work is to the community. It keeps us motivated!\n\nTo include your own work, you can either\nfill out `this template on github <https://github.com/tenpy/tenpy/issues/new?&labels=doc&template=paper-using-tenpy.md&title=[cite]>`_,\nor you can directly add your citation in `this Zotero online library <https://www.zotero.org/groups/2569413/tenpy/items>`_ (and notify us about it or just wait).\n\nEntries in the following list are sorted by year-author.\n\n    :list: enumerated\n    :all:\n    :style: custom2",
    "search_text": "doc.papers_using_tenpy --- documentation: papers_using_tenpy ---\npapers using tenpy\n==================\n\nthis page collects papers using (and citing) the tenpy library, both as an inspiration what can be done, as well as to keep\ntrack of the usage, such that we can see how useful our work is to the community. it keeps us motivated!\n\nto include your own work, you can either\nfill out `this template on github <https://github.com/tenpy/tenpy/issues/new?&labels=doc&template=paper-using-tenpy.md&title=[cite]>`_,\nor you can directly add your citation in `this zotero online library <https://www.zotero.org/groups/2569413/tenpy/items>`_ (and notify us about it or just wait).\n\nentries in the following list are sorted by year-author.\n\n    :list: enumerated\n    :all:\n    :style: custom2 tutorial documentation papers_using_tenpy",
    "tokens": 194
  },
  {
    "category": "tutorials",
    "name": "doc.lattices",
    "content": "--- DOCUMENTATION: lattices ---\nDetails on the lattice geometry\n===============================\n\nThe tenpy.models.lattice.Lattice class defines the geometry of the system.\nIn the basic form, it represents a unit cell of a few sites repeated in one or multiple directions.\nMoreover, it maps this higher-dimensional geometry to a one-dimensional chain for MPS-based algorithms.\n\nVisualization\n-------------\n\nA plot of the lattice can greatly help to understand which sites are connected by what couplings.\nThe methods ``plot_*`` of the tenpy.models.lattice.Lattice can do a good job for a quick illustration.\nLet's look at the Honeycomb lattice as an example.\n\n    :include-source:\n\n    import matplotlib.pyplot as plt\n    from tenpy.models import lattice\n\n    plt.figure(figsize=(5, 6))\n    ax = plt.gca()\n    lat = lattice.Honeycomb(Lx=4, Ly=4, sites=None, bc='periodic')\n    lat.plot_coupling(ax)\n    lat.plot_order(ax, linestyle=':')\n    lat.plot_sites(ax)\n    lat.plot_basis(ax, origin=-0.5*(lat.basis[0] + lat.basis[1]))\n    ax.set_aspect('equal')\n    ax.set_xlim(-1)\n    ax.set_ylim(-1)\n    plt.show()\n\nIn this case, the unit cell (shaded green) consists of two sites, which for the purpose of plotting we just set to ``sites=None``;\nin general you should specify instances of tenpy.networks.site.Site for that.\nThe unit cell gets repeated in the directions given by the lattice basis (green arrows at the unit cell boundary).\nHence, we can label each site by a **lattice index** ``(x, y, u)`` in this case, where ``x in range(Lx), y in range(Ly)`` specify the translation of the unit cell\nand ``u in range(len(unit_cell))``, here ``u in [0, 1]``, specifies the index within the unit cell.\n\nHow an MPS winds through the lattice: the `order`\n-------------------------------------------------\n\nFor MPS-based algorithms, we need to map a 2D lattice like the one above to a 1D chain.\nThe red, dashed line in the plot indicates how an MPS winds through the 2D\nlattice. The **MPS index** `i` is a simple enumeration of the sites along this line, shown as numbers next to the sites\nin the plot.\nThe methods tenpy.models.lattice.Lattice.mps2lat_idx and tenpy.models.lattice.Lattice.lat2mps_idx map\nindices of the MPS to and from indices of the lattice.\n\nThe tenpy.networks.mps.MPS class itself is (mostly) agnostic of the underlying geometry.\nFor example, tenpy.networks.mps.MPS.expectation_value will return a 1D array of the expectation value on each\nsite indexed by the MPS index `i`.\nIf you have a two-dimensional lattice, you can use tenpy.models.lattice.Lattice.mps2lat_values to map this result to a 2D array index by the lattice indices.\n\nA suitable order is critical for the efficiency of MPS-based algorithms.\nOn one hand, different orderings can lead to different MPO bond-dimensions, with direct impact on the complexity scaling.\nOn the other hand, it influences how much entanglement needs to go through each bonds of the underlying MPS,\ne.g., the ground state to be found in DMRG, and therefore influences the required MPS bond dimensions.\nFor the latter reason, the \"optimal\" ordering can not be known a priori and might even depend on your coupling\nparameters (and the phase you are in).\nIn the end, you can just try different orderings and see which one works best.\n\nThe simplest way to *change* the order is to use a non-default value for the initialization parameter `order` of the\ntenpy.models.lattice.Lattice class. This gets passed on to tenpy.models.lattice.Lattice.ordering,\nwhich you can override by creating a custom lattice class to define new possible orderings.\nAlternatively, you can go the most general way and simply set the attribute `order` to be a 2D numpy array with\nlattice indices as rows, in the order you want.\n\n    :include-source:\n\n    import matplotlib.pyplot as plt\n    from tenpy.models import lattice\n\n    Lx, Ly = 3, 3\n    fig, axes = plt.subplots(2, 2, figsize=(7, 8))\n\n    lat1 = lattice.Honeycomb(Lx, Ly, sites=None, bc='periodic')  # default order\n    lat2 = lattice.Honeycomb(Lx, Ly, sites=None, bc='periodic',\n                            order=\"Cstyle\")  # first method to change order\n    # alternative: directly set \"Cstyle\" order\n    lat3 = lattice.Honeycomb(Lx, Ly, sites=None, bc='periodic')\n    lat3.order = lat2.ordering(\"Cstyle\")  # now equivalent to lat2\n\n    # general: can apply arbitrary permutation to the order\n    lat4 = lattice.Honeycomb(Lx, Ly, sites=None, bc='periodic',\n                            order=\"Cstyle\")\n    old_order = lat4.order\n    permutation = []\n    for i in range(0, len(old_order), 2):\n        permutation.append(i+1)\n        permutation.append(i)\n    lat4.order = old_order[permutation, :]\n\n    for lat, label, ax in zip([lat1, lat2, lat3, lat4],\n                              [\"order='default'\",\n                               \"order='Cstyle'\",\n                               \"order='Cstyle'\",\n                               \"custom permutation\"],\n                              axes.flatten()):\n        lat.plot_coupling(ax)\n        lat.plot_sites(ax)\n        lat.plot_order(ax, linestyle=':', linewidth=2.)\n        ax.set_aspect('equal')\n        ax.set_title('order = ' + repr(label))\n\n    plt.show()\n\n\nBoundary conditions\n-------------------\n\nThe tenpy.models.lattice.Lattice defines the **boundary conditions** `bc` in each direction.\nIt can be one of the usual ``'open'`` or ``'periodic'`` in each direction and will be used by the\ntenpy.models.model.CouplingModel to determine whether there should be added periodic couplings in the\ncorresponding directions.\n\nOn top of that, there is the `bc_MPS` boundary condition of the MPS, one of ``'finite', 'segment', 'infinite'``.\nFor an ``'infinite'`` MPS, the whole lattice is repeated in the direction of the *first* basis vector of the lattice.\nFor ``bc_MPS='infinite'``, the first direction should always be ``'periodic'``, but you *can* also define a lattice with\n``bc_MPS='finite', bc=['periodic', 'periodic']`` for a finite system on the torus.\nThis is discouraged, though, because the ground state MPS will require the *squared* bond dimension for the *same precision* in this\ncase!\n\nFor two (or higher) dimensional lattices, e.g for DMRG on an infinite cylinder,\nyou can also specify an integer `shift` instead of just saying ``'periodic'``.\nRolling the 2D lattice up into a cylinder, you have a degree of freedom about which sites to connect.\nThis is illustrated in the figure below for a tenpy.models.lattice.Square lattice with ``bc=['periodic', shift]``\nfor ``shift in [-1, 0, 1]`` (different columns).\nIn the first row, the orange markers indicate a pair of identified sites (see tenpy.models.lattice.Lattice.plot_bc_shift).\nThe dashed orange line indicates the direction of the cylinder axis.\nThe line where the cylinder is \"cut open\" therefore winds around the the cylinder for a non-zero `shift`.\n(A similar thing happens even for shift=0 for more complicated lattices with non-orthogonal basis.)\nIn the second row, we directly draw lines between all sites connected by nearest-neighbor couplings, as they appear in the MPO.\n\n\n    import matplotlib.pyplot as plt\n    from tenpy.models import lattice\n\n    Lx, Ly = 4, 3\n    fig, axes = plt.subplots(2, 3, sharex=True, sharey=True, figsize=(7, 4))\n\n    for i, shift in enumerate([1, 0, -1]):\n        ax1, ax2 = axes[:, i]\n        lat = lattice.Square(Lx, Ly, None, bc=['periodic', shift], bc_MPS='infinite')\n        for ax in ax1, ax2:\n            lat.plot_sites(ax)\n            ax.set_aspect('equal')\n            ax.set_ylim(-1, 4)\n        lat.plot_coupling(ax1)\n        lat.plot_bc_identified(ax1, cylinder_axis=True)\n        lat.plot_coupling(ax2, wrap=True)\n        ax1.set_title('shift = ' + str(shift))\n        ax.set_xlim(-1.5)\n\n    plt.show()\n\n\nIrregular Lattices\n------------------\nThe tenpy.models.lattice.IrregularLattice allows you to add or remove sites from/to an existing regular lattice.\nThe doc-string of tenpy.models.lattice.IrregularLattice contains several examples. Let us consider another one\nhere, where we use the IrregularLattice to \"fix\" the boundary of the Honeycomb lattice.\nWhen we use ``\"open\"`` boundary conditions for a finite system, there are two sites (shown on the lower left, and upper right corners of the figure below),\nwhich are not included into any hexagonal. The following example shows how to remove them from the system:\n\n    :include-source:\n\n    import matplotlib.pyplot as plt\n    from tenpy.models import lattice\n\n    Lx, Ly = 3, 3\n    fig, axes = plt.subplots(1, 2, sharex=True, sharey=True, figsize=(6, 4))\n\n    reg_lat = lattice.Honeycomb(Lx=Lx, Ly=Ly, sites=None, bc='open')\n    irr_lat = lattice.IrregularLattice(reg_lat, remove=[[0, 0, 0], [-1, -1, 1]])\n    for lat, label, ax in zip([reg_lat, irr_lat],\n                              [\"regular\", \"irregular\"],\n                              axes.flatten()):\n        lat.plot_coupling(ax)\n        lat.plot_order(ax, linestyle=':')\n        lat.plot_sites(ax)\n        ax.set_aspect('equal')\n        ax.set_title(label)\n\n    plt.show()",
    "search_text": "doc.lattices --- documentation: lattices ---\ndetails on the lattice geometry\n===============================\n\nthe tenpy.models.lattice.lattice class defines the geometry of the system.\nin the basic form, it represents a unit cell of a few sites repeated in one or multiple directions.\nmoreover, it maps this higher-dimensional geometry to a one-dimensional chain for mps-based algorithms.\n\nvisualization\n-------------\n\na plot of the lattice can greatly help to understand which sites are connected by what couplings.\nthe methods ``plot_*`` of the tenpy.models.lattice.lattice can do a good job for a quick illustration.\nlet's look at the honeycomb lattice as an example.\n\n    :include-source:\n\n    import matplotlib.pyplot as plt\n    from tenpy.models import lattice\n\n    plt.figure(figsize=(5, 6))\n    ax = plt.gca()\n    lat = lattice.honeycomb(lx=4, ly=4, sites=none, bc='periodic')\n    lat.plot_coupling(ax)\n    lat.plot_order(ax, linestyle=':')\n    lat.plot_sites(ax)\n    lat.plot_basis(ax, origin=-0.5*(lat.basis[0] + lat.basis[1]))\n    ax.set_aspect('equal')\n    ax.set_xlim(-1)\n    ax.set_ylim(-1)\n    plt.show()\n\nin this case, the unit cell (shaded green) consists of two sites, which for the purpose of plotting we just set to ``sites=none``;\nin general you should specify instances of tenpy.networks.site.site for that.\nthe unit cell gets repeated in the directions given by the lattice basis (green arrows at the unit cell boundary).\nhence, we can label each site by a **lattice index** ``(x, y, u)`` in this case, where ``x in range(lx), y in range(ly)`` specify the translation of the unit cell\nand ``u in range(len(unit_cell))``, here ``u in [0, 1]``, specifies the index within the unit cell.\n\nhow an mps winds through the lattice: the `order`\n-------------------------------------------------\n\nfor mps-based algorithms, we need to map a 2d lattice like the one above to a 1d chain.\nthe red, dashed line in the plot indicates how an mps winds through the 2d\nlattice. the **mps index** `i` is a simple enumeration of the sites along this line, shown as numbers next to the sites\nin the plot.\nthe methods tenpy.models.lattice.lattice.mps2lat_idx and tenpy.models.lattice.lattice.lat2mps_idx map\nindices of the mps to and from indices of the lattice.\n\nthe tenpy.networks.mps.mps class itself is (mostly) agnostic of the underlying geometry.\nfor example, tenpy.networks.mps.mps.expectation_value will return a 1d array of the expectation value on each\nsite indexed by the mps index `i`.\nif you have a two-dimensional lattice, you can use tenpy.models.lattice.lattice.mps2lat_values to map this result to a 2d array index by the lattice indices.\n\na suitable order is critical for the efficiency of mps-based algorithms.\non one hand, different orderings can lead to different mpo bond-dimensions, with direct impact on the complexity scaling.\non the other hand, it influences how much entanglement needs to go through each bonds of the underlying mps,\ne.g., the ground state to be found in dmrg, and therefore influences the required mps bond dimensions.\nfor the latter reason, the \"optimal\" ordering can not be known a priori and might even depend on your coupling\nparameters (and the phase you are in).\nin the end, you can just try different orderings and see which one works best.\n\nthe simplest way to *change* the order is to use a non-default value for the initialization parameter `order` of the\ntenpy.models.lattice.lattice class. this gets passed on to tenpy.models.lattice.lattice.ordering,\nwhich you can override by creating a custom lattice class to define new possible orderings.\nalternatively, you can go the most general way and simply set the attribute `order` to be a 2d numpy array with\nlattice indices as rows, in the order you want.\n\n    :include-source:\n\n    import matplotlib.pyplot as plt\n    from tenpy.models import lattice\n\n    lx, ly = 3, 3\n    fig, axes = plt.subplots(2, 2, figsize=(7, 8))\n\n    lat1 = lattice.honeycomb(lx, ly, sites=none, bc='periodic')  # default order\n    lat2 = lattice.honeycomb(lx, ly, sites=none, bc='periodic',\n                            order=\"cstyle\")  # first method to change order\n    # alternative: directly set \"cstyle\" order\n    lat3 = lattice.honeycomb(lx, ly, sites=none, bc='periodic')\n    lat3.order = lat2.ordering(\"cstyle\")  # now equivalent to lat2\n\n    # general: can apply arbitrary permutation to the order\n    lat4 = lattice.honeycomb(lx, ly, sites=none, bc='periodic',\n                            order=\"cstyle\")\n    old_order = lat4.order\n    permutation = []\n    for i in range(0, len(old_order), 2):\n        permutation.append(i+1)\n        permutation.append(i)\n    lat4.order = old_order[permutation, :]\n\n    for lat, label, ax in zip([lat1, lat2, lat3, lat4],\n                              [\"order='default'\",\n                               \"order='cstyle'\",\n                               \"order='cstyle'\",\n                               \"custom permutation\"],\n                              axes.flatten()):\n        lat.plot_coupling(ax)\n        lat.plot_sites(ax)\n        lat.plot_order(ax, linestyle=':', linewidth=2.)\n        ax.set_aspect('equal')\n        ax.set_title('order = ' + repr(label))\n\n    plt.show()\n\n\nboundary conditions\n-------------------\n\nthe tenpy.models.lattice.lattice defines the **boundary conditions** `bc` in each direction.\nit can be one of the usual ``'open'`` or ``'periodic'`` in each direction and will be used by the\ntenpy.models.model.couplingmodel to determine whether there should be added periodic couplings in the\ncorresponding directions.\n\non top of that, there is the `bc_mps` boundary condition of the mps, one of ``'finite', 'segment', 'infinite'``.\nfor an ``'infinite'`` mps, the whole lattice is repeated in the direction of the *first* basis vector of the lattice.\nfor ``bc_mps='infinite'``, the first direction should always be ``'periodic'``, but you *can* also define a lattice with\n``bc_mps='finite', bc=['periodic', 'periodic']`` for a finite system on the torus.\nthis is discouraged, though, because the ground state mps will require the *squared* bond dimension for the *same precision* in this\ncase!\n\nfor two (or higher) dimensional lattices, e.g for dmrg on an infinite cylinder,\nyou can also specify an integer `shift` instead of just saying ``'periodic'``.\nrolling the 2d lattice up into a cylinder, you have a degree of freedom about which sites to connect.\nthis is illustrated in the figure below for a tenpy.models.lattice.square lattice with ``bc=['periodic', shift]``\nfor ``shift in [-1, 0, 1]`` (different columns).\nin the first row, the orange markers indicate a pair of identified sites (see tenpy.models.lattice.lattice.plot_bc_shift).\nthe dashed orange line indicates the direction of the cylinder axis.\nthe line where the cylinder is \"cut open\" therefore winds around the the cylinder for a non-zero `shift`.\n(a similar thing happens even for shift=0 for more complicated lattices with non-orthogonal basis.)\nin the second row, we directly draw lines between all sites connected by nearest-neighbor couplings, as they appear in the mpo.\n\n\n    import matplotlib.pyplot as plt\n    from tenpy.models import lattice\n\n    lx, ly = 4, 3\n    fig, axes = plt.subplots(2, 3, sharex=true, sharey=true, figsize=(7, 4))\n\n    for i, shift in enumerate([1, 0, -1]):\n        ax1, ax2 = axes[:, i]\n        lat = lattice.square(lx, ly, none, bc=['periodic', shift], bc_mps='infinite')\n        for ax in ax1, ax2:\n            lat.plot_sites(ax)\n            ax.set_aspect('equal')\n            ax.set_ylim(-1, 4)\n        lat.plot_coupling(ax1)\n        lat.plot_bc_identified(ax1, cylinder_axis=true)\n        lat.plot_coupling(ax2, wrap=true)\n        ax1.set_title('shift = ' + str(shift))\n        ax.set_xlim(-1.5)\n\n    plt.show()\n\n\nirregular lattices\n------------------\nthe tenpy.models.lattice.irregularlattice allows you to add or remove sites from/to an existing regular lattice.\nthe doc-string of tenpy.models.lattice.irregularlattice contains several examples. let us consider another one\nhere, where we use the irregularlattice to \"fix\" the boundary of the honeycomb lattice.\nwhen we use ``\"open\"`` boundary conditions for a finite system, there are two sites (shown on the lower left, and upper right corners of the figure below),\nwhich are not included into any hexagonal. the following example shows how to remove them from the system:\n\n    :include-source:\n\n    import matplotlib.pyplot as plt\n    from tenpy.models import lattice\n\n    lx, ly = 3, 3\n    fig, axes = plt.subplots(1, 2, sharex=true, sharey=true, figsize=(6, 4))\n\n    reg_lat = lattice.honeycomb(lx=lx, ly=ly, sites=none, bc='open')\n    irr_lat = lattice.irregularlattice(reg_lat, remove=[[0, 0, 0], [-1, -1, 1]])\n    for lat, label, ax in zip([reg_lat, irr_lat],\n                              [\"regular\", \"irregular\"],\n                              axes.flatten()):\n        lat.plot_coupling(ax)\n        lat.plot_order(ax, linestyle=':')\n        lat.plot_sites(ax)\n        ax.set_aspect('equal')\n        ax.set_title(label)\n\n    plt.show() tutorial documentation lattices",
    "tokens": 2221
  },
  {
    "category": "tutorials",
    "name": "doc.dmrg-protocol",
    "content": "--- DOCUMENTATION: dmrg-protocol ---\nProtocol for using (i)DMRG\n==========================\n\nWhile this documentation contains extensive guidance on how to interact with the tenpy, it is often unclear how to approach a physics question using these methods.\nThis page is an attempt to provide such guidance, describing a protocol on how to go from a model implementation to an answered question.\n\nThe basic workflow for an (i)DMRG project is as follows, with individual steps expanded on later where necessary.\n\n1. Confirm the correctness of the model implementation.\n2. Run some low-effort tests to see whether the question seems answerable.\n3. If the tests are successful, run production-quality simulations.\n   This will be entirely particular to the project you're working on.\n4. Confirm that your results are converged.\n\nConfirming the model is correct\n-------------------------------\n\nAlthough TeNPy makes model implementation much easier than constructing the MPO by hand, one should still ensure that the MPO represents the intended model faithfully.\nThere are several possible ways to do this. Firstly, for sufficiently small system sizes, one can contract the entire MPO into a matrix, and inspect the matrix elements. In TeNPy, this can be done using tenpy.networks.mpo.MPO.get_full_hamiltonian. These should reproduce the analytical Hamiltonian up to machine precision, or any other necessary cut-off (e.g., long-range interactions may be truncated at some finite distance).\n\nSecondly, if the model basis allows it, one can construct (product state) MPSs for known eigenstates of the model and evaluate whether these reproduce the correct eigenvalues upon contraction with the MPO.\n\nFinally, one can sometimes construct a basis of single- or even two-particle MPSs in some basis, and evaluate the MPO on this basis to get a representation of the single- and two-particle Hamiltonian.\nIf the model contains only single- and two-body terms, this latter approach should reproduce all terms in the Hamiltonian.\n\nLow-effort tests\n----------------\nAs not every state can be accurately represented by an MPS, some results are outside the reach of (i)DMRG.\nTo prevent wasting considerable numerical resources on a fruitless project, it is recommended to run some low-effort trials first, and see whether any indication of the desired result can be found.\nIf so, one can then go on to more computationally expensive simulations.\nIf not, one should evaluate:\n\n1. Whether there is a mistake in the model or simulation set-up,\n2. Whether a slightly more computationally expensive test would potentially yield a result, or\n3. Whether your approach is unfortunately out of reach of (i)DMRG.\n\nTo set up low-effort trials, one should limit system size, bond dimension and the range of interactions, as well as (if possible) target a non-critical region of phase space.\nAll these measures reduce the size of and/or entanglement entropy needing to be captured by the MPS, which yields both memory and run time advantages.\nOf course, one introduces a trade-off between computational cost and accuracy, which is why one should be careful to not put too much faith into results obtained at this stage.\n\nDetecting convergence issues\n----------------------------\n\nEnsuring that the results of an (i)DMRG simulation are well-converged and thus reliable is a hugely important part of any (i)DMRG study.\nPossible indications that there might be a convergence issue include:\n\n1. The simulation shows a non-monotonous decrease of energy, and/or a non-monotonous increase of entanglement entropy. An increase of energy or decrease of entanglement entropy on subsequent steps within a sweep, or between subsequent sweeps, are particularly suspicious.\n2. The simulation does not halt because it reached a convergence criterion, but because it reached its maximum number of sweeps.\n3. Results vary wildly under small changes of parameters. In particular, if a small change in bond dimension yields a big change in results, one should be suspicious of the data.\n\nCombating convergence issues\n----------------------------\n\nTo combat convergence issues of the (i)DMRG algorithm, several strategies (short of switching to a different method) can be attempted:\n\n1. Ensure that there are no errors in the model (see above) or the simulation set-up.\n2. Increase the maximum bond dimension.\n3. Ramp up the maximum bond dimension during simulation, rather than starting at the highest value. I.e., define a schedule wherein the first :math:`N_{\\mathrm{sweeps}}` sweeps run at some :math:`\\chi_1 < \\chi_\\mathrm{max}`, the next :math:`N_{\\mathrm{sweeps}}` at :math:`\\chi_1 < \\chi_2 < \\chi_{\\mathrm{max}}`, etc.\n   This can be done through the ``chi_list`` option of the tenpy.algorithms.dmrg.DMRGEngine.\n   You should also make sure that the ``max_hours`` option is set to sufficiently long runtimes.\n4. Increase the maximum number of sweeps the algorithm is allowed to make, through the ``max_sweeps`` option of the tenpy.algorithms.dmrg.DMRGEngine.\n5. Change the tenpy.algorithms.dmrg.Mixer settings to in- or decrease the effects of the mixer.\n6. Change convergence criteria. This will not overcome convergence issues in itself, but can help fine tune the (i)DMRG simulation if it takes a long time to converge (relax the convergence constraints), or if the simulation finishes too soon (tighten the constraints).\n   Criteria to consider are ``max_E_err`` and ``max_S_err``, in tenpy.algorithms.dmrg.DMRGEngine.\n7. Increase the minimum number of sweeps taken by the algorithm. Again, this will not resolve issues due to bad convergence, but might prevent bad results due to premature convergence.\n   This can be done through the ``min_sweeps`` option of the tenpy.algorithms.dmrg.DMRGEngine.\n8. Change the size and shape of the MPS unit cell (where possible), in case an artificially enforced translational invariance prevents the algorithm from finding a true ground state which is incommensurate with this periodicity.\n   For example, a chain system which has a true ground state that is periodic in three sites, will not be accurately represented by a two-site MPS unit cell, as the latter enforces two-site periodicity.\n\n\nIn some instances, it is essentially unavoidable to encounter convergence issues.\nIn particular, a simulation of a critical state can cause problems with (i)DMRG convergence, as these states violate the area law underlying an accurate MPS approximation.\nIn these cases, one should acknowledge the difficulties imposed by the method and take care to be very careful in interpreting the data.",
    "search_text": "doc.dmrg-protocol --- documentation: dmrg-protocol ---\nprotocol for using (i)dmrg\n==========================\n\nwhile this documentation contains extensive guidance on how to interact with the tenpy, it is often unclear how to approach a physics question using these methods.\nthis page is an attempt to provide such guidance, describing a protocol on how to go from a model implementation to an answered question.\n\nthe basic workflow for an (i)dmrg project is as follows, with individual steps expanded on later where necessary.\n\n1. confirm the correctness of the model implementation.\n2. run some low-effort tests to see whether the question seems answerable.\n3. if the tests are successful, run production-quality simulations.\n   this will be entirely particular to the project you're working on.\n4. confirm that your results are converged.\n\nconfirming the model is correct\n-------------------------------\n\nalthough tenpy makes model implementation much easier than constructing the mpo by hand, one should still ensure that the mpo represents the intended model faithfully.\nthere are several possible ways to do this. firstly, for sufficiently small system sizes, one can contract the entire mpo into a matrix, and inspect the matrix elements. in tenpy, this can be done using tenpy.networks.mpo.mpo.get_full_hamiltonian. these should reproduce the analytical hamiltonian up to machine precision, or any other necessary cut-off (e.g., long-range interactions may be truncated at some finite distance).\n\nsecondly, if the model basis allows it, one can construct (product state) mpss for known eigenstates of the model and evaluate whether these reproduce the correct eigenvalues upon contraction with the mpo.\n\nfinally, one can sometimes construct a basis of single- or even two-particle mpss in some basis, and evaluate the mpo on this basis to get a representation of the single- and two-particle hamiltonian.\nif the model contains only single- and two-body terms, this latter approach should reproduce all terms in the hamiltonian.\n\nlow-effort tests\n----------------\nas not every state can be accurately represented by an mps, some results are outside the reach of (i)dmrg.\nto prevent wasting considerable numerical resources on a fruitless project, it is recommended to run some low-effort trials first, and see whether any indication of the desired result can be found.\nif so, one can then go on to more computationally expensive simulations.\nif not, one should evaluate:\n\n1. whether there is a mistake in the model or simulation set-up,\n2. whether a slightly more computationally expensive test would potentially yield a result, or\n3. whether your approach is unfortunately out of reach of (i)dmrg.\n\nto set up low-effort trials, one should limit system size, bond dimension and the range of interactions, as well as (if possible) target a non-critical region of phase space.\nall these measures reduce the size of and/or entanglement entropy needing to be captured by the mps, which yields both memory and run time advantages.\nof course, one introduces a trade-off between computational cost and accuracy, which is why one should be careful to not put too much faith into results obtained at this stage.\n\ndetecting convergence issues\n----------------------------\n\nensuring that the results of an (i)dmrg simulation are well-converged and thus reliable is a hugely important part of any (i)dmrg study.\npossible indications that there might be a convergence issue include:\n\n1. the simulation shows a non-monotonous decrease of energy, and/or a non-monotonous increase of entanglement entropy. an increase of energy or decrease of entanglement entropy on subsequent steps within a sweep, or between subsequent sweeps, are particularly suspicious.\n2. the simulation does not halt because it reached a convergence criterion, but because it reached its maximum number of sweeps.\n3. results vary wildly under small changes of parameters. in particular, if a small change in bond dimension yields a big change in results, one should be suspicious of the data.\n\ncombating convergence issues\n----------------------------\n\nto combat convergence issues of the (i)dmrg algorithm, several strategies (short of switching to a different method) can be attempted:\n\n1. ensure that there are no errors in the model (see above) or the simulation set-up.\n2. increase the maximum bond dimension.\n3. ramp up the maximum bond dimension during simulation, rather than starting at the highest value. i.e., define a schedule wherein the first :math:`n_{\\mathrm{sweeps}}` sweeps run at some :math:`\\chi_1 < \\chi_\\mathrm{max}`, the next :math:`n_{\\mathrm{sweeps}}` at :math:`\\chi_1 < \\chi_2 < \\chi_{\\mathrm{max}}`, etc.\n   this can be done through the ``chi_list`` option of the tenpy.algorithms.dmrg.dmrgengine.\n   you should also make sure that the ``max_hours`` option is set to sufficiently long runtimes.\n4. increase the maximum number of sweeps the algorithm is allowed to make, through the ``max_sweeps`` option of the tenpy.algorithms.dmrg.dmrgengine.\n5. change the tenpy.algorithms.dmrg.mixer settings to in- or decrease the effects of the mixer.\n6. change convergence criteria. this will not overcome convergence issues in itself, but can help fine tune the (i)dmrg simulation if it takes a long time to converge (relax the convergence constraints), or if the simulation finishes too soon (tighten the constraints).\n   criteria to consider are ``max_e_err`` and ``max_s_err``, in tenpy.algorithms.dmrg.dmrgengine.\n7. increase the minimum number of sweeps taken by the algorithm. again, this will not resolve issues due to bad convergence, but might prevent bad results due to premature convergence.\n   this can be done through the ``min_sweeps`` option of the tenpy.algorithms.dmrg.dmrgengine.\n8. change the size and shape of the mps unit cell (where possible), in case an artificially enforced translational invariance prevents the algorithm from finding a true ground state which is incommensurate with this periodicity.\n   for example, a chain system which has a true ground state that is periodic in three sites, will not be accurately represented by a two-site mps unit cell, as the latter enforces two-site periodicity.\n\n\nin some instances, it is essentially unavoidable to encounter convergence issues.\nin particular, a simulation of a critical state can cause problems with (i)dmrg convergence, as these states violate the area law underlying an accurate mps approximation.\nin these cases, one should acknowledge the difficulties imposed by the method and take care to be very careful in interpreting the data. tutorial documentation dmrg-protocol",
    "tokens": 1392
  },
  {
    "category": "tutorials",
    "name": "doc.options",
    "content": "--- DOCUMENTATION: options ---\nParameters and options\n======================\n\n(We use `parameter` and `option` synonymously. See also the section on parameters in :doc:`/intro/simulations`.\n\nStandard simulations in TeNPy can be defined by just a set of options collected in a dictionary (possibly containing\nother parameter dictionaries).\nIt can be convenient to represent these options in a [yaml]_ file, say ``parameters.yml``, which might look like this:\n\n\nNote that the default values and even the allowed/used option names often depend on other parameters.\nFor example, the `model_class` parameter above given to a tenpy.simulations.simulation.Simulation selects a model class,\nand different model classes might have completely different parameters.\nThis gives you freedom to easily define your own parameters when you implement a model,\nbut it also makes it a little bit harder to keep track of allowed values.\n\nIn the TeNPy documentation, we use the ``Options`` sections of doc-strings to define parameters that are read out.\nEach documented parameter is attributed to one set of parameters, called \"config\", and managed in a tenpy.tools.params.Config class at runtime.\nThe above example represents the config for a `Simulation`, with the `model_params` representing the config given as\n`options` to the model for initialization.\nSometimes, there is also a structure of one `config` including the parameters from another one:\nFor example, the generic parameters for time evolution algorithms, :cfgTimeEvolutionAlgorithm are included\ninto the :cfgTEBDEngine config, similarly to the sub-classing used.\n\nDuring runtime, the tenpy.tools.params.Config class logs the first use of any parameter (with DEBUG log-level, if\nthe default is used, and with INFO log-level, if it is non-default). Moreover, the default is saved into the parameter\ndictionary. Hence, it will contain the *full set of all used parameters*, default and non-default, at the end of a\nsimulation, e.g., in the `sim_params` of the `results` returned by tenpy.simulations.Simulation.run.\n\n\n    You can find a **list of all the different configs** in the cfg-config-index, and a **list of all parameters** in cfg-option-index.\n\n\n    If you add extra options to your configuration that TeNPy doesn't read out by the end of the simulation, it will (usually) issue a warning.\n    Getting such a warnings is an indicator for a typo in your configuration, or an option being in the wrong config dictionary.\n\n\nPython snippets in yaml files\n-----------------------------\nWhen defining the parameters in the yaml file, you might want to evaluate small formulas e.g., set a parameter to a certain fraction of $\\pi$,\nor expanding a long list ``[2**i for i in range(5, 10)]`` without explicitly writing all the entries.\nFor those cases, it can be convenient to have small python snippets inside the yaml file, which we allow by loading the\nyaml files with tenpy.tools.params.load_yaml_with_py_eval.\n\nIt defines a ``!py_eval`` yaml tag, which should be followed by a string of python code to be evaluated with python's ``eval()`` function.\nA good method to pass the python code is to use a literal string in yaml, as shown in the simple examples below.\n\n\n    a: !py_eval |\n        2**np.arange(6, 10)\n    b: !py_eval |\n        [10, 15] + list(range(20, 31, 2)) + [35, 40]\n    c: !py_eval \"2*np.pi * 0.3\"",
    "search_text": "doc.options --- documentation: options ---\nparameters and options\n======================\n\n(we use `parameter` and `option` synonymously. see also the section on parameters in :doc:`/intro/simulations`.\n\nstandard simulations in tenpy can be defined by just a set of options collected in a dictionary (possibly containing\nother parameter dictionaries).\nit can be convenient to represent these options in a [yaml]_ file, say ``parameters.yml``, which might look like this:\n\n\nnote that the default values and even the allowed/used option names often depend on other parameters.\nfor example, the `model_class` parameter above given to a tenpy.simulations.simulation.simulation selects a model class,\nand different model classes might have completely different parameters.\nthis gives you freedom to easily define your own parameters when you implement a model,\nbut it also makes it a little bit harder to keep track of allowed values.\n\nin the tenpy documentation, we use the ``options`` sections of doc-strings to define parameters that are read out.\neach documented parameter is attributed to one set of parameters, called \"config\", and managed in a tenpy.tools.params.config class at runtime.\nthe above example represents the config for a `simulation`, with the `model_params` representing the config given as\n`options` to the model for initialization.\nsometimes, there is also a structure of one `config` including the parameters from another one:\nfor example, the generic parameters for time evolution algorithms, :cfgtimeevolutionalgorithm are included\ninto the :cfgtebdengine config, similarly to the sub-classing used.\n\nduring runtime, the tenpy.tools.params.config class logs the first use of any parameter (with debug log-level, if\nthe default is used, and with info log-level, if it is non-default). moreover, the default is saved into the parameter\ndictionary. hence, it will contain the *full set of all used parameters*, default and non-default, at the end of a\nsimulation, e.g., in the `sim_params` of the `results` returned by tenpy.simulations.simulation.run.\n\n\n    you can find a **list of all the different configs** in the cfg-config-index, and a **list of all parameters** in cfg-option-index.\n\n\n    if you add extra options to your configuration that tenpy doesn't read out by the end of the simulation, it will (usually) issue a warning.\n    getting such a warnings is an indicator for a typo in your configuration, or an option being in the wrong config dictionary.\n\n\npython snippets in yaml files\n-----------------------------\nwhen defining the parameters in the yaml file, you might want to evaluate small formulas e.g., set a parameter to a certain fraction of $\\pi$,\nor expanding a long list ``[2**i for i in range(5, 10)]`` without explicitly writing all the entries.\nfor those cases, it can be convenient to have small python snippets inside the yaml file, which we allow by loading the\nyaml files with tenpy.tools.params.load_yaml_with_py_eval.\n\nit defines a ``!py_eval`` yaml tag, which should be followed by a string of python code to be evaluated with python's ``eval()`` function.\na good method to pass the python code is to use a literal string in yaml, as shown in the simple examples below.\n\n\n    a: !py_eval |\n        2**np.arange(6, 10)\n    b: !py_eval |\n        [10, 15] + list(range(20, 31, 2)) + [35, 40]\n    c: !py_eval \"2*np.pi * 0.3\" tutorial documentation options",
    "tokens": 752
  },
  {
    "category": "tutorials",
    "name": "doc.measurements",
    "content": "--- DOCUMENTATION: measurements ---\nMeasurements for Simulations\n============================\n\nRationale\n---------\n\nWhen we run a simulation performing a time evolution, we are interested in measurements\nafter every (n-th) time step, but it would be too costly (in terms of disk space) to save the\nfull psi at each time step; we only have the ``|psi(t)>`` *during* the simulation, not afterwards.\nHence, we need to define what measurements we want to perform for a given simulation **before**\nrunning it.\n\n    For variational ground state searches, e.g. DMRG, the situation is better: we're not\n    interested in how we got to the ground state, but only properties of the ground state itself.\n    In this case, we can first run DMRG, save the state, and then perform additional\n    measurements and analysis *after* finishing the simulation, so it is not crucial to\n    define all the measurements before the simulation.\n\nThe setup for simulations in TeNPy is as follows.\n\n1) For each measurement that is to be done, we need a measurement function that evaluates\n   whatever we want to measure, e.g., the expectation value or correlation function of some operators.\n   If needed, you can define your own, custom functions.\n2) For a given simulation, we specify the list of measurement functions in the simulation parameter\n   :cfgSimulation.connect_measurements.\n3) When the simulation runs, it calls the tenpy.simulations.Simulation.make_measurements method\n   each time a set of measurements should be performed, e.g. on the initial state, during the time\n   evolution, and on the final state.\n   This causes a call to each of the measurement functions specified in\n   the :cfgSimulation.connect_measurements parameter, passing the current state\n   ``psi, model, simulation`` as arguments (possibly amongst other keyword arguments\n   also specified in :cfgSimulation.connect_measurements).\n   Moreover, it passes a dictionary ``results``, in which measurement results should be saved.\n   At the end of `make_measurements`, the simulation class merges the obtained results\n   into the collection tenpy.simulations.Simulation.results of all previous measurements\n4) At the end of simulation, the `results` are saved and returned for further analysis (e.g. plotting).\n\n\nMeasurement functions\n---------------------\n\nIn the simplest case, a measurement function is just a function, which can take the keyword arguments\n``results, psi, model, simulation`` and saves the measurement results in the dictionary `results`.\nThe other arguments `psi` and `model` are the current MPS and model that can be used for measurements,\nand `simulation` gives access to the full simulation class, in case other additional data is needed.\n\nWithin TeNPy, we use the convention that measurement functions (taking these arguments and saving to `results` instead\nof simply returning values) start with an ``m_`` in their name.\nA few generic measurement functions are defined in tenpy.simulations.measurement.\n\nAs a first, somewhat trivial example, let us look at the source code of\ntenpy.simulations.measurement.m_entropy::\n\n    def m_entropy(results, psi, model, simulation, results_key='entropy'):\n        results[results_key] = psi.entanglement_entropy()\n\nAs you can see, it's a simple wrapper around the MPS method tenpy.networks.mps.MPS.entanglement_entropy.\nNote that usually the `psi` and `model` arguments are the same as the simulation attributes\n``simulation.psi`` and ``simulation.model``, but they can be different in certain cases, e.g. when grouping sites.\nIn most cases, you should directly use the passed `psi` and `model`.\n\nOf course, you can also do some actual calculations in the measurement functions.\nA good example of this is the tenpy.simulations.measurement.m_onsite_expectation_value - take a look at it's\nsource code. Another example could be the `m_pollmann_turner_inversion` measurement function defined in the\n:doc:`/examples/model_custom` example from the :doc:`/intro/simulations` guide.\n\n\nThe connect_measurements parameter\n----------------------------------\n\nThe :cfgSimulation.connect_measurements parameter is a list with one entry for each measurement function to be\nused. Each function is specified by a tuple ``module, func_name, extra_kwargs, priority``.\nHere, `module` and `func` specify the module and name of the function, `extra_kwargs` are (optional) additional keyword\narguments to be given to the function, and `priority` allows to control the order in which the measurement functions get\ncalled. The latter is useful if you want to \"post-process\" results of another measurement function.\n\nFor example, say you want to measure local expectation values of both `Sz` and `Sx` with\ntenpy.simulations.measurement.m_onsite_expectation_value, then you could use\n\n\n    connect_measurements:\n        - - tenpy.simulations.measurement\n          - m_onsite_expectation_value\n          - opname: Sx\n        - - tenpy.simulations.measurement\n          - m_onsite_expectation_value\n          - opname: Sz\n\nThese measurement functions have default `results_key` under which they save values in the `results`, so you can then\nread out ``results['<Sx>']`` and ``results['<Sz>']`` in the simulation results.\nIf you want other keys, you can explicitly specify them with the `results_key` argument of the function, e.g.,\n\n\n    connect_measurements:\n        - - tenpy.simulations.measurement\n          - m_onsite_expectation_value\n          - opname: Sx\n            results_key: X_i     # save as results['X_i']\n        - - tenpy.simulations.measurement\n          - m_onsite_expectation_value\n          - opname: Sz\n            results_key: Z_i     # save as results['Z_i']\n\n\nSome measurements are actually that common that they get added by default to the simulations (unless you explicitly\ndisable them with :cfgSimulation.use_default_measurements); for example the tenpy.simulations.measurement.m_entropy\nis measured for any simulation, as it appears in tenpy.simulations.simulation.Simulation.default_measurements.\n\nOften, what you want to measure is just calling a method of the state `psi`, so there is a special syntax in the\n`connect_measurements` parameter:\nif you **specify the first entry to be** ``psi_method``, ``model_method`` or ``simulation_method``, you can call a method of the\ncorresponding classes.\nAs for global measurement functions, we pass the corresponding ``results, psi, model, simulation`` keyword arguments,\ne.g. `psi_method` measurement functions need to accept ``results, model, simulation`` as arguments, and\n`simulation_method` measurement functions should accept ``results, psi, model``.\n\nThis is already very useful to call measurement functions defined inside (custom) models or simulation classes,\nyet methods of `psi` don't follow the measurement function call structure, but simply return values.\nFor those cases, you can use another special syntax, namely to **simply add `wrap` before the function name**.\nIn this case, we don't pass ``results, psi, model, simulation``, but simply save the return values of the function\nin the results, under the `results_key` that gets passed as extra keyword argument,\nsee (the source code of) tenpy.simulations.measurement.measurement_wrapper.\nThe `results_key` defaults to the function name.\n\nTo make this clearer, let's extend the example above with more measurements:\n\n\n    connect_measurements:\n        - - tenpy.simulations.measurement\n          - m_onsite_expectation_value\n          - opname: Sx\n        - - tenpy.simulations.measurement\n          - m_onsite_expectation_value\n          - opname: Sz\n        - - psi_method\n          - wrap correlation_function   # call psi.correlation_function()\n          - results_key: '<Sz Sz>'      # save returned value as results[\"<Sz Sz>\"]\n            ops1: Sz                    # other (necessary) arguments to psi.correlation_function\n            ops2: Sz\n        - - simulation_method\n          - wrap walltime               # \"measure\" wall clock time it took to run so far\n        - - tenpy.tools.process\n          - wrap memory_usage           # \"measure\" the current RAM usage in MB\n\n\n\n   The `*_method` and `wrap` syntax are (currently) special to the :cfgSimulation.connect_measurements\n   parameter, and do not apply to e.g. :cfgSimulation.connect_algorithm_checkpoint, which uses an analogous\n   setup to allow calling functions at each algorithm checkpoint.",
    "search_text": "doc.measurements --- documentation: measurements ---\nmeasurements for simulations\n============================\n\nrationale\n---------\n\nwhen we run a simulation performing a time evolution, we are interested in measurements\nafter every (n-th) time step, but it would be too costly (in terms of disk space) to save the\nfull psi at each time step; we only have the ``|psi(t)>`` *during* the simulation, not afterwards.\nhence, we need to define what measurements we want to perform for a given simulation **before**\nrunning it.\n\n    for variational ground state searches, e.g. dmrg, the situation is better: we're not\n    interested in how we got to the ground state, but only properties of the ground state itself.\n    in this case, we can first run dmrg, save the state, and then perform additional\n    measurements and analysis *after* finishing the simulation, so it is not crucial to\n    define all the measurements before the simulation.\n\nthe setup for simulations in tenpy is as follows.\n\n1) for each measurement that is to be done, we need a measurement function that evaluates\n   whatever we want to measure, e.g., the expectation value or correlation function of some operators.\n   if needed, you can define your own, custom functions.\n2) for a given simulation, we specify the list of measurement functions in the simulation parameter\n   :cfgsimulation.connect_measurements.\n3) when the simulation runs, it calls the tenpy.simulations.simulation.make_measurements method\n   each time a set of measurements should be performed, e.g. on the initial state, during the time\n   evolution, and on the final state.\n   this causes a call to each of the measurement functions specified in\n   the :cfgsimulation.connect_measurements parameter, passing the current state\n   ``psi, model, simulation`` as arguments (possibly amongst other keyword arguments\n   also specified in :cfgsimulation.connect_measurements).\n   moreover, it passes a dictionary ``results``, in which measurement results should be saved.\n   at the end of `make_measurements`, the simulation class merges the obtained results\n   into the collection tenpy.simulations.simulation.results of all previous measurements\n4) at the end of simulation, the `results` are saved and returned for further analysis (e.g. plotting).\n\n\nmeasurement functions\n---------------------\n\nin the simplest case, a measurement function is just a function, which can take the keyword arguments\n``results, psi, model, simulation`` and saves the measurement results in the dictionary `results`.\nthe other arguments `psi` and `model` are the current mps and model that can be used for measurements,\nand `simulation` gives access to the full simulation class, in case other additional data is needed.\n\nwithin tenpy, we use the convention that measurement functions (taking these arguments and saving to `results` instead\nof simply returning values) start with an ``m_`` in their name.\na few generic measurement functions are defined in tenpy.simulations.measurement.\n\nas a first, somewhat trivial example, let us look at the source code of\ntenpy.simulations.measurement.m_entropy::\n\n    def m_entropy(results, psi, model, simulation, results_key='entropy'):\n        results[results_key] = psi.entanglement_entropy()\n\nas you can see, it's a simple wrapper around the mps method tenpy.networks.mps.mps.entanglement_entropy.\nnote that usually the `psi` and `model` arguments are the same as the simulation attributes\n``simulation.psi`` and ``simulation.model``, but they can be different in certain cases, e.g. when grouping sites.\nin most cases, you should directly use the passed `psi` and `model`.\n\nof course, you can also do some actual calculations in the measurement functions.\na good example of this is the tenpy.simulations.measurement.m_onsite_expectation_value - take a look at it's\nsource code. another example could be the `m_pollmann_turner_inversion` measurement function defined in the\n:doc:`/examples/model_custom` example from the :doc:`/intro/simulations` guide.\n\n\nthe connect_measurements parameter\n----------------------------------\n\nthe :cfgsimulation.connect_measurements parameter is a list with one entry for each measurement function to be\nused. each function is specified by a tuple ``module, func_name, extra_kwargs, priority``.\nhere, `module` and `func` specify the module and name of the function, `extra_kwargs` are (optional) additional keyword\narguments to be given to the function, and `priority` allows to control the order in which the measurement functions get\ncalled. the latter is useful if you want to \"post-process\" results of another measurement function.\n\nfor example, say you want to measure local expectation values of both `sz` and `sx` with\ntenpy.simulations.measurement.m_onsite_expectation_value, then you could use\n\n\n    connect_measurements:\n        - - tenpy.simulations.measurement\n          - m_onsite_expectation_value\n          - opname: sx\n        - - tenpy.simulations.measurement\n          - m_onsite_expectation_value\n          - opname: sz\n\nthese measurement functions have default `results_key` under which they save values in the `results`, so you can then\nread out ``results['<sx>']`` and ``results['<sz>']`` in the simulation results.\nif you want other keys, you can explicitly specify them with the `results_key` argument of the function, e.g.,\n\n\n    connect_measurements:\n        - - tenpy.simulations.measurement\n          - m_onsite_expectation_value\n          - opname: sx\n            results_key: x_i     # save as results['x_i']\n        - - tenpy.simulations.measurement\n          - m_onsite_expectation_value\n          - opname: sz\n            results_key: z_i     # save as results['z_i']\n\n\nsome measurements are actually that common that they get added by default to the simulations (unless you explicitly\ndisable them with :cfgsimulation.use_default_measurements); for example the tenpy.simulations.measurement.m_entropy\nis measured for any simulation, as it appears in tenpy.simulations.simulation.simulation.default_measurements.\n\noften, what you want to measure is just calling a method of the state `psi`, so there is a special syntax in the\n`connect_measurements` parameter:\nif you **specify the first entry to be** ``psi_method``, ``model_method`` or ``simulation_method``, you can call a method of the\ncorresponding classes.\nas for global measurement functions, we pass the corresponding ``results, psi, model, simulation`` keyword arguments,\ne.g. `psi_method` measurement functions need to accept ``results, model, simulation`` as arguments, and\n`simulation_method` measurement functions should accept ``results, psi, model``.\n\nthis is already very useful to call measurement functions defined inside (custom) models or simulation classes,\nyet methods of `psi` don't follow the measurement function call structure, but simply return values.\nfor those cases, you can use another special syntax, namely to **simply add `wrap` before the function name**.\nin this case, we don't pass ``results, psi, model, simulation``, but simply save the return values of the function\nin the results, under the `results_key` that gets passed as extra keyword argument,\nsee (the source code of) tenpy.simulations.measurement.measurement_wrapper.\nthe `results_key` defaults to the function name.\n\nto make this clearer, let's extend the example above with more measurements:\n\n\n    connect_measurements:\n        - - tenpy.simulations.measurement\n          - m_onsite_expectation_value\n          - opname: sx\n        - - tenpy.simulations.measurement\n          - m_onsite_expectation_value\n          - opname: sz\n        - - psi_method\n          - wrap correlation_function   # call psi.correlation_function()\n          - results_key: '<sz sz>'      # save returned value as results[\"<sz sz>\"]\n            ops1: sz                    # other (necessary) arguments to psi.correlation_function\n            ops2: sz\n        - - simulation_method\n          - wrap walltime               # \"measure\" wall clock time it took to run so far\n        - - tenpy.tools.process\n          - wrap memory_usage           # \"measure\" the current ram usage in mb\n\n\n\n   the `*_method` and `wrap` syntax are (currently) special to the :cfgsimulation.connect_measurements\n   parameter, and do not apply to e.g. :cfgsimulation.connect_algorithm_checkpoint, which uses an analogous\n   setup to allow calling functions at each algorithm checkpoint. tutorial documentation measurements",
    "tokens": 1833
  },
  {
    "category": "tutorials",
    "name": "doc.overview",
    "content": "--- DOCUMENTATION: overview ---\nOverview\n========\n\nRepository\n----------\n\nThe root directory of the `git repository <https://github.com/tenpy/tenpy>`_ contains the following folders:\n\ntenpy\n    The actual source code of the library.\n    Every subfolder contains an ``__init__.py`` file with a summary what the modules in it are good for.\n    (This file is also necessary to mark the folder as part of the python package.\n    Consequently, other subfolders of the git repo should not include a ``__init__.py`` file.)\ntoycodes\n    Simple toy codes completely independent of the remaining library (i.e., codes in ``tenpy/``).\n    These codes should be quite readable and try to give a flavor of how (some of) the algorithms work.\nexamples\n    Some example files demonstrating the usage and interface of the library, including pure python files, jupyter\n    notebooks, and example parameter files.\ndoc\n    A folder containing the documentation: the user guide is contained in the ``*.rst`` files.\n    The online documentation is autogenerated from these files and the docstrings of the library.\n    This folder contains a make file for building the documentation, run ``make help`` for the different options.\n    The necessary files for the reference in ``doc/reference`` can be auto-generated/updated with ``make src2html``.\ntests\n    Contains files with test routines, to be used with `pytest`.\n    If you are set up correctly and have `pytest` installed, you can run the test suite with\n    ``pytest`` from within the ``tests/`` folder.\nbuild\n    This folder is not distributed with the code, but is generated by ``setup.py`` (or ``compile.sh``, respectively).\n    It contains compiled versions of the Cython files, and can be ignored (and even removed without loosing functionality).\n\n\nLayer structure\n---------------\n\nThere are several layers of abstraction in TeNPy.\nWhile there is a certain hierarchy of how the concepts build up on each other, the user can decide to utilize only some of them.\nA maximal flexibility is provided by an object oriented style based on classes, which can be inherited and adjusted to individual demands.\n\nThe following figure gives an overview of the most important modules, classes and functions in TeNPy.\nGray backgrounds indicate (sub)modules, yellow backgrounds indicate classes.\nRed arrows indicate inheritance relations, dashed black arrows indicate a direct use.\n(The individual models might be derived from the tenpy.models.model.NearestNeighborModel depending on the geometry of the lattice.)\nThere is a fairly clear hierarchy from top-level simulations wrapping everything you want to do in a single job,\nover high-level algorithms in the tenpy.algorithms module down to basic\noperations from linear algebra in the tenpy.linalg module.\n\n\n\nHigh-level simulations\n----------------------\nThe high-level interface is given by simulations, which probably handle everything you want to run on a computing cluster job:\nGiven a set of parameters (often in the form of a parameter input file),\nthe simulation consists of initializing the model, tensor network and algorithms, running the algorithm,\nperforming some measurements and finally saving the results to disk.\nIt also provides some extra functionality like the ability to resume an interrupted simulation,\ne.g., if your job got killed on the cluster due to runtime limits.\nIdeally, the simulation (sub) class represents the whole simulation from start to end, giving reproducible results\ndepending only on the parameters given to it.\n\nFor example, calling ``tenpy-run parameters.yml`` from the terminal with the following content in the `parameters.yml` file\nwill run DMRG for a tenpy.models.spins.SpinChain:\n\n\n\n   The :doc:`/intro/simulations` user guide is a good point to continue reading\n   when you finished reading this overview.\n\nTo get a sense how things work together, it's instructive to consider the remaining layers in a bottom-to-top order.\n\n\nLow-level: tensors and linear algebra\n-------------------------------------\n\n\n    See :doc:`/intro/npc` for more information on defining charges for arrays.\n\nThe most basic layer is given by in the tenpy.linalg module, which provides basic features of linear algebra.\nIn particular, the tenpy.linalg.np_conserved submodule implements an tenpy.linalg.np_conserved.Array class which is used to represent\nthe tensors. The basic interface of tenpy.linalg.np_conserved is very similar to that of the NumPy and SciPy libraries.\nHowever, the tenpy.linalg.np_conserved.Array class implements abelian charge conservation.\nIf no charges are to be used, one can use 'trivial' arrays, as shown in the following example code.\n\n\n\nThe number and types of symmetries are specified in a tenpy.linalg.charges.ChargeInfo class.\nAn tenpy.linalg.np_conserved.Array instance represents a tensor satisfying a charge rule specifying which blocks of it are nonzero.\nInternally, it stores only the non-zero blocks of the tensor, along with one tenpy.linalg.charges.LegCharge instance for each\nleg, which contains the `charges` and sign `qconj` for each leg.\nWe can combine multiple legs into a single larger tenpy.linalg.charges.LegPipe,\nwhich is derived from the tenpy.linalg.charges.LegCharge and stores all the information necessary to later split the pipe.\n\nThe following code explicitly defines the spin-1/2 :math:`S^+, S^-, S^z` operators and\nuses them to generate and diagonalize the two-site Hamiltonian :math:`H = \\vec{S} \\cdot \\vec{S}`.\nIt prints the charge values (by default sorted ascending) and the eigenvalues of H.\n\n\n\nSites for the local Hilbert space and tensor networks\n-----------------------------------------------------\n\nThe next basic concept is that of a local Hilbert space, which is represented by a tenpy.networks.site.Site in TeNPy.\nThis class does not only label the local states and define the charges, but also\nprovides onsite operators. For example, the tenpy.networks.site.SpinHalfSite provides the\n:math:`S^+, S^-, S^z` operators under the names ``'Sp', 'Sm', 'Sz'``, defined as tenpy.linalg.np_conserved.Array instances similarly as\nin the code above.\nSince the most common sites like for example the tenpy.networks.site.SpinSite (for general spin S=0.5, 1, 1.5,...), tenpy.networks.site.BosonSite and\ntenpy.networks.site.FermionSite are predefined, a user of TeNPy usually does not need to define the local charges and operators explicitly.\nThe total Hilbert space, i.e, the tensor product of the local Hilbert spaces, is then just given by a\nlist of tenpy.networks.site.Site instances. If desired, different kinds of tenpy.networks.site.Site can be combined in that list.\nThis list is then given to classes representing tensor networks like the tenpy.networks.mps.MPS and\ntenpy.networks.mpo.MPO.\nThe tensor network classes also use tenpy.linalg.np_conserved.Array instances for the tensors of the represented network.\n\nThe following example illustrates the initialization of a spin-1/2 site, an tenpy.networks.mps.MPS representing the Neel state, and\nan tenpy.networks.mpo.MPO representing the Heisenberg model by explicitly defining the `W` tensor.\n\n\nModels\n------\n\n\n    See :doc:`/intro/model` for more information on sites and how to define and extend models on your own.\n\nTechnically, the explicit definition of an tenpy.networks.mpo.MPO is already enough to call an algorithm like DMRG in tenpy.algorithms.dmrg.\nHowever, writing down the `W` tensors is cumbersome especially for more complicated models.\nHence, TeNPy provides another layer of abstraction for the definition of models, which we discuss first.\nDifferent kinds of algorithms require different representations of the Hamiltonian.\nTherefore, the library offers to specify the model abstractly by the individual onsite terms and coupling terms of the Hamiltonian.\nThe following example illustrates this, again for the Heisenberg model.\n\n\nWhile this generates the same MPO as in the previous code, this example can easily be adjusted and generalized, for\nexample to a higher dimensional lattice by just specifying a different lattice.\nInternally, the MPO is generated using a finite state machine picture.\nThis allows not only to translate more complicated Hamiltonians into their corresponding MPOs,\nbut also to automate the mapping from a higher dimensional lattice to the 1D chain along which the MPS\nwinds.\nNote that this mapping introduces longer-range couplings, so the model can no longer be defined to be a\ntenpy.models.model.NearestNeighborModel suited for TEBD if another lattice than the tenpy.models.lattice.Chain is to be used.\nOf course, many commonly studied models are also predefined.\nFor example, the following code initializes the Heisenberg model on a kagome lattice;\nthe spin liquid nature of the ground state of this model is highly debated in the current literature.\n\n\nAlgorithms\n----------\n\nThe highest level (beyond the wrapping simulations) is given by algorithms like DMRG and TEBD.\nThey usually need to be initialized with a state, i.e., tensor network like an MPS, and suitable model.\nThose are defined in the next lower levels.\nThe following simple example illustrates the basic structure that the simulation class needs to perform for the same\nparameters as the example above.\n\n\nThe switch from DMRG to iDMRG in TeNPy is simply accomplished by a change of the parameter\n``\"bc_MPS\"`` from ``\"finite\"`` to ``\"infinite\"``, both for the model and the state.\nThe returned ``E`` is then the energy density per site.\nDue to the translation invariance, one can also evaluate the correlation length, here slightly away from the critical point.\n\n\nRunning time evolution with TEBD requires an additional loop, during which the desired observables have to be measured.\nThe following code shows this directly for the infinite version of TEBD.\n\n\nNote that there is also a simulation class for tenpy.simulations.time_evolution.RealTimeEvolution that can handle this extra loop over time, and\nallows to easily switch between different time evolution algorithms.",
    "search_text": "doc.overview --- documentation: overview ---\noverview\n========\n\nrepository\n----------\n\nthe root directory of the `git repository <https://github.com/tenpy/tenpy>`_ contains the following folders:\n\ntenpy\n    the actual source code of the library.\n    every subfolder contains an ``__init__.py`` file with a summary what the modules in it are good for.\n    (this file is also necessary to mark the folder as part of the python package.\n    consequently, other subfolders of the git repo should not include a ``__init__.py`` file.)\ntoycodes\n    simple toy codes completely independent of the remaining library (i.e., codes in ``tenpy/``).\n    these codes should be quite readable and try to give a flavor of how (some of) the algorithms work.\nexamples\n    some example files demonstrating the usage and interface of the library, including pure python files, jupyter\n    notebooks, and example parameter files.\ndoc\n    a folder containing the documentation: the user guide is contained in the ``*.rst`` files.\n    the online documentation is autogenerated from these files and the docstrings of the library.\n    this folder contains a make file for building the documentation, run ``make help`` for the different options.\n    the necessary files for the reference in ``doc/reference`` can be auto-generated/updated with ``make src2html``.\ntests\n    contains files with test routines, to be used with `pytest`.\n    if you are set up correctly and have `pytest` installed, you can run the test suite with\n    ``pytest`` from within the ``tests/`` folder.\nbuild\n    this folder is not distributed with the code, but is generated by ``setup.py`` (or ``compile.sh``, respectively).\n    it contains compiled versions of the cython files, and can be ignored (and even removed without loosing functionality).\n\n\nlayer structure\n---------------\n\nthere are several layers of abstraction in tenpy.\nwhile there is a certain hierarchy of how the concepts build up on each other, the user can decide to utilize only some of them.\na maximal flexibility is provided by an object oriented style based on classes, which can be inherited and adjusted to individual demands.\n\nthe following figure gives an overview of the most important modules, classes and functions in tenpy.\ngray backgrounds indicate (sub)modules, yellow backgrounds indicate classes.\nred arrows indicate inheritance relations, dashed black arrows indicate a direct use.\n(the individual models might be derived from the tenpy.models.model.nearestneighbormodel depending on the geometry of the lattice.)\nthere is a fairly clear hierarchy from top-level simulations wrapping everything you want to do in a single job,\nover high-level algorithms in the tenpy.algorithms module down to basic\noperations from linear algebra in the tenpy.linalg module.\n\n\n\nhigh-level simulations\n----------------------\nthe high-level interface is given by simulations, which probably handle everything you want to run on a computing cluster job:\ngiven a set of parameters (often in the form of a parameter input file),\nthe simulation consists of initializing the model, tensor network and algorithms, running the algorithm,\nperforming some measurements and finally saving the results to disk.\nit also provides some extra functionality like the ability to resume an interrupted simulation,\ne.g., if your job got killed on the cluster due to runtime limits.\nideally, the simulation (sub) class represents the whole simulation from start to end, giving reproducible results\ndepending only on the parameters given to it.\n\nfor example, calling ``tenpy-run parameters.yml`` from the terminal with the following content in the `parameters.yml` file\nwill run dmrg for a tenpy.models.spins.spinchain:\n\n\n\n   the :doc:`/intro/simulations` user guide is a good point to continue reading\n   when you finished reading this overview.\n\nto get a sense how things work together, it's instructive to consider the remaining layers in a bottom-to-top order.\n\n\nlow-level: tensors and linear algebra\n-------------------------------------\n\n\n    see :doc:`/intro/npc` for more information on defining charges for arrays.\n\nthe most basic layer is given by in the tenpy.linalg module, which provides basic features of linear algebra.\nin particular, the tenpy.linalg.np_conserved submodule implements an tenpy.linalg.np_conserved.array class which is used to represent\nthe tensors. the basic interface of tenpy.linalg.np_conserved is very similar to that of the numpy and scipy libraries.\nhowever, the tenpy.linalg.np_conserved.array class implements abelian charge conservation.\nif no charges are to be used, one can use 'trivial' arrays, as shown in the following example code.\n\n\n\nthe number and types of symmetries are specified in a tenpy.linalg.charges.chargeinfo class.\nan tenpy.linalg.np_conserved.array instance represents a tensor satisfying a charge rule specifying which blocks of it are nonzero.\ninternally, it stores only the non-zero blocks of the tensor, along with one tenpy.linalg.charges.legcharge instance for each\nleg, which contains the `charges` and sign `qconj` for each leg.\nwe can combine multiple legs into a single larger tenpy.linalg.charges.legpipe,\nwhich is derived from the tenpy.linalg.charges.legcharge and stores all the information necessary to later split the pipe.\n\nthe following code explicitly defines the spin-1/2 :math:`s^+, s^-, s^z` operators and\nuses them to generate and diagonalize the two-site hamiltonian :math:`h = \\vec{s} \\cdot \\vec{s}`.\nit prints the charge values (by default sorted ascending) and the eigenvalues of h.\n\n\n\nsites for the local hilbert space and tensor networks\n-----------------------------------------------------\n\nthe next basic concept is that of a local hilbert space, which is represented by a tenpy.networks.site.site in tenpy.\nthis class does not only label the local states and define the charges, but also\nprovides onsite operators. for example, the tenpy.networks.site.spinhalfsite provides the\n:math:`s^+, s^-, s^z` operators under the names ``'sp', 'sm', 'sz'``, defined as tenpy.linalg.np_conserved.array instances similarly as\nin the code above.\nsince the most common sites like for example the tenpy.networks.site.spinsite (for general spin s=0.5, 1, 1.5,...), tenpy.networks.site.bosonsite and\ntenpy.networks.site.fermionsite are predefined, a user of tenpy usually does not need to define the local charges and operators explicitly.\nthe total hilbert space, i.e, the tensor product of the local hilbert spaces, is then just given by a\nlist of tenpy.networks.site.site instances. if desired, different kinds of tenpy.networks.site.site can be combined in that list.\nthis list is then given to classes representing tensor networks like the tenpy.networks.mps.mps and\ntenpy.networks.mpo.mpo.\nthe tensor network classes also use tenpy.linalg.np_conserved.array instances for the tensors of the represented network.\n\nthe following example illustrates the initialization of a spin-1/2 site, an tenpy.networks.mps.mps representing the neel state, and\nan tenpy.networks.mpo.mpo representing the heisenberg model by explicitly defining the `w` tensor.\n\n\nmodels\n------\n\n\n    see :doc:`/intro/model` for more information on sites and how to define and extend models on your own.\n\ntechnically, the explicit definition of an tenpy.networks.mpo.mpo is already enough to call an algorithm like dmrg in tenpy.algorithms.dmrg.\nhowever, writing down the `w` tensors is cumbersome especially for more complicated models.\nhence, tenpy provides another layer of abstraction for the definition of models, which we discuss first.\ndifferent kinds of algorithms require different representations of the hamiltonian.\ntherefore, the library offers to specify the model abstractly by the individual onsite terms and coupling terms of the hamiltonian.\nthe following example illustrates this, again for the heisenberg model.\n\n\nwhile this generates the same mpo as in the previous code, this example can easily be adjusted and generalized, for\nexample to a higher dimensional lattice by just specifying a different lattice.\ninternally, the mpo is generated using a finite state machine picture.\nthis allows not only to translate more complicated hamiltonians into their corresponding mpos,\nbut also to automate the mapping from a higher dimensional lattice to the 1d chain along which the mps\nwinds.\nnote that this mapping introduces longer-range couplings, so the model can no longer be defined to be a\ntenpy.models.model.nearestneighbormodel suited for tebd if another lattice than the tenpy.models.lattice.chain is to be used.\nof course, many commonly studied models are also predefined.\nfor example, the following code initializes the heisenberg model on a kagome lattice;\nthe spin liquid nature of the ground state of this model is highly debated in the current literature.\n\n\nalgorithms\n----------\n\nthe highest level (beyond the wrapping simulations) is given by algorithms like dmrg and tebd.\nthey usually need to be initialized with a state, i.e., tensor network like an mps, and suitable model.\nthose are defined in the next lower levels.\nthe following simple example illustrates the basic structure that the simulation class needs to perform for the same\nparameters as the example above.\n\n\nthe switch from dmrg to idmrg in tenpy is simply accomplished by a change of the parameter\n``\"bc_mps\"`` from ``\"finite\"`` to ``\"infinite\"``, both for the model and the state.\nthe returned ``e`` is then the energy density per site.\ndue to the translation invariance, one can also evaluate the correlation length, here slightly away from the critical point.\n\n\nrunning time evolution with tebd requires an additional loop, during which the desired observables have to be measured.\nthe following code shows this directly for the infinite version of tebd.\n\n\nnote that there is also a simulation class for tenpy.simulations.time_evolution.realtimeevolution that can handle this extra loop over time, and\nallows to easily switch between different time evolution algorithms. tutorial documentation overview",
    "tokens": 2139
  },
  {
    "category": "tutorials",
    "name": "doc.model_details",
    "content": "--- DOCUMENTATION: model_details ---\nDetails on the implementation of Models\n=======================================\n\nIn this chapter, we provide some more detail on how models work, and how you might customize them.\nYou should probably read :doc:`/intro/model` first.\n\nWe distinguish three different ways in which the Hamiltonian can be given, and there is a\nbase class for each one of them:\n\n1. In a tenpy.models.model.NearestNeighborModel, we have the Hamiltonian as a sum of\n   two-body terms, which are stored explicitly as a list\n   of tenpy.linalg.np_conserved.Array\\s.\n   This is the structure you need to do TEBD with the model.\n2. In a tenpy.models.model.MPOModel, we have the Hamiltonian directly given as a\n   tenpy.networks.mpo.MPO.\n   This is the structure you need to do DMRG, ExpMPOEvolution or TDVP.\n3. In a tenpy.models.model.CouplingModel, the Hamiltonian is given symbolically, in\n   the form of terms (see tenpy.networks.terms).\n   There are (currently) no algorithms in TeNPy that require this particular structure.\n   We can view it more as a convenient way to specify models, which also allows us to\n   initialize the other two structures easily.\n\nA custom model (as well as the pre-defined models in TeNPy) should then inherit from all of the\nclasses that are applicable.\n\nIf you define a tenpy.models.model.CouplingModel structure for the model, that class\noffers convenient methods to initialize the other two structures, as shown in more detail below.\nThere is a convenience class that achieves this directly, the tenpy.models.model.CouplingMPOModel.\nIt uses the same symbolical representation of the Hamiltonian, but in contrast to the\nplain tenpy.models.model.CouplingModel, automates the initialization of the lattice and\nof the MPO. It also automatically initializes ``H_bond``, if it detects that the custom model\nis also a subclass of tenpy.models.model.NearestNeighborModel.\nThis means that there is virtually no explicit code needed, e.g. when the\ntenpy.models.tf_ising.TFIModel is specialized to the tenpy.models.tf_ising.TFIChain.\n\nIn the rest of this intro, we introduce the classes and their ways of initializing models in more detail.\n\n\nThe CouplingModel: general structure\n------------------------------------\n\nThe tenpy.models.model.CouplingModel provides a general, quite abstract way to specify a Hamiltonian\nof couplings on a given lattice.\nOnce initialized, its methods tenpy.models.CouplingModel.add_onsite and\ntenpy.models.model.CouplingModel.add_coupling allow to add onsite and coupling terms repeated over the different\nunit cells of the lattice.\nIn that way, it basically allows a straight-forward translation of the Hamiltonian given as a math formula\n:math:`H = \\sum_{i} A_i B_{i+dx} + ...` with onsite operators `A`, `B`,... into a model class.\n\nThe general structure for a new model based on the tenpy.models.model.CouplingModel is then::\n\n    class MyNewModel3(CouplingModel,MPOModel,NearestNeighborModel):\n        def __init__(self, ...):\n            ...  # follow the basic steps explained below\n\n\nIn the initialization method ``__init__(self, ...)`` of this class you can then follow these basic steps:\n\n0. Read out the parameters.\n1. Given the parameters, determine the charges to be conserved.\n   Initialize the tenpy.linalg.charges.LegCharge of the local sites accordingly.\n2. Define (additional) local operators needed.\n3. Initialize the needed tenpy.networks.site.Site.\n\n\n      Using pre-defined sites like the tenpy.networks.site.SpinHalfSite is recommended and\n      can replace steps 1-3.\n\n4. Initialize the lattice (or if you got the lattice as a parameter, set the sites in the unit cell).\n5. Initialize the tenpy.models.model.CouplingModel with ``CouplingModel.__init__(self, lat)``.\n6. Use tenpy.models.model.CouplingModel.add_onsite and tenpy.models.model.CouplingModel.add_coupling\n   to add all terms of the Hamiltonian. Here, the tenpy.models.lattice.Lattice.pairs of the lattice\n   can come in handy, for example::\n\n       self.add_onsite(-np.asarray(h), 0, 'Sz')\n       for u1, u2, dx in self.lat.pairs['nearest_neighbors']:\n           self.add_coupling(0.5*J, u1, 'Sp', u2, 'Sm', dx, plus_hc=True)\n           self.add_coupling(    J, u1, 'Sz', u2, 'Sz', dx)\n\n\n      The method tenpy.models.model.CouplingModel.add_coupling adds the coupling only in one direction, i.e.\n      not switching `i` and `j` in a :math:`\\sum_{\\langle i, j\\rangle}`.\n      If you have terms like :math:`c^\\dagger_i c_j` or :math:`S^{+}_i S^{-}_j` in your Hamiltonian,\n      you *need* to add it in both directions to get a Hermitian Hamiltonian!\n      The easiest way to do that is to use the `plus_hc` option of\n      tenpy.models.model.CouplingModel.add_onsite and tenpy.models.model.CouplingModel.add_coupling,\n      as we did for the :math:`J/2 (S^{+}_i S^{-}_j + h.c.)` terms of the Heisenberg model above.\n      Alternatively, you can add the hermitian conjugate terms explicitly, see the examples in\n      tenpy.models.model.CouplingModel.add_coupling for more details.\n\n   Note that the `strength` arguments of these functions can be (numpy) arrays for site-dependent couplings.\n   If you need to add or multiply some parameters of the model for the `strength` of certain terms,\n   it is recommended use ``np.asarray`` beforehand -- in that way lists will also work fine.\n7. Finally, if you derived from the tenpy.models.model.MPOModel, you can call\n   tenpy.models.model.CouplingModel.calc_H_MPO to build the MPO and use it for the initialization\n   as ``MPOModel.__init__(self, lat, self.calc_H_MPO())``.\n8. Similarly, if you derived from the tenpy.models.model.NearestNeighborModel, you can call\n   tenpy.models.model.CouplingModel.calc_H_bond to initialize it\n   as ``NearestNeighborModel.__init__(self, lat, self.calc_H_bond())``.\n   Calling ``self.calc_H_bond()`` will fail for models which are not nearest-neighbors (with respect to the MPS ordering),\n   so you should only subclass the tenpy.models.model.NearestNeighborModel if the lattice is a simple\n   tenpy.models.lattice.Chain.\n\n\n    The method tenpy.models.model.CouplingModel.add_coupling works only for terms involving operators on 2\n    sites. If you have couplings involving more than two sites, you can use the\n    tenpy.models.model.CouplingModel.add_multi_coupling instead.\n    A prototypical example is the exactly solvable tenpy.models.toric_code.ToricCode.\n\n\nThe code of the module tenpy.models.xxz_chain is included below as an illustrative example how to implement a\nModel. The implementation of the tenpy.models.xxz_chain.XXZChain directly follows the steps\noutline above.\nThe tenpy.models.xxz_chain.XXZChain2 implements the very same model, but based on the\ntenpy.models.model.CouplingMPOModel explained in the next section.\n\n\n\nThe easiest way: the CouplingMPOModel\n-------------------------------------\nSince many of the basic steps above are always the same, we don't need to repeat them all the time.\nSo we have yet another class helping to structure the initialization of models: the tenpy.models.model.CouplingMPOModel.\nThe general structure of this class is like this::\n\n    class CouplingMPOModel(CouplingModel,MPOModel):\n        default_lattice = \"Chain\"\n        \"\n\n        def __init__(self, model_param):\n            # ... follows the basic steps 1-8 using the methods\n            lat = self.init_lattice(self, model_param)  # for step 4\n            # ...\n            self.init_terms(self, model_param) # for step 6\n            # ...\n\n        def init_sites(self, model_param):\n            # You should overwrite this in most cases to ensure\n            # getting the site(s) and charge conservation you want\n            site = SpinSite(...)  # or FermionSite, BosonSite, ...\n            return site  # (or tuple of sites)\n\n        def init_lattice(self, model_param):\n            sites = self.init_sites(self, model_param) # for steps 1-3\n            # and then read out the class attribute `default_lattice`,\n            # initialize an arbitrary pre-defined lattice\n            # using model_params['lattice']\n            # and ensure it's the default lattice if the class attribute\n            # `force_default_lattice` is True.\n\n        def init_terms(self, model_param):\n            # does nothing.\n            # You should overwrite this\n\nThe tenpy.models.xxz_chain.XXZChain2 included above illustrates, how it can be used.\nYou need to implement steps 1-3) by overwriting the method tenpy.models.model.CouplingMPOModel.init_sites\nStep 4) is performed in the method tenpy.models.model.CouplingMPOModel.init_lattice, which initializes arbitrary 1D or 2D\nlattices; by default a simple 1D chain.\nIf your model only works for specific lattices, you can overwrite this method in your own class.\nStep 6) should be done by overwriting the method tenpy.models.model.CouplingMPOModel.init_terms.\nSteps 5,7,8 and calls to the `init_...` methods for the other steps are done automatically if you just call the\n``CouplingMPOModel.__init__(self, model_param)``.\n\nThe tenpy.models.xxz_chain.XXZChain and tenpy.models.xxz_chain.XXZChain2 work only with the\ntenpy.models.lattice.Chain as lattice, since they are derived from the tenpy.models.model.NearestNeighborModel.\nThis allows to use them for TEBD in 1D (yeah!), but we can't get the MPO for DMRG on (for example) a tenpy.models.lattice.Square\nlattice cylinder - although it's intuitively clear, what the Hamiltonian there should be: just put the nearest-neighbor\ncoupling on each bond of the 2D lattice.\n\nIt's not possible to generalize a tenpy.models.model.NearestNeighborModel to an arbitrary lattice where it's\nno longer nearest Neighbors in the MPS sense, but we can go the other way around:\nfirst write the model on an arbitrary 2D lattice and then restrict it to a 1D chain to make it a tenpy.models.model.NearestNeighborModel.\n\nLet me illustrate this with another standard example model: the transverse field Ising model, implemented in the module\ntenpy.models.tf_ising included below.\nThe tenpy.models.tf_ising.TFIModel works for arbitrary 1D or 2D lattices.\nThe tenpy.models.tf_ising.TFIChain is then taking the exact same model making a tenpy.models.model.NearestNeighborModel,\nwhich only works for the 1D chain.\n\n\n\nAutomation of Hermitian conjugation\n-----------------------------------\nAs most physical Hamiltonians are Hermitian, these Hamiltonians are fully determined when only half of the mutually conjugate terms is defined. For example, a simple Hamiltonian:\n\n        H = \\sum_{\\langle i,j\\rangle, i<j}\n              - \\mathtt{J} (c^{\\dagger}_i c_j + c^{\\dagger}_j c_i)\n\nis fully determined by the term :math:`c^{\\dagger}_i c_j` if we demand that Hermitian conjugates are included automatically.\nIn TeNPy, whenever you add a coupling using tenpy.models.model.CouplingModel.add_onsite,\ntenpy.models.model.CouplingModel.add_coupling, or tenpy.models.model.CouplingModel.add_multi_coupling,\nyou can use the optional argument `plus_hc` to automatically create and add the Hermitian conjugate of that coupling term - as shown above.\n\nAdditionally, in an MPO, explicitly adding both a non-Hermitian term and its conjugate increases the bond dimension of the MPO, which increases the memory requirements of the tenpy.networks.mpo.MPOEnvironment.\nInstead of adding the conjugate terms explicitly, you can set a flag `explicit_plus_hc` in the tenpy.models.model.MPOCouplingModel parameters, which will ensure two things:\n\n1. The model and the MPO will only store half the terms of each Hermitian conjugate pair added, but the flag `explicit_plus_hc` indicates that they *represent* `self + h.c.`.\n   In the example above, only the term :math:`c^{\\dagger}_i c_j` would be saved.\n2. At runtime during DMRG, the Hermitian conjugate of the (now non-Hermitian) MPO will be computed and applied along with the MPO, so that the effective Hamiltonian is still Hermitian.\n\n\n    The model flag `explicit_plus_hc` should be used in conjunction with the flag `plus_hc` in tenpy.models.model.CouplingModel.add_coupling or tenpy.models.model.CouplingModel.add_multi_coupling.\n    If `plus_hc` is `False` while `explicit_plus_hc` is `True` the MPO bond dimension will not be reduced, but you will still pay the additional computational cost of computing the Hermitian conjugate at runtime.\n\nThus, we end up with several use cases, depending on your preferences.\nConsider the tenpy.models.fermions_spinless.FermionModel.\nIf you do not care about the MPO bond dimension, and want to add Hermitian conjugate terms manually, you would set `model_par['explicit_plus_hc'] = False` and write::\n\n    self.add_coupling(-J, u1, 'Cd', u2, 'C', dx)\n    self.add_coupling(np.conj(-J), u2, 'Cd', u1, 'C', -dx)\n\nIf you wanted to save the trouble of the extra line of code (but still did not care about MPO bond dimension), you would keep the `model_par`, but instead write::\n\n    self.add_coupling(-J, u1, 'Cd', u2, 'C', dx, plus_hc=True)\n\nFinally, if you wanted a reduction in MPO bond dimension, you would need to set `model_par['explicit_plus_hc'] = True`, and write::\n\n    self.add_coupling(-J, u1, 'Cd', u2, 'C', dx, plus_hc=True)\n\n\nNon-uniform terms and couplings\n-------------------------------\nThe CouplingModel-methods tenpy.models.model.CouplingModel.add_onsite, tenpy.models.model.CouplingModel.add_coupling,\nand tenpy.models.model.CouplingModel.add_multi_coupling add a sum over a \"coupling\" term shifted by lattice\nvectors. However, some models are not that \"uniform\" over the whole lattice.\n\nFirst of all, you might have some local term that gets added only at one specific location in the lattice.\nYou can add such a term for example with tenpy.models.model.CouplingModel.add_local_term.\n\nSecond, if you have irregular lattices, take a look at the corresponding section in :doc:`/intro/lattices`.\n\nFinally, note that the argument `strength` for the `add_onsite`, `add_coupling`, and `add_multi_coupling` methods\ncan not only be a numpy scalar, but also a (numpy) array.\nIn general, the sum performed by the methods runs over the given term\nshifted by lattice vectors *as far as possible to still fit the term into the lattice*.\n\nFor the tenpy.models.model.CouplingModel.add_onsite case this criterion is simple: there is exactly one site in each lattice unit cell with the `u` specified as separate argument, so the correct shape for the `strength` array is simply given by tenpy.models.lattice.Lattice.Ls.\nFor example, if you want the defacto standard model studied for many-body localization, a Heisenberg chain with random , uniform onsite field :math:`h^z_i \\in [-W, W]`,\n\n\n    H = J \\sum_{i=0}^{L-1} \\vec{S}_i \\cdot \\vec{S}_{i+1} - \\sum_{i=0}^{L} h^z_i S^z_i\n\nyou can use the tenpy.models.spins.SpinChain with the following model parameters::\n\n    L = 30 # or whatever you like...\n    W = 5.  # MBL transition at W_c ~= 3.5 J\n    model_params = {\n        'L': L,\n        'Jx': 1., 'Jy': 1., 'Jz': 1.,\n        'hz': 2.*W*(np.random.random(L) - 0.5),  # random values in [-W, W], shape (L,)\n        'conserve': 'best',\n    }\n    M = tenpy.models.spins.SpinChain(model_params)\n\nFor tenpy.models.model.CouplingModel.add_coupling and tenpy.models.model.CouplingModel.add_multi_coupling,\nthings become a little bit more complicated, and the correct shape of the `strength` array depends not only on the tenpy.models.lattice.Lattice.Ls\nbut also on the boundary conditions of the lattice. Given a term, you can call\ntenpy.models.lattice.Lattice.coupling_shape and tenpy.models.lattice.Lattice.multi_coupling_shape to find out the correct shape for `strength`.\nTo avoid any ambiguity, the shape of the `strength` always has to fit, at least after a tiling performed by tenpy.tools.misc.to_array.\n\nFor example, consider the Su-Schrieffer-Heeger model, a spin-less tenpy.models.fermions.FermionChain with hopping strength alternating between two values, say `t1` and `t2`.\nYou can generate this model for example like this::\n\n    L = 30 # or whatever you like...\n    t1, t2 = 0.5, 1.5\n    t_array = np.array([(t1 if i % 2 == 0 else t2) for i in range(L-1)])\n    model_params = {\n        'L': L,\n        't': t_array,\n        'V': 0., 'mu': 0.,  # just free fermions, but you can generalize...\n        'conserve': 'best'\n    }\n    M = tenpy.models.fermions.FermionChain(model_params)\n\n\nSome random remarks on models\n-----------------------------\n\n- Needless to say that we have also various predefined models under tenpy.models.\n- If you want to use random parameters, you should use ``model.rng`` as a random number generator and change ``model_params['random_seed']`` for different configurations.\n- Of course, an MPO is all you need to initialize a tenpy.models.model.MPOModel to be used for DMRG; you don't have to use the tenpy.models.model.CouplingModel\n  or tenpy.models.model.CouplingMPOModel.\n  For example, we build the model directly from an MPO in ``examples/mpo_exponentially_decaying.py``.\n  The tenpy.models.aklt.AKLTChain is another example which is directly constructed from the `H_bond` terms.\n- We suggest writing the model to take a single parameter dictionary for the initialization,\n  as the tenpy.models.model.CouplingMPOModel does.\n  The tenpy.models.model.CouplingMPOModel converts the dictionary to a dict-like\n  tenpy.tools.params.Config with some additional features before passing it on to the `init_lattice`,\n  `init_site`, ... methods.\n  It is recommended to read out providing default values with ``model_params.get(\"key\", default_value)``,\n  see tenpy.tools.params.Config.get.\n- When you write a model and want to include a test that it can be at least constructed,\n  take a look at ``tests/test_model.py``.",
    "search_text": "doc.model_details --- documentation: model_details ---\ndetails on the implementation of models\n=======================================\n\nin this chapter, we provide some more detail on how models work, and how you might customize them.\nyou should probably read :doc:`/intro/model` first.\n\nwe distinguish three different ways in which the hamiltonian can be given, and there is a\nbase class for each one of them:\n\n1. in a tenpy.models.model.nearestneighbormodel, we have the hamiltonian as a sum of\n   two-body terms, which are stored explicitly as a list\n   of tenpy.linalg.np_conserved.array\\s.\n   this is the structure you need to do tebd with the model.\n2. in a tenpy.models.model.mpomodel, we have the hamiltonian directly given as a\n   tenpy.networks.mpo.mpo.\n   this is the structure you need to do dmrg, expmpoevolution or tdvp.\n3. in a tenpy.models.model.couplingmodel, the hamiltonian is given symbolically, in\n   the form of terms (see tenpy.networks.terms).\n   there are (currently) no algorithms in tenpy that require this particular structure.\n   we can view it more as a convenient way to specify models, which also allows us to\n   initialize the other two structures easily.\n\na custom model (as well as the pre-defined models in tenpy) should then inherit from all of the\nclasses that are applicable.\n\nif you define a tenpy.models.model.couplingmodel structure for the model, that class\noffers convenient methods to initialize the other two structures, as shown in more detail below.\nthere is a convenience class that achieves this directly, the tenpy.models.model.couplingmpomodel.\nit uses the same symbolical representation of the hamiltonian, but in contrast to the\nplain tenpy.models.model.couplingmodel, automates the initialization of the lattice and\nof the mpo. it also automatically initializes ``h_bond``, if it detects that the custom model\nis also a subclass of tenpy.models.model.nearestneighbormodel.\nthis means that there is virtually no explicit code needed, e.g. when the\ntenpy.models.tf_ising.tfimodel is specialized to the tenpy.models.tf_ising.tfichain.\n\nin the rest of this intro, we introduce the classes and their ways of initializing models in more detail.\n\n\nthe couplingmodel: general structure\n------------------------------------\n\nthe tenpy.models.model.couplingmodel provides a general, quite abstract way to specify a hamiltonian\nof couplings on a given lattice.\nonce initialized, its methods tenpy.models.couplingmodel.add_onsite and\ntenpy.models.model.couplingmodel.add_coupling allow to add onsite and coupling terms repeated over the different\nunit cells of the lattice.\nin that way, it basically allows a straight-forward translation of the hamiltonian given as a math formula\n:math:`h = \\sum_{i} a_i b_{i+dx} + ...` with onsite operators `a`, `b`,... into a model class.\n\nthe general structure for a new model based on the tenpy.models.model.couplingmodel is then::\n\n    class mynewmodel3(couplingmodel,mpomodel,nearestneighbormodel):\n        def __init__(self, ...):\n            ...  # follow the basic steps explained below\n\n\nin the initialization method ``__init__(self, ...)`` of this class you can then follow these basic steps:\n\n0. read out the parameters.\n1. given the parameters, determine the charges to be conserved.\n   initialize the tenpy.linalg.charges.legcharge of the local sites accordingly.\n2. define (additional) local operators needed.\n3. initialize the needed tenpy.networks.site.site.\n\n\n      using pre-defined sites like the tenpy.networks.site.spinhalfsite is recommended and\n      can replace steps 1-3.\n\n4. initialize the lattice (or if you got the lattice as a parameter, set the sites in the unit cell).\n5. initialize the tenpy.models.model.couplingmodel with ``couplingmodel.__init__(self, lat)``.\n6. use tenpy.models.model.couplingmodel.add_onsite and tenpy.models.model.couplingmodel.add_coupling\n   to add all terms of the hamiltonian. here, the tenpy.models.lattice.lattice.pairs of the lattice\n   can come in handy, for example::\n\n       self.add_onsite(-np.asarray(h), 0, 'sz')\n       for u1, u2, dx in self.lat.pairs['nearest_neighbors']:\n           self.add_coupling(0.5*j, u1, 'sp', u2, 'sm', dx, plus_hc=true)\n           self.add_coupling(    j, u1, 'sz', u2, 'sz', dx)\n\n\n      the method tenpy.models.model.couplingmodel.add_coupling adds the coupling only in one direction, i.e.\n      not switching `i` and `j` in a :math:`\\sum_{\\langle i, j\\rangle}`.\n      if you have terms like :math:`c^\\dagger_i c_j` or :math:`s^{+}_i s^{-}_j` in your hamiltonian,\n      you *need* to add it in both directions to get a hermitian hamiltonian!\n      the easiest way to do that is to use the `plus_hc` option of\n      tenpy.models.model.couplingmodel.add_onsite and tenpy.models.model.couplingmodel.add_coupling,\n      as we did for the :math:`j/2 (s^{+}_i s^{-}_j + h.c.)` terms of the heisenberg model above.\n      alternatively, you can add the hermitian conjugate terms explicitly, see the examples in\n      tenpy.models.model.couplingmodel.add_coupling for more details.\n\n   note that the `strength` arguments of these functions can be (numpy) arrays for site-dependent couplings.\n   if you need to add or multiply some parameters of the model for the `strength` of certain terms,\n   it is recommended use ``np.asarray`` beforehand -- in that way lists will also work fine.\n7. finally, if you derived from the tenpy.models.model.mpomodel, you can call\n   tenpy.models.model.couplingmodel.calc_h_mpo to build the mpo and use it for the initialization\n   as ``mpomodel.__init__(self, lat, self.calc_h_mpo())``.\n8. similarly, if you derived from the tenpy.models.model.nearestneighbormodel, you can call\n   tenpy.models.model.couplingmodel.calc_h_bond to initialize it\n   as ``nearestneighbormodel.__init__(self, lat, self.calc_h_bond())``.\n   calling ``self.calc_h_bond()`` will fail for models which are not nearest-neighbors (with respect to the mps ordering),\n   so you should only subclass the tenpy.models.model.nearestneighbormodel if the lattice is a simple\n   tenpy.models.lattice.chain.\n\n\n    the method tenpy.models.model.couplingmodel.add_coupling works only for terms involving operators on 2\n    sites. if you have couplings involving more than two sites, you can use the\n    tenpy.models.model.couplingmodel.add_multi_coupling instead.\n    a prototypical example is the exactly solvable tenpy.models.toric_code.toriccode.\n\n\nthe code of the module tenpy.models.xxz_chain is included below as an illustrative example how to implement a\nmodel. the implementation of the tenpy.models.xxz_chain.xxzchain directly follows the steps\noutline above.\nthe tenpy.models.xxz_chain.xxzchain2 implements the very same model, but based on the\ntenpy.models.model.couplingmpomodel explained in the next section.\n\n\n\nthe easiest way: the couplingmpomodel\n-------------------------------------\nsince many of the basic steps above are always the same, we don't need to repeat them all the time.\nso we have yet another class helping to structure the initialization of models: the tenpy.models.model.couplingmpomodel.\nthe general structure of this class is like this::\n\n    class couplingmpomodel(couplingmodel,mpomodel):\n        default_lattice = \"chain\"\n        \"\n\n        def __init__(self, model_param):\n            # ... follows the basic steps 1-8 using the methods\n            lat = self.init_lattice(self, model_param)  # for step 4\n            # ...\n            self.init_terms(self, model_param) # for step 6\n            # ...\n\n        def init_sites(self, model_param):\n            # you should overwrite this in most cases to ensure\n            # getting the site(s) and charge conservation you want\n            site = spinsite(...)  # or fermionsite, bosonsite, ...\n            return site  # (or tuple of sites)\n\n        def init_lattice(self, model_param):\n            sites = self.init_sites(self, model_param) # for steps 1-3\n            # and then read out the class attribute `default_lattice`,\n            # initialize an arbitrary pre-defined lattice\n            # using model_params['lattice']\n            # and ensure it's the default lattice if the class attribute\n            # `force_default_lattice` is true.\n\n        def init_terms(self, model_param):\n            # does nothing.\n            # you should overwrite this\n\nthe tenpy.models.xxz_chain.xxzchain2 included above illustrates, how it can be used.\nyou need to implement steps 1-3) by overwriting the method tenpy.models.model.couplingmpomodel.init_sites\nstep 4) is performed in the method tenpy.models.model.couplingmpomodel.init_lattice, which initializes arbitrary 1d or 2d\nlattices; by default a simple 1d chain.\nif your model only works for specific lattices, you can overwrite this method in your own class.\nstep 6) should be done by overwriting the method tenpy.models.model.couplingmpomodel.init_terms.\nsteps 5,7,8 and calls to the `init_...` methods for the other steps are done automatically if you just call the\n``couplingmpomodel.__init__(self, model_param)``.\n\nthe tenpy.models.xxz_chain.xxzchain and tenpy.models.xxz_chain.xxzchain2 work only with the\ntenpy.models.lattice.chain as lattice, since they are derived from the tenpy.models.model.nearestneighbormodel.\nthis allows to use them for tebd in 1d (yeah!), but we can't get the mpo for dmrg on (for example) a tenpy.models.lattice.square\nlattice cylinder - although it's intuitively clear, what the hamiltonian there should be: just put the nearest-neighbor\ncoupling on each bond of the 2d lattice.\n\nit's not possible to generalize a tenpy.models.model.nearestneighbormodel to an arbitrary lattice where it's\nno longer nearest neighbors in the mps sense, but we can go the other way around:\nfirst write the model on an arbitrary 2d lattice and then restrict it to a 1d chain to make it a tenpy.models.model.nearestneighbormodel.\n\nlet me illustrate this with another standard example model: the transverse field ising model, implemented in the module\ntenpy.models.tf_ising included below.\nthe tenpy.models.tf_ising.tfimodel works for arbitrary 1d or 2d lattices.\nthe tenpy.models.tf_ising.tfichain is then taking the exact same model making a tenpy.models.model.nearestneighbormodel,\nwhich only works for the 1d chain.\n\n\n\nautomation of hermitian conjugation\n-----------------------------------\nas most physical hamiltonians are hermitian, these hamiltonians are fully determined when only half of the mutually conjugate terms is defined. for example, a simple hamiltonian:\n\n        h = \\sum_{\\langle i,j\\rangle, i<j}\n              - \\mathtt{j} (c^{\\dagger}_i c_j + c^{\\dagger}_j c_i)\n\nis fully determined by the term :math:`c^{\\dagger}_i c_j` if we demand that hermitian conjugates are included automatically.\nin tenpy, whenever you add a coupling using tenpy.models.model.couplingmodel.add_onsite,\ntenpy.models.model.couplingmodel.add_coupling, or tenpy.models.model.couplingmodel.add_multi_coupling,\nyou can use the optional argument `plus_hc` to automatically create and add the hermitian conjugate of that coupling term - as shown above.\n\nadditionally, in an mpo, explicitly adding both a non-hermitian term and its conjugate increases the bond dimension of the mpo, which increases the memory requirements of the tenpy.networks.mpo.mpoenvironment.\ninstead of adding the conjugate terms explicitly, you can set a flag `explicit_plus_hc` in the tenpy.models.model.mpocouplingmodel parameters, which will ensure two things:\n\n1. the model and the mpo will only store half the terms of each hermitian conjugate pair added, but the flag `explicit_plus_hc` indicates that they *represent* `self + h.c.`.\n   in the example above, only the term :math:`c^{\\dagger}_i c_j` would be saved.\n2. at runtime during dmrg, the hermitian conjugate of the (now non-hermitian) mpo will be computed and applied along with the mpo, so that the effective hamiltonian is still hermitian.\n\n\n    the model flag `explicit_plus_hc` should be used in conjunction with the flag `plus_hc` in tenpy.models.model.couplingmodel.add_coupling or tenpy.models.model.couplingmodel.add_multi_coupling.\n    if `plus_hc` is `false` while `explicit_plus_hc` is `true` the mpo bond dimension will not be reduced, but you will still pay the additional computational cost of computing the hermitian conjugate at runtime.\n\nthus, we end up with several use cases, depending on your preferences.\nconsider the tenpy.models.fermions_spinless.fermionmodel.\nif you do not care about the mpo bond dimension, and want to add hermitian conjugate terms manually, you would set `model_par['explicit_plus_hc'] = false` and write::\n\n    self.add_coupling(-j, u1, 'cd', u2, 'c', dx)\n    self.add_coupling(np.conj(-j), u2, 'cd', u1, 'c', -dx)\n\nif you wanted to save the trouble of the extra line of code (but still did not care about mpo bond dimension), you would keep the `model_par`, but instead write::\n\n    self.add_coupling(-j, u1, 'cd', u2, 'c', dx, plus_hc=true)\n\nfinally, if you wanted a reduction in mpo bond dimension, you would need to set `model_par['explicit_plus_hc'] = true`, and write::\n\n    self.add_coupling(-j, u1, 'cd', u2, 'c', dx, plus_hc=true)\n\n\nnon-uniform terms and couplings\n-------------------------------\nthe couplingmodel-methods tenpy.models.model.couplingmodel.add_onsite, tenpy.models.model.couplingmodel.add_coupling,\nand tenpy.models.model.couplingmodel.add_multi_coupling add a sum over a \"coupling\" term shifted by lattice\nvectors. however, some models are not that \"uniform\" over the whole lattice.\n\nfirst of all, you might have some local term that gets added only at one specific location in the lattice.\nyou can add such a term for example with tenpy.models.model.couplingmodel.add_local_term.\n\nsecond, if you have irregular lattices, take a look at the corresponding section in :doc:`/intro/lattices`.\n\nfinally, note that the argument `strength` for the `add_onsite`, `add_coupling`, and `add_multi_coupling` methods\ncan not only be a numpy scalar, but also a (numpy) array.\nin general, the sum performed by the methods runs over the given term\nshifted by lattice vectors *as far as possible to still fit the term into the lattice*.\n\nfor the tenpy.models.model.couplingmodel.add_onsite case this criterion is simple: there is exactly one site in each lattice unit cell with the `u` specified as separate argument, so the correct shape for the `strength` array is simply given by tenpy.models.lattice.lattice.ls.\nfor example, if you want the defacto standard model studied for many-body localization, a heisenberg chain with random , uniform onsite field :math:`h^z_i \\in [-w, w]`,\n\n\n    h = j \\sum_{i=0}^{l-1} \\vec{s}_i \\cdot \\vec{s}_{i+1} - \\sum_{i=0}^{l} h^z_i s^z_i\n\nyou can use the tenpy.models.spins.spinchain with the following model parameters::\n\n    l = 30 # or whatever you like...\n    w = 5.  # mbl transition at w_c ~= 3.5 j\n    model_params = {\n        'l': l,\n        'jx': 1., 'jy': 1., 'jz': 1.,\n        'hz': 2.*w*(np.random.random(l) - 0.5),  # random values in [-w, w], shape (l,)\n        'conserve': 'best',\n    }\n    m = tenpy.models.spins.spinchain(model_params)\n\nfor tenpy.models.model.couplingmodel.add_coupling and tenpy.models.model.couplingmodel.add_multi_coupling,\nthings become a little bit more complicated, and the correct shape of the `strength` array depends not only on the tenpy.models.lattice.lattice.ls\nbut also on the boundary conditions of the lattice. given a term, you can call\ntenpy.models.lattice.lattice.coupling_shape and tenpy.models.lattice.lattice.multi_coupling_shape to find out the correct shape for `strength`.\nto avoid any ambiguity, the shape of the `strength` always has to fit, at least after a tiling performed by tenpy.tools.misc.to_array.\n\nfor example, consider the su-schrieffer-heeger model, a spin-less tenpy.models.fermions.fermionchain with hopping strength alternating between two values, say `t1` and `t2`.\nyou can generate this model for example like this::\n\n    l = 30 # or whatever you like...\n    t1, t2 = 0.5, 1.5\n    t_array = np.array([(t1 if i % 2 == 0 else t2) for i in range(l-1)])\n    model_params = {\n        'l': l,\n        't': t_array,\n        'v': 0., 'mu': 0.,  # just free fermions, but you can generalize...\n        'conserve': 'best'\n    }\n    m = tenpy.models.fermions.fermionchain(model_params)\n\n\nsome random remarks on models\n-----------------------------\n\n- needless to say that we have also various predefined models under tenpy.models.\n- if you want to use random parameters, you should use ``model.rng`` as a random number generator and change ``model_params['random_seed']`` for different configurations.\n- of course, an mpo is all you need to initialize a tenpy.models.model.mpomodel to be used for dmrg; you don't have to use the tenpy.models.model.couplingmodel\n  or tenpy.models.model.couplingmpomodel.\n  for example, we build the model directly from an mpo in ``examples/mpo_exponentially_decaying.py``.\n  the tenpy.models.aklt.akltchain is another example which is directly constructed from the `h_bond` terms.\n- we suggest writing the model to take a single parameter dictionary for the initialization,\n  as the tenpy.models.model.couplingmpomodel does.\n  the tenpy.models.model.couplingmpomodel converts the dictionary to a dict-like\n  tenpy.tools.params.config with some additional features before passing it on to the `init_lattice`,\n  `init_site`, ... methods.\n  it is recommended to read out providing default values with ``model_params.get(\"key\", default_value)``,\n  see tenpy.tools.params.config.get.\n- when you write a model and want to include a test that it can be at least constructed,\n  take a look at ``tests/test_model.py``. tutorial documentation model_details",
    "tokens": 4430
  },
  {
    "category": "tutorials",
    "name": "doc.simulations",
    "content": "--- DOCUMENTATION: simulations ---\nSimulations\n===========\n\nWhat is a simulation?\n---------------------\n\nSimulations provide the highest-level interface in TeNPy.\nThey represent one simulation from start (initializing the various classes from given parameters) to end (saving the results to a file).\nThe idea is that they contain the full package of code that you run by a job on a computing cluster.\n(You don't have to stick to that rule, of course.)\nIn fact, any simulation can be run from the command line, given only a parameter file as input, like this::\n\n   python -m tenpy parameters.yml\n   # or alternatively, if tenpy is installed correctly:\n   tenpy-run parameters.yml\n\n   # equivalent to calling `tenpy.console_main(\"parameters.yml\")` from within python\n\nYou need to specify somewhere what type of simulation you want to run. Often, one of the predefined ones like\nthe tenpy.simulations.ground_state_search.GroundStateSearch for running DMRG or\ntenpy.simulations.time_evolution.RealTimeEvolution for running e.g. TEBD or TDVP will suffice.\nThe tenpy.simulations.simulation.Simulation class can be specified with the `simulation_class` option in the yaml file, or directly as a command line\nargument, e.g. ``tenpy-run -C GroundStateSearch parameters.yml``.\nNote that command line arguments possibly override entries in the yaml files.\nFor more details, see tenpy.console_main for the command-line interface.\n\nOf course, you can also directly run the simulation from inside python, the command line call is essentially just a wrapper around the tenpy.run_simulation python interface::\n\n    import tenpy\n\n    simulation_params = tenpy.load_yaml_with_py_eval(\"parameters.yml\")\n    # instead of using yaml, you can also define a usual python dictionary\n    tenpy.run_simulation(**simulation_params)\n\nOr as a single line::\n\n    tenpy.console_main(\"parameters.yml\")\n\nTo have self-contained jupyter notebook examples, the following pattern might be useful::\n\n    simulation_params = tenpy.load_yaml_with_py_eval(yaml_content=\"\"\"\n    SimulationClass: GroundStateSearch\n    ...\n    \"\"\")\n    tenpy.run_simulation(**simulation_params)\n\n\nAn minimal example to run finite DMRG for a Spin-1/2 Heisenberg tenpy.models.spins.SpinChain could be given by\n\n\n\nParallelization: controlling the number of threads\n--------------------------------------------------\nAlmost all of the TeNPy code is \"only\" using thread-based parallelization provided by the underlying LAPACK/BLAS package linked to by Numpy/Scipy, and/or TeNPy's Cython code when you compile it.\n(A notable exception is the tenpy.tools.cache.ThreadedStorage for caching.)\nIn practice, you can control the number of threads in the same way as if you use just plain numpy - by default, this uses all the CPU cores on a given machine.\n\nIf you run things on a cluster, it is often required to only use a fixed number of cores. Assuming a standard Linux cluster, the easiest way to control the used number of threads is usually the OMP_NUM_THREADS environment variable, which you can set in your cluster submission script:\n\n\n    export OMP_NUM_THREADS=4\n    python -m tenpy parameters.yml\n\nIf you linked against MKL, you can use ``export MKL_NUM_THREADS=4`` instead. In some cases, it might also be necessary to additionally ``export MKL_DYNAMIC=FALSE``.\nUniversities usually have some kind of local cluster documentation with examples - try to follow those, and double check\nthat you only use the cores you request.\n\n\nCustomizing parameters\n----------------------\n\nThe most straight-forward way to customize a simulation is to tweak and adjust the parameters to your needs.\nAs you can see in the above example, the parameters are organized in a hierarchical structure, following roughly the\nsame level structure as discussed in the :doc:`/intro/overview`.\n\nThe allowed options on the top level are documented in the corresponding simulation class, e.g. the\ntenpy.simulations.ground_state_search.GroundStateSearch.\n\nThe allowed entries in the `model_params` section depend on the `model_class`:\nClearly, the tenpy.models.spins.SpinChain in the example above requires a different set of specified\ncoupling parameters than, e.g., the tenpy.models.hubbard.FermiHubbardModel.\nThe base model classes like the tenpy.models.models.model.CouplingMPOModel have a common set of parameters\nusually read out, but custom model implementations can override this and/or add additional parameters.\nThe list of allowed parameters can hence be found in the documentation of the most specialized class that you use, e.g.,\nthe tenpy.models.tf_ising.TFIChain above.\n\nSimilarly, allowed values in the `algorithm_params` section depend on the used `algorithm_class`.\n\n\nTo get the full set of used options, it can be convenient to simply run the algorithm\n(for debugging parameters to allow a very quick run) and look at the ``results['simulation_parameters']``\nreturned by the simulation (or saved to file):\n\n\n    import tenpy\n    from pprint import pprint\n    import yaml\n\n    with open('parameters.yml', 'r') as stream:\n        simulation_parameters = tenpy.load_yaml_with_py_eval(stream)\n    # alternative: simulation_parameters = tenpy.load_yaml_with_py_eval('parameters.yml')\n    results = tenpy.run_simulation(simulation_parameters)\n    pprint(results['simulation_parameters'])\n\n\n    You can find a **list of all the different configs** in the cfg-config-index, and a **list of all parameters** in cfg-option-index.\n\n\n    If you add extra options to your configuration that TeNPy doesn't read out by the end of the simulation, it will (usually) issue a warning.\n    Getting such a warnings is often an indicator for a typo in your configuration, or an option being in the wrong section.\n\n\nAdjusting the output\n--------------------\nIf specified, output files are saved in a given :cfgSimulation.directory.\nAs shown in the parameter example above, you can simply give an :cfgSimulation.output_filename parameter.\nAlternatively, one can specify the :cfgSimulation.output_filename_params to make the filename depend on other\nsimulation parameters (specified as keys of the `parts`), e.g:\n\n\n    directory: results\n    output_filename_params:\n        prefix: dmrg\n        parts:\n            algorithm_params.trunc_params.chi_max: 'chi_{0:04d}'\n            model_params.L: 'L_{0:d}'\n        suffix: .h5\n\nWith the above example parameters, this would yield the output filename ``results/dmrg_chi_0100_L_16.h5``; further examples in the\ndocumentation of tenpy.simulations.simulation.output_filename_from_dict.\n\nNote that TeNPy will not overwrite output unless you explicitly set :cfgSimulation.overwrite_output to ``True``.\nRather, it will modify the filename with extra numbers, e.g., ``file.h5, file_1.h5, file_2.h5, ...``, or it will raise a\nspecific tenpy.simulations.simulation.Skip exception if :cfgSimulation.skip_if_output_exists is set.\nFurther, temporary ``.backup.h5`` files are used while saving to avoid loosing previous results in case of a crash during the save.\n\nThe option :cfgSimulation.save_psi allows to enable (default) or disable saving the full tensor network at the end of the simulation - note this drastically influences the size of the output file!\nFor long-running simulations you can decide to save intermediate checkpoints with the option :cfgSimulation.save_every_x_seconds; see the resume_details_ section below.\n\nLog files by default use the same filename as the output but with the extension ``.log``, see :doc:`/intro/logging` for more details.\nIn practice, it is useful only print warnings and errors to stdout to allow a simple check for errors, while the ``.log`` files can then be used to follow the details and progress of the simulation:\n\n\n    log_params:\n        to_file: INFO\n        to_stdout: WARN\n        # format: \"{levelname:.4s} {asctime} {message}\"\n\n\n    Always check errors and warnings! In most simulations, there shouldn't be any warnings left.\n\n\nAnalyzing the results post simulation: output structure\n-------------------------------------------------------\nA simulation usually generates an output file that can be loaded with the tenpy.tools.hdf5_io.load function.\nIt is usually either in the pickle or HDF5 format, see :doc:`/intro/input_output` for more details.\n\nThe ability to keep code snippets and plots together in [jupyter]_ notebooks makes them a very convenient environment for analyzing results.\nThere are a bunch of jupyter notebooks in the :doc:`/examples` that you can look at for inspiration.\n\nThe `results` returned by tenpy.run_simulation are a (nested) dictionary.\nThe general structure is listed in tenpy.simulations.simulation.Simulation.results.\nPossible entries depend on the simulation class run, and some options like `save_psi` or specified measurements.\n\nLet us consider our initial DMRG example.\nThe tenpy.simulations.ground_state_search.GroundStateSearch performs two measurements: one on the initial\nstate (unless disabled with :cfgmeasure_initial and one on the final state.\nFurther, MPS-based simulations by default measure the entanglement entropies for cutting at the various MPS bonds,\nsuch that we can read out the final half-chain entanglement entropy like this::\n\n    >>> import tenpy\n    >>> results = tenpy.tools.hdf5_io.load('results/dmrg_chi_0100_L_32.h5')\n    >>> L = results['simulation_parameters']['model_params']['L']\n    >>> L\n    32\n    >>> print(results['measurements']['entropy'].shape)\n    (2, 31)\n    >>> print(results['measurements']['entropy'][-1, (L-1)//2])\n\nHere, the shape of the entropy array is ``(2, 31)`` since 2 is the number of measurements\n(one on the initial state, one on the final ground state), and 31=L-1 the number of bonds.\nNote that you can easily read out the simulation parameters, even default ones that are only implicitly defined\nsomewhere in the code!\n\n\nAdding more measurements\n------------------------\nMost simulation classes have only a few tenpy.simulations.Simulation.default_measurements, but you can easily\nadd more with the :cfgSimulation.connect_measurements parameters. Each measurement is simply a function that is\ncalled whenever the simulation wants to measure, e.g. with the initial state, at the end of the simulation, and for time\nevolutions also during the evolution. The default measurement functions are defined in\nthe module tenpy.simulations.measurement; tenpy.simulations.measurement.m_measurement_index documents what\narguments a measurement function should have.\nIn the simplest case, you just specify the module and function name, but you can also add more arguments, as the\nfollowing example shows.\n\n\n    connect_measurements:\n      - - tenpy.simulations.measurement\n        - m_onsite_expectation_value\n        - opname: Sz\n      - - psi_method\n        - wrap correlation_function\n        - results_key: '<Sp_i Sm_j>'\n          ops1: Sp\n          ops2: Sm\n\nNote the indentation and minus signs here: this yaml syntax is equivalent to the following python structure:\n\n\n    {'connect_measurements': [['tenpy.simulations.measurement',\n                               'm_onsite_expectation_value',\n                               {'opname': 'Sz'}],\n                              ['psi_method',\n                               'wrap correlation_function',\n                               {'results_key': '<Sp_i Sm_j>',\n                                'ops1': 'Sp',\n                                'ops2': 'Sm'}]]}\n\nThe measurement functions add the values under the specified `key` to the `results` returned and saved by the\nsimulation, e.g. for the above measurements you can now read out ``results['measurements']['<Sz>']`` (default key) and ``results['measurements']['<Sp_i Sm_j>']``.\n\n\n    For more details, see the extra guide :doc:`/intro/measurements`.\n\n\nA full example with custom python code\n--------------------------------------\n\nWhile there are plenty of predefined models and algorithms, there is a good chance that you need to tweak and adjust\nthem further by writing your own python code. Examples could be custom models and/or lattices, measurement functions, or\neven adjustments to any other class (tensor networks, algorithms, simulations...).\n\nAs a concrete example, let's try to reproduce some results of pollmann2012, namely the :math:`\\mathcal{O}_I` defined in eq. (15) of that paper.\nA new model class is not strictly necessary, one can also select appropriate parameters for the tenpy.models.spins.SpinChain, but we include it here for completeness.\nDetails on how to define a custom model class can be found in :doc:`/intro/model`.\n\n\nThe corresponding `simulation_custom.yml` parameter file, collecting the snippets above, could then look like this:\n\n\nNote that we explicitly specified the module `model_custom` for the additional measurement; you need to adjust that if\nyou rename the `model_custom.py` file.\nYou can then run this simulation, say for three different `D` values specified directly on the command line::\n\n    tenpy-run -i model_custom simulation_custom.yml -o model_params.D 0.\n    tenpy-run -i model_custom simulation_custom.yml -o model_params.D 1.5\n    tenpy-run -i model_custom simulation_custom.yml -o model_params.D -1.0\n\n\n\n    If you use the setup from the [TeNPyProjectTemplate]_ repository, the ``cluster_jobs.py`` helps to manage submitting\n    jobs with similar parameters to a computing cluster;\n    it includes this very example as a starting point for customization.\n\n\n\nCheckpoints for resuming a simulation\n-------------------------------------\nAs mentioned above, you can save intermediate results with the option :cfgsave_every_x_seconds.\nMoreover, you need to have :cfgSimulation.save_psi and :cfgSimulation.save_resume_data enabled::\n\n    save_every_x_seconds: 1800\n    save_psi: True\n    save_resume_data: True\n\nIf this is the case, the simulation will save the current status at certain \"checkpoints\" defined by the algorithm,\ne.g., in DMRG at the end of a sweep.\nThe checkpoints are saved to the same filename as the desired final output file, and get overwritten by each following save at a checkpoint.\nYou can check ``results['finished']`` in the output file to see whether it finished.\n\nYou can then resume the simulation using the function tenpy.resume_from_checkpoint.\n\nNote that you can also adjust parameters for the resume.\nFor example, if you find that a DMRG result (even a finished one) is not yet fully converged in bond dimension, you can \"resume\" the simulation\nwith a larger bond dimension and a new output filename.\nFor DMRG, this is roughly equivalent to starting a new simulation with the initial state loaded\ntenpy.networks.mps.InitialStateBuilder.from_file; but it can reuse more than just the state, e.g., environments and already performed measurements, or the `evolved_time` of a time evolution.\n\n\nSequential simulations\n----------------------\nInstead of waiting for one simulation to finish and \"resuming\" another one with slightly different parameters, you can\nalso directly specify a set of \"sequential\" simulations where the output/results of one simulation are reused for the\nnext one. This can be particularly useful to \"adiabatically\" follow the ground state when tuning model parameters, in\nparticular for flux pump experiments, or to get a stable scaling with bond dimension.\n\nTo achieve this, you need to call tenpy.run_seq_simulations instead of just tenpy.run_simulation, and\nspecify the :cfgsequential parameters for the simulation (at the top level of the yaml files), in particular\nthe `recursive_keys` for the parameters to be changed. The values for those parameters can be specified as\n:cfgsequential.value_lists, or as lists in the original location of the yaml file.\n\n\n    sequential:\n        recursive_keys:\n            - algorithm_params.trunc_params.chi_max\n\n    algorithm_params:\n        trunc_params:\n            chi_max: [128, 256, 512]",
    "search_text": "doc.simulations --- documentation: simulations ---\nsimulations\n===========\n\nwhat is a simulation?\n---------------------\n\nsimulations provide the highest-level interface in tenpy.\nthey represent one simulation from start (initializing the various classes from given parameters) to end (saving the results to a file).\nthe idea is that they contain the full package of code that you run by a job on a computing cluster.\n(you don't have to stick to that rule, of course.)\nin fact, any simulation can be run from the command line, given only a parameter file as input, like this::\n\n   python -m tenpy parameters.yml\n   # or alternatively, if tenpy is installed correctly:\n   tenpy-run parameters.yml\n\n   # equivalent to calling `tenpy.console_main(\"parameters.yml\")` from within python\n\nyou need to specify somewhere what type of simulation you want to run. often, one of the predefined ones like\nthe tenpy.simulations.ground_state_search.groundstatesearch for running dmrg or\ntenpy.simulations.time_evolution.realtimeevolution for running e.g. tebd or tdvp will suffice.\nthe tenpy.simulations.simulation.simulation class can be specified with the `simulation_class` option in the yaml file, or directly as a command line\nargument, e.g. ``tenpy-run -c groundstatesearch parameters.yml``.\nnote that command line arguments possibly override entries in the yaml files.\nfor more details, see tenpy.console_main for the command-line interface.\n\nof course, you can also directly run the simulation from inside python, the command line call is essentially just a wrapper around the tenpy.run_simulation python interface::\n\n    import tenpy\n\n    simulation_params = tenpy.load_yaml_with_py_eval(\"parameters.yml\")\n    # instead of using yaml, you can also define a usual python dictionary\n    tenpy.run_simulation(**simulation_params)\n\nor as a single line::\n\n    tenpy.console_main(\"parameters.yml\")\n\nto have self-contained jupyter notebook examples, the following pattern might be useful::\n\n    simulation_params = tenpy.load_yaml_with_py_eval(yaml_content=\"\"\"\n    simulationclass: groundstatesearch\n    ...\n    \"\"\")\n    tenpy.run_simulation(**simulation_params)\n\n\nan minimal example to run finite dmrg for a spin-1/2 heisenberg tenpy.models.spins.spinchain could be given by\n\n\n\nparallelization: controlling the number of threads\n--------------------------------------------------\nalmost all of the tenpy code is \"only\" using thread-based parallelization provided by the underlying lapack/blas package linked to by numpy/scipy, and/or tenpy's cython code when you compile it.\n(a notable exception is the tenpy.tools.cache.threadedstorage for caching.)\nin practice, you can control the number of threads in the same way as if you use just plain numpy - by default, this uses all the cpu cores on a given machine.\n\nif you run things on a cluster, it is often required to only use a fixed number of cores. assuming a standard linux cluster, the easiest way to control the used number of threads is usually the omp_num_threads environment variable, which you can set in your cluster submission script:\n\n\n    export omp_num_threads=4\n    python -m tenpy parameters.yml\n\nif you linked against mkl, you can use ``export mkl_num_threads=4`` instead. in some cases, it might also be necessary to additionally ``export mkl_dynamic=false``.\nuniversities usually have some kind of local cluster documentation with examples - try to follow those, and double check\nthat you only use the cores you request.\n\n\ncustomizing parameters\n----------------------\n\nthe most straight-forward way to customize a simulation is to tweak and adjust the parameters to your needs.\nas you can see in the above example, the parameters are organized in a hierarchical structure, following roughly the\nsame level structure as discussed in the :doc:`/intro/overview`.\n\nthe allowed options on the top level are documented in the corresponding simulation class, e.g. the\ntenpy.simulations.ground_state_search.groundstatesearch.\n\nthe allowed entries in the `model_params` section depend on the `model_class`:\nclearly, the tenpy.models.spins.spinchain in the example above requires a different set of specified\ncoupling parameters than, e.g., the tenpy.models.hubbard.fermihubbardmodel.\nthe base model classes like the tenpy.models.models.model.couplingmpomodel have a common set of parameters\nusually read out, but custom model implementations can override this and/or add additional parameters.\nthe list of allowed parameters can hence be found in the documentation of the most specialized class that you use, e.g.,\nthe tenpy.models.tf_ising.tfichain above.\n\nsimilarly, allowed values in the `algorithm_params` section depend on the used `algorithm_class`.\n\n\nto get the full set of used options, it can be convenient to simply run the algorithm\n(for debugging parameters to allow a very quick run) and look at the ``results['simulation_parameters']``\nreturned by the simulation (or saved to file):\n\n\n    import tenpy\n    from pprint import pprint\n    import yaml\n\n    with open('parameters.yml', 'r') as stream:\n        simulation_parameters = tenpy.load_yaml_with_py_eval(stream)\n    # alternative: simulation_parameters = tenpy.load_yaml_with_py_eval('parameters.yml')\n    results = tenpy.run_simulation(simulation_parameters)\n    pprint(results['simulation_parameters'])\n\n\n    you can find a **list of all the different configs** in the cfg-config-index, and a **list of all parameters** in cfg-option-index.\n\n\n    if you add extra options to your configuration that tenpy doesn't read out by the end of the simulation, it will (usually) issue a warning.\n    getting such a warnings is often an indicator for a typo in your configuration, or an option being in the wrong section.\n\n\nadjusting the output\n--------------------\nif specified, output files are saved in a given :cfgsimulation.directory.\nas shown in the parameter example above, you can simply give an :cfgsimulation.output_filename parameter.\nalternatively, one can specify the :cfgsimulation.output_filename_params to make the filename depend on other\nsimulation parameters (specified as keys of the `parts`), e.g:\n\n\n    directory: results\n    output_filename_params:\n        prefix: dmrg\n        parts:\n            algorithm_params.trunc_params.chi_max: 'chi_{0:04d}'\n            model_params.l: 'l_{0:d}'\n        suffix: .h5\n\nwith the above example parameters, this would yield the output filename ``results/dmrg_chi_0100_l_16.h5``; further examples in the\ndocumentation of tenpy.simulations.simulation.output_filename_from_dict.\n\nnote that tenpy will not overwrite output unless you explicitly set :cfgsimulation.overwrite_output to ``true``.\nrather, it will modify the filename with extra numbers, e.g., ``file.h5, file_1.h5, file_2.h5, ...``, or it will raise a\nspecific tenpy.simulations.simulation.skip exception if :cfgsimulation.skip_if_output_exists is set.\nfurther, temporary ``.backup.h5`` files are used while saving to avoid loosing previous results in case of a crash during the save.\n\nthe option :cfgsimulation.save_psi allows to enable (default) or disable saving the full tensor network at the end of the simulation - note this drastically influences the size of the output file!\nfor long-running simulations you can decide to save intermediate checkpoints with the option :cfgsimulation.save_every_x_seconds; see the resume_details_ section below.\n\nlog files by default use the same filename as the output but with the extension ``.log``, see :doc:`/intro/logging` for more details.\nin practice, it is useful only print warnings and errors to stdout to allow a simple check for errors, while the ``.log`` files can then be used to follow the details and progress of the simulation:\n\n\n    log_params:\n        to_file: info\n        to_stdout: warn\n        # format: \"{levelname:.4s} {asctime} {message}\"\n\n\n    always check errors and warnings! in most simulations, there shouldn't be any warnings left.\n\n\nanalyzing the results post simulation: output structure\n-------------------------------------------------------\na simulation usually generates an output file that can be loaded with the tenpy.tools.hdf5_io.load function.\nit is usually either in the pickle or hdf5 format, see :doc:`/intro/input_output` for more details.\n\nthe ability to keep code snippets and plots together in [jupyter]_ notebooks makes them a very convenient environment for analyzing results.\nthere are a bunch of jupyter notebooks in the :doc:`/examples` that you can look at for inspiration.\n\nthe `results` returned by tenpy.run_simulation are a (nested) dictionary.\nthe general structure is listed in tenpy.simulations.simulation.simulation.results.\npossible entries depend on the simulation class run, and some options like `save_psi` or specified measurements.\n\nlet us consider our initial dmrg example.\nthe tenpy.simulations.ground_state_search.groundstatesearch performs two measurements: one on the initial\nstate (unless disabled with :cfgmeasure_initial and one on the final state.\nfurther, mps-based simulations by default measure the entanglement entropies for cutting at the various mps bonds,\nsuch that we can read out the final half-chain entanglement entropy like this::\n\n    >>> import tenpy\n    >>> results = tenpy.tools.hdf5_io.load('results/dmrg_chi_0100_l_32.h5')\n    >>> l = results['simulation_parameters']['model_params']['l']\n    >>> l\n    32\n    >>> print(results['measurements']['entropy'].shape)\n    (2, 31)\n    >>> print(results['measurements']['entropy'][-1, (l-1)//2])\n\nhere, the shape of the entropy array is ``(2, 31)`` since 2 is the number of measurements\n(one on the initial state, one on the final ground state), and 31=l-1 the number of bonds.\nnote that you can easily read out the simulation parameters, even default ones that are only implicitly defined\nsomewhere in the code!\n\n\nadding more measurements\n------------------------\nmost simulation classes have only a few tenpy.simulations.simulation.default_measurements, but you can easily\nadd more with the :cfgsimulation.connect_measurements parameters. each measurement is simply a function that is\ncalled whenever the simulation wants to measure, e.g. with the initial state, at the end of the simulation, and for time\nevolutions also during the evolution. the default measurement functions are defined in\nthe module tenpy.simulations.measurement; tenpy.simulations.measurement.m_measurement_index documents what\narguments a measurement function should have.\nin the simplest case, you just specify the module and function name, but you can also add more arguments, as the\nfollowing example shows.\n\n\n    connect_measurements:\n      - - tenpy.simulations.measurement\n        - m_onsite_expectation_value\n        - opname: sz\n      - - psi_method\n        - wrap correlation_function\n        - results_key: '<sp_i sm_j>'\n          ops1: sp\n          ops2: sm\n\nnote the indentation and minus signs here: this yaml syntax is equivalent to the following python structure:\n\n\n    {'connect_measurements': [['tenpy.simulations.measurement',\n                               'm_onsite_expectation_value',\n                               {'opname': 'sz'}],\n                              ['psi_method',\n                               'wrap correlation_function',\n                               {'results_key': '<sp_i sm_j>',\n                                'ops1': 'sp',\n                                'ops2': 'sm'}]]}\n\nthe measurement functions add the values under the specified `key` to the `results` returned and saved by the\nsimulation, e.g. for the above measurements you can now read out ``results['measurements']['<sz>']`` (default key) and ``results['measurements']['<sp_i sm_j>']``.\n\n\n    for more details, see the extra guide :doc:`/intro/measurements`.\n\n\na full example with custom python code\n--------------------------------------\n\nwhile there are plenty of predefined models and algorithms, there is a good chance that you need to tweak and adjust\nthem further by writing your own python code. examples could be custom models and/or lattices, measurement functions, or\neven adjustments to any other class (tensor networks, algorithms, simulations...).\n\nas a concrete example, let's try to reproduce some results of pollmann2012, namely the :math:`\\mathcal{o}_i` defined in eq. (15) of that paper.\na new model class is not strictly necessary, one can also select appropriate parameters for the tenpy.models.spins.spinchain, but we include it here for completeness.\ndetails on how to define a custom model class can be found in :doc:`/intro/model`.\n\n\nthe corresponding `simulation_custom.yml` parameter file, collecting the snippets above, could then look like this:\n\n\nnote that we explicitly specified the module `model_custom` for the additional measurement; you need to adjust that if\nyou rename the `model_custom.py` file.\nyou can then run this simulation, say for three different `d` values specified directly on the command line::\n\n    tenpy-run -i model_custom simulation_custom.yml -o model_params.d 0.\n    tenpy-run -i model_custom simulation_custom.yml -o model_params.d 1.5\n    tenpy-run -i model_custom simulation_custom.yml -o model_params.d -1.0\n\n\n\n    if you use the setup from the [tenpyprojecttemplate]_ repository, the ``cluster_jobs.py`` helps to manage submitting\n    jobs with similar parameters to a computing cluster;\n    it includes this very example as a starting point for customization.\n\n\n\ncheckpoints for resuming a simulation\n-------------------------------------\nas mentioned above, you can save intermediate results with the option :cfgsave_every_x_seconds.\nmoreover, you need to have :cfgsimulation.save_psi and :cfgsimulation.save_resume_data enabled::\n\n    save_every_x_seconds: 1800\n    save_psi: true\n    save_resume_data: true\n\nif this is the case, the simulation will save the current status at certain \"checkpoints\" defined by the algorithm,\ne.g., in dmrg at the end of a sweep.\nthe checkpoints are saved to the same filename as the desired final output file, and get overwritten by each following save at a checkpoint.\nyou can check ``results['finished']`` in the output file to see whether it finished.\n\nyou can then resume the simulation using the function tenpy.resume_from_checkpoint.\n\nnote that you can also adjust parameters for the resume.\nfor example, if you find that a dmrg result (even a finished one) is not yet fully converged in bond dimension, you can \"resume\" the simulation\nwith a larger bond dimension and a new output filename.\nfor dmrg, this is roughly equivalent to starting a new simulation with the initial state loaded\ntenpy.networks.mps.initialstatebuilder.from_file; but it can reuse more than just the state, e.g., environments and already performed measurements, or the `evolved_time` of a time evolution.\n\n\nsequential simulations\n----------------------\ninstead of waiting for one simulation to finish and \"resuming\" another one with slightly different parameters, you can\nalso directly specify a set of \"sequential\" simulations where the output/results of one simulation are reused for the\nnext one. this can be particularly useful to \"adiabatically\" follow the ground state when tuning model parameters, in\nparticular for flux pump experiments, or to get a stable scaling with bond dimension.\n\nto achieve this, you need to call tenpy.run_seq_simulations instead of just tenpy.run_simulation, and\nspecify the :cfgsequential parameters for the simulation (at the top level of the yaml files), in particular\nthe `recursive_keys` for the parameters to be changed. the values for those parameters can be specified as\n:cfgsequential.value_lists, or as lists in the original location of the yaml file.\n\n\n    sequential:\n        recursive_keys:\n            - algorithm_params.trunc_params.chi_max\n\n    algorithm_params:\n        trunc_params:\n            chi_max: [128, 256, 512] tutorial documentation simulations",
    "tokens": 3388
  },
  {
    "category": "tutorials",
    "name": "doc.JordanWigner",
    "content": "--- DOCUMENTATION: JordanWigner ---\nFermions and the Jordan-Wigner transformation\n=============================================\n\nThe `Jordan-Wigner transformation <https://en.wikipedia.org/wiki/Jordan-Wigner_transformation>`_\nmaps fermionic creation- and annihilation operators to (bosonic) spin-operators.\n\n\nSpinless fermions in 1D\n-----------------------\nLet's start by explicitly writing down the transformation.\nWith the Pauli matrices :math:`\\sigma^{x,y,z}_j` and :math:`\\sigma^{\\pm}_j = (\\sigma^x_j \\pm \\mathrm{i} \\sigma^y_j)/2` on each site,\nwe can map\n\n    n_j         &\\leftrightarrow (\\sigma^{z}_j + 1)/2        \\\\\n    c_j         &\\leftrightarrow (-1)^{\\sum_{l < j} n_l} \\sigma^{-}_j             \\\\\n    c_j^\\dagger &\\leftrightarrow (-1)^{\\sum_{l < j} n_l} \\sigma^{+}_j\n\nThe n_l in the second and third row are defined in terms of Pauli matrices according to the first row.\nWe do not interpret the Pauli matrices as spin-1/2; they have nothing to do with the spin in the spin-full case.\nIf you really want to interpret them physically, you might better think of them as hard-core bosons\n(:math:`b_j =\\sigma^{-}_j, b^\\dagger_j=\\sigma^{+}_j`),\nwith a spin of the fermions mapping to a spin of the hard-core bosons.\n\nNote that this transformation maps the fermionic operators c_j and :math:`c^\\dagger_j` to *global* operators; although they carry an index `j` indicating\na site, they actually act on all sites ``l <= j``!\nThus, clearly the operators ``C`` and ``Cd`` defined in the tenpy.networks.site.FermionSite do *not* directly correspond to c_j and\n:math:`c^\\dagger_j`.\nThe part :math:`(-1)^{\\sum_{l < j} n_l}` is called Jordan-Wigner string and in the tenpy.networks.site.FermionSite is given by the local operator\n:math:`JW := (-1)^{n_l}` acting on all sites ``l < j``.\nSince this important, let me stress it again:\n\n    The fermionic operator c_j (and similar :math:`c^\\dagger_j`) maps to a *global* operator consisting of\n    the Jordan-Wigner string built by the local operator ``JW`` on sites ``l < j`` *and* the local operator ``C`` (or ``Cd``, respectively) on site ``j``.\n\nOn the sites itself, the onsite operators ``C`` and ``Cd`` in the tenpy.networks.site.FermionSite fulfill the correct anti-commutation relation, without the need to include ``JW`` strings.\nThe ``JW`` string is necessary to ensure the anti-commutation for operators acting on different sites.\n\nWritten in terms of `onsite` operators defined in the tenpy.networks.site.FermionSite,\nwith the `i`-th entry in the list acting on site `i`, the relations are thus::\n\n    [\"JW\", ..., \"JW\", \"C\",  \"Id\", ..., \"Id\"]   # for the annihilation operator\n    [\"JW\", ..., \"JW\", \"Cd\", \"Id\", ..., \"Id\"]   # for the creation operator\n\nNote that ``\"JW\"`` squares to the identity, ``\"JW JW\" == \"Id\"``,\nwhich is the reason that the Jordan-wigner string completely cancels in :math:`n_j = c^\\dagger_j c_j`.\nIn the above notation, this can be written as::\n\n    [\"JW\", ..., \"JW\", \"Cd\",  \"Id\", ..., \"Id\"] * [\"JW\", ..., \"JW\", \"C\", \"Id\", ..., \"Id\"]\n    == [\"JW JW\", ..., \"JW JW\", \"Cd C\",  \"Id Id\", ..., \"Id Id\"]      # by definition of the tensorproduct\n    == [\"Id\",    ..., \"Id\",    \"N\",     \"Id\",    ..., \"Id\"]         # by definition of the local operators\n    # (\"X Y\" stands for the local operators X and Y applied on the same site. We assume that the \"Cd\" and \"C\" on the first line act on the same site.)\n\nFor a pair of operators acting on different sites, ``JW`` strings have to be included for every site between the operators.\nFor example, taking ``i < j``,\n:math:`c^\\dagger_i c_j \\leftrightarrow \\sigma_i^{+} (-1)^{\\sum_{i <=l < j} n_l}  \\sigma_j^{-}`.\nMore explicitly, for ``j = i+2`` we get::\n\n    [\"JW\", ..., \"JW\", \"Cd\", \"Id\", \"Id\", \"Id\", ..., \"Id\"] * [\"JW\", ..., \"JW\", \"JW\", \"JW\", \"C\", \"Id\", ..., \"Id\"]\n    == [\"JW JW\", ..., \"JW JW\", \"Cd JW\",  \"Id JW\", \"Id C\", ..., \"Id\"]\n    == [\"Id\",    ..., \"Id\",    \"Cd JW\",  \"JW\",    \"C\",    ..., \"Id\"]\n\nIn other words, the Jordan-Wigner string appears only in the range ``i <= l < j``, i.e. between the two sites *and* on the smaller/left one of them.\n(You can easily generalize this rule to cases with more than two c or :math:`c^\\dagger`.)\n\nThis last line (as well as the last line of the previous example) can be rewritten by changing the order of the operators ``Cd JW`` to ``\"JW Cd\" == - \"Cd\"``.\n(This is valid because either site ``i`` is occupied, yielding a minus sign from the ``JW``, or it is empty, yielding a 0 from the ``Cd``.)\n\nThis is also the case for ``j < i``, say ``j = i-2``:\n:math:`c^\\dagger_i c_j \\leftrightarrow (-1)^{\\sum_{j <=l < i} n_l} \\sigma_i^{+} \\sigma_j^{-}`.\nAs shown in the following, the ``JW`` again appears on the left site,\nbut this time acting *after* ``C``::\n\n    [\"JW\", ..., \"JW\", \"JW\", \"JW\", \"Cd\", \"Id\", ..., \"Id\"] * [\"JW\", ..., \"JW\", \"C\", \"Id\", \"Id\", \"Id\", ..., \"Id\"]\n    == [\"JW JW\", ..., \"JW JW\", \"JW C\",  \"JW\", \"Cd Id\", ..., \"Id\"]\n    == [\"Id\",    ..., \"Id\",    \"JW C\",  \"JW\", \"Cd\",    ..., \"Id\"]\n\n\n\n\nHigher dimensions\n-----------------\nFor an MPO or MPS, you always have to define an ordering of all your sites. This ordering effectively maps the\nhigher-dimensional lattice to a 1D chain, usually at the expense of long-range hopping/interactions.\nWith this mapping, the Jordan-Wigner transformation generalizes to higher dimensions in a straight-forward way.\n\n\nSpinful fermions\n-----------------\n\n\nAs illustrated in the above picture, you can think of spin-1/2 fermions on a chain as spinless fermions living on a ladder (and analogous mappings for higher dimensional lattices).\nEach rung (a blue box in the picture) forms a tenpy.networks.site.SpinHalfFermionSite\nwhich is composed of two tenpy.networks.site.FermionSite (the circles in the picture) for spin-up and spin-down.\nThe mapping of the spin-1/2 fermions onto the ladder induces an ordering of the spins, as the final result must again be a one-dimensional chain, now containing both spin species.\nThe solid line indicates the convention for the ordering, the dashed lines indicate spin-preserving hopping :math:`c^\\dagger_{s,i} c_{s,i+1} + h.c.`\nand visualize the ladder structure.\nMore generally, each species of fermions appearing in your model gets a separate label, and its Jordan-Wigner string\nincludes the signs :math:`(-1)^{n_l}` of *all* species of fermions to the 'left' of it (in the sense of the ordering indicated by the solid line in the picture).\n\nIn the case of spin-1/2 fermions labeled by :math:`\\uparrow` and :math:`\\downarrow` on each `site`, the complete mapping is given (where `j` and `l` are indices of the tenpy.networks.site.FermionSite):\n\n    n_{\\uparrow,j} &\\leftrightarrow (\\sigma^{z}_{\\uparrow,j} + 1)/2                                                                                  \\\\\n    n_{\\downarrow,j} &\\leftrightarrow (\\sigma^{z}_{\\downarrow,j} + 1)/2                                                                              \\\\\n    c_{\\uparrow,j} &\\leftrightarrow (-1)^{\\sum_{l < j} n_{\\uparrow,l} + n_{\\downarrow,l}} \\sigma^{-}_{\\uparrow,j}                                    \\\\\n    c^\\dagger_{\\uparrow,j} &\\leftrightarrow (-1)^{\\sum_{l < j} n_{\\uparrow,l} + n_{\\downarrow,l}} \\sigma^{+}_{\\uparrow,j}                           \\\\\n    c_{\\downarrow,j} &\\leftrightarrow (-1)^{\\sum_{l < j} n_{\\uparrow,l} + n_{\\downarrow,l}} (-1)^{n_{\\uparrow,j}} \\sigma^{-}_{\\downarrow,j}          \\\\\n    c^\\dagger_{\\downarrow,j} &\\leftrightarrow (-1)^{\\sum_{l < j} n_{\\uparrow,l} + n_{\\downarrow,l}} (-1)^{n_{\\uparrow,j}} \\sigma^{+}_{\\downarrow,j} \\\\\n\nIn each of the above mappings the operators on the right hand sides commute; we can rewrite\n:math:`(-1)^{\\sum_{l < j} n_{\\uparrow,l} + n_{\\downarrow,l}} = \\prod_{l < j} (-1)^{n_{\\uparrow,l}} (-1)^{n_{\\downarrow,l}}`,\nwhich resembles the actual structure in the code more closely.\nThe parts of the operator acting in the same box of the picture, i.e. which have the same index `j` or `l`,\nare the 'onsite' operators in the tenpy.networks.site.SpinHalfFermionSite:\nfor example ``JW`` on site `j` is given by :math:`(-1)^{n_{\\uparrow,j}} (-1)^{n_{\\downarrow,j}}`,\n``Cu`` is just the :math:`\\sigma^{-}_{\\uparrow,j}`, ``Cdu`` is :math:`\\sigma^{+}_{\\uparrow,j}`,\n``Cd`` is :math:`(-1)^{n_{\\uparrow,j}} \\sigma^{-}_{\\downarrow,j}`.\nand ``Cdd`` is :math:`(-1)^{n_{\\uparrow,j}} \\sigma^{+}_{\\downarrow,j}`.\nNote the asymmetry regarding the spin in the definition of the onsite operators:\nthe spin-down operators include Jordan-Wigner signs for the spin-up fermions on the same site.\nThis asymmetry stems from the ordering convention introduced by the solid line in the picture, according to which the spin-up site\nis \"left\" of the spin-down site. With the above definition, the operators within the same tenpy.networks.site.SpinHalfFermionSite fulfill the expected commutation relations,\nfor example ``\"Cu Cdd\" == - \"Cdd Cu\"``, but again the ``JW`` on sites left of the operator pair is crucial to get the correct\ncommutation relations globally.\n\n    Again, the fermionic operators :math:`c_{\\uparrow,j}, c^\\dagger_{\\uparrow,j}, c_{\\downarrow,j}, c^\\dagger_{\\downarrow,j}` correspond to  *global* operators consisting of\n    the Jordan-Wigner string built by the local operator ``JW`` on sites ``l < j`` *and* the local operators ``'Cu', 'Cdu', 'Cd', 'Cdd'`` on site ``j``.\n\nWritten explicitly in terms of onsite operators defined in the tenpy.networks.sites.FermionSite,\nwith the `j`-th entry entry in the list acting on site `j`, the relations are::\n\n    [\"JW\", ..., \"JW\", \"Cu\",  \"Id\", ..., \"Id\"]    # for the annihilation operator spin-up\n    [\"JW\", ..., \"JW\", \"Cd\",  \"Id\", ..., \"Id\"]    # for the annihilation operator spin-down\n    [\"JW\", ..., \"JW\", \"Cdu\",  \"Id\", ..., \"Id\"]   # for the creation operator spin-up\n    [\"JW\", ..., \"JW\", \"Cdd\",  \"Id\", ..., \"Id\"]   # for the creation operator spin-down\n\nAs you can see, the asymmetry regarding the spins in the definition of the local onsite operators ``\"Cu\", \"Cd\", \"Cdu\", \"Cdd\"`` lead to a symmetric definition in the global sense.\nIf you look at the definitions very closely, you can see that in terms like ``[\"Id\", \"Cd JW\", \"JW\", \"Cd\"]`` the\nJordan-Wigner sign :math:`(-1)^{n_\\uparrow,2}` appears twice (namely once in the definition of ``\"Cd\"`` and once in the ``\"JW\"`` on site\n2) and could in principle be canceled, however in favor of a simplified handling in the code we do not recommend you to cancel it.\nSimilar, within a spinless tenpy.networks.site.FermionSite, one can simplify ``\"Cd JW\" == \"Cd\"`` and ``\"JW C\" == \"C\"``,\nbut these relations do *not* hold in the tenpy.networks.site.SpinHalfFermionSite,\nand for consistency we recommend to explicitly keep the ``\"JW\"`` operator string even in nearest-neighbor models where it is not strictly necessary.\n\n\nHow to handle Jordan-Wigner strings in practice\n-----------------------------------------------\n\nThere are only a few pitfalls where you have to keep the mapping in mind:\nWhen **building a model**, you map the physical fermionic operators to the usual spin/bosonic operators.\nThe algorithms don't care about the mapping, they just use the given Hamiltonian, be it given as MPO for DMRG or as nearest neighbor couplings for TEBD.\nOnly when you do a **measurement** (e.g. by calculating an expectation value or a correlation function), you have to reverse this mapping.\nBe aware that in certain cases, e.g. when calculating the entanglement entropy on a certain bond,\nyou cannot reverse this mapping (in a straightforward way), and thus your results might depend on how you defined the Jordan-Wigner string.\n\nWhatever you do, you should first think about if (and how much of) the Jordan-Wigner string cancels.\nFor example for many of the onsite operators (like the particle number operator ``N`` or the spin operators in the tenpy.networks.site.SpinHalfFermionSite)\nthe Jordan-Wigner string cancels completely and you can just ignore it both in onsite-terms and couplings.\nIn case of two operators acting on different sites, you typically have a Jordan-Wigner string inbetween (e.g. for the\n:math:`c^\\dagger_i c_j` examples described above and below) or no Jordan-Wigner strings at all (e.g. for density-density\ninteractions :math:`n_i n_j`).\nIn fact, the case that the Jordan Wigner string on the left of the first non-trivial operator does not cancel is currently not supported\nfor models and expectation values, as it usually doesn't appear in practice.\nFor terms involving more operators, things tend to get more complicated, e.g. :math:`c^\\dagger_i c^\\dagger_j c_k c_l` with\n:math:`i < j < k < l` requires a Jordan-Wigner string on sites `m` with :math:`i \\leq m <j` or :math:`k \\leq m <l`, but\nnot for :math:`j < m < k`.\n\n    TeNPy keeps track of which onsite operators need a Jordan-Wigner string in the tenpy.networks.site.Site class,\n    specifically in tenpy.networks.site.Site.need_JW_string and tenpy.networks.site.Site.op_needs_JW.\n    Hence, when you define custom sites or add extra operators to the sites, make sure that\n    tenpy.networks.site.Site.op_needs_JW returns the expected results.\n\nWhen **building a model** the Jordan-Wigner strings need to be taken into account.\nIf you just specify the `H_MPO` or `H_bond`, it is *your* responsibility to use the correct mapping.\nHowever, if you use the tenpy.models.model.CouplingModel.add_coupling method of the\ntenpy.models.model.CouplingModel ,\n(or the generalization tenpy.models.model.CouplingModel.add_multi_coupling for more than 2 operators),\nTeNPy can use the information from the `Site` class to *automatically add Jordan-Wigner* strings as needed.\nIndeed, with the default argument ``op_string=None``, `add_coupling` will automatically check whether the operators\nneed Jordan-Wigner strings and correspondingly set ``op_string='JW', str_on_first=True``, if necessary.\nFor `add_multi_coupling`, you can't even explicitly specify the correct Jordan-Wigner strings, but you **must use**\n``op_string=None``, from which it will automatically determine where Jordan-Wigner strings are needed.\n\nObviously, you should be careful about the convention which of the operators is applied first (in a physical\nsense as an operator acting on a state), as this corresponds to a sign of the prefactor.\nRead the doc-strings of tenpy.models.model.CouplingModel.add_coupling\ntenpy.models.model.CouplingModel.add_multi_coupling for details.\n\nAs a concrete example, let us specify a hopping\n:math:`\\sum_{i} (c^\\dagger_i c_{i+1} + h.c.) = \\sum_{i} (c^\\dagger_i c_{i+1} + c^\\dagger_{i} c_{i-1})`\nin a 1D chain of tenpy.networks.site.FermionSite with tenpy.models.model.CouplingModel.add_coupling.\nThe recommended way is just::\n\n    self.add_coupling(strength, 0, 'Cd', 0, 'C', 1, plus_hc=True)\n\nIf you want to specify both the Jordan-Wigner string and the ``h.c.`` term explicitly, you can use::\n\n    self.add_coupling(strength, 0, 'Cd', 0, 'C', 1, op_string='JW', str_on_first=True)\n    self.add_coupling(strength, 0, 'Cd', 0, 'C', -1, op_string='JW', str_on_first=True)\n\nSlightly more complicated, to specify the hopping\n:math:`\\sum_{\\langle i, j\\rangle, s} (c^\\dagger_{s,i} c_{s,j} + h.c.)`\nin the Fermi-Hubbard model on a 2D square lattice, we could use::\n\n    for (dx, dy) in [(1, 0), (0, 1)]:\n        self.add_coupling(strength, 0, 'Cdu', 0, 'Cu', (dx, dy), plus_hc=True)  # spin up\n        self.add_coupling(strength, 0, 'Cdd', 0, 'Cd', (dx, dy), plus_hc=True)  # spin down\n\n    # or without `plus_hc`\n    for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:  # include -dx !\n        self.add_coupling(strength, 0, 'Cdu', 0, 'Cu', (dx, dy))  # spin up\n        self.add_coupling(strength, 0, 'Cdd', 0, 'Cd', (dx, dy))  # spin down\n\n    # or specifying the 'JW' string explicitly\n    for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n        self.add_coupling(strength, 0, 'Cdu', 0, 'Cu', (dx, dy), 'JW', True)  # spin up\n        self.add_coupling(strength, 0, 'Cdd', 0, 'Cd', (dx, dy), 'JW', True)  # spin down\n\n\nThe most important functions for doing **measurements** are probably tenpy.networks.mps.MPS.expectation_value\nand tenpy.networks.mps.MPS.correlation_function. Again, if all the Jordan-Wigner strings cancel, you don't have\nto worry about them at all, e.g. for many onsite operators or correlation functions involving only number operators.\nIf you build multi-site operators to be measured by `expectation_value`, take care to include the Jordan-Wigner\nstring correctly.\n\nSome MPS methods like\ntenpy.networks.mps.MPS.correlation_function,\ntenpy.networks.mps.MPS.expectation_value_term and\ntenpy.networks.mps.MPS.expectation_value_terms_sum automatically add Jordan-Wigner strings\n(at least with default arguments).\nOther more low-level functions like tenpy.networks.mps.MPS.expectation_value_multi_sites don't do it.\nHence, you should always watch out during measurements, if the function used needs special treatment for Jordan-Wigner strings.",
    "search_text": "doc.jordanwigner --- documentation: jordanwigner ---\nfermions and the jordan-wigner transformation\n=============================================\n\nthe `jordan-wigner transformation <https://en.wikipedia.org/wiki/jordan-wigner_transformation>`_\nmaps fermionic creation- and annihilation operators to (bosonic) spin-operators.\n\n\nspinless fermions in 1d\n-----------------------\nlet's start by explicitly writing down the transformation.\nwith the pauli matrices :math:`\\sigma^{x,y,z}_j` and :math:`\\sigma^{\\pm}_j = (\\sigma^x_j \\pm \\mathrm{i} \\sigma^y_j)/2` on each site,\nwe can map\n\n    n_j         &\\leftrightarrow (\\sigma^{z}_j + 1)/2        \\\\\n    c_j         &\\leftrightarrow (-1)^{\\sum_{l < j} n_l} \\sigma^{-}_j             \\\\\n    c_j^\\dagger &\\leftrightarrow (-1)^{\\sum_{l < j} n_l} \\sigma^{+}_j\n\nthe n_l in the second and third row are defined in terms of pauli matrices according to the first row.\nwe do not interpret the pauli matrices as spin-1/2; they have nothing to do with the spin in the spin-full case.\nif you really want to interpret them physically, you might better think of them as hard-core bosons\n(:math:`b_j =\\sigma^{-}_j, b^\\dagger_j=\\sigma^{+}_j`),\nwith a spin of the fermions mapping to a spin of the hard-core bosons.\n\nnote that this transformation maps the fermionic operators c_j and :math:`c^\\dagger_j` to *global* operators; although they carry an index `j` indicating\na site, they actually act on all sites ``l <= j``!\nthus, clearly the operators ``c`` and ``cd`` defined in the tenpy.networks.site.fermionsite do *not* directly correspond to c_j and\n:math:`c^\\dagger_j`.\nthe part :math:`(-1)^{\\sum_{l < j} n_l}` is called jordan-wigner string and in the tenpy.networks.site.fermionsite is given by the local operator\n:math:`jw := (-1)^{n_l}` acting on all sites ``l < j``.\nsince this important, let me stress it again:\n\n    the fermionic operator c_j (and similar :math:`c^\\dagger_j`) maps to a *global* operator consisting of\n    the jordan-wigner string built by the local operator ``jw`` on sites ``l < j`` *and* the local operator ``c`` (or ``cd``, respectively) on site ``j``.\n\non the sites itself, the onsite operators ``c`` and ``cd`` in the tenpy.networks.site.fermionsite fulfill the correct anti-commutation relation, without the need to include ``jw`` strings.\nthe ``jw`` string is necessary to ensure the anti-commutation for operators acting on different sites.\n\nwritten in terms of `onsite` operators defined in the tenpy.networks.site.fermionsite,\nwith the `i`-th entry in the list acting on site `i`, the relations are thus::\n\n    [\"jw\", ..., \"jw\", \"c\",  \"id\", ..., \"id\"]   # for the annihilation operator\n    [\"jw\", ..., \"jw\", \"cd\", \"id\", ..., \"id\"]   # for the creation operator\n\nnote that ``\"jw\"`` squares to the identity, ``\"jw jw\" == \"id\"``,\nwhich is the reason that the jordan-wigner string completely cancels in :math:`n_j = c^\\dagger_j c_j`.\nin the above notation, this can be written as::\n\n    [\"jw\", ..., \"jw\", \"cd\",  \"id\", ..., \"id\"] * [\"jw\", ..., \"jw\", \"c\", \"id\", ..., \"id\"]\n    == [\"jw jw\", ..., \"jw jw\", \"cd c\",  \"id id\", ..., \"id id\"]      # by definition of the tensorproduct\n    == [\"id\",    ..., \"id\",    \"n\",     \"id\",    ..., \"id\"]         # by definition of the local operators\n    # (\"x y\" stands for the local operators x and y applied on the same site. we assume that the \"cd\" and \"c\" on the first line act on the same site.)\n\nfor a pair of operators acting on different sites, ``jw`` strings have to be included for every site between the operators.\nfor example, taking ``i < j``,\n:math:`c^\\dagger_i c_j \\leftrightarrow \\sigma_i^{+} (-1)^{\\sum_{i <=l < j} n_l}  \\sigma_j^{-}`.\nmore explicitly, for ``j = i+2`` we get::\n\n    [\"jw\", ..., \"jw\", \"cd\", \"id\", \"id\", \"id\", ..., \"id\"] * [\"jw\", ..., \"jw\", \"jw\", \"jw\", \"c\", \"id\", ..., \"id\"]\n    == [\"jw jw\", ..., \"jw jw\", \"cd jw\",  \"id jw\", \"id c\", ..., \"id\"]\n    == [\"id\",    ..., \"id\",    \"cd jw\",  \"jw\",    \"c\",    ..., \"id\"]\n\nin other words, the jordan-wigner string appears only in the range ``i <= l < j``, i.e. between the two sites *and* on the smaller/left one of them.\n(you can easily generalize this rule to cases with more than two c or :math:`c^\\dagger`.)\n\nthis last line (as well as the last line of the previous example) can be rewritten by changing the order of the operators ``cd jw`` to ``\"jw cd\" == - \"cd\"``.\n(this is valid because either site ``i`` is occupied, yielding a minus sign from the ``jw``, or it is empty, yielding a 0 from the ``cd``.)\n\nthis is also the case for ``j < i``, say ``j = i-2``:\n:math:`c^\\dagger_i c_j \\leftrightarrow (-1)^{\\sum_{j <=l < i} n_l} \\sigma_i^{+} \\sigma_j^{-}`.\nas shown in the following, the ``jw`` again appears on the left site,\nbut this time acting *after* ``c``::\n\n    [\"jw\", ..., \"jw\", \"jw\", \"jw\", \"cd\", \"id\", ..., \"id\"] * [\"jw\", ..., \"jw\", \"c\", \"id\", \"id\", \"id\", ..., \"id\"]\n    == [\"jw jw\", ..., \"jw jw\", \"jw c\",  \"jw\", \"cd id\", ..., \"id\"]\n    == [\"id\",    ..., \"id\",    \"jw c\",  \"jw\", \"cd\",    ..., \"id\"]\n\n\n\n\nhigher dimensions\n-----------------\nfor an mpo or mps, you always have to define an ordering of all your sites. this ordering effectively maps the\nhigher-dimensional lattice to a 1d chain, usually at the expense of long-range hopping/interactions.\nwith this mapping, the jordan-wigner transformation generalizes to higher dimensions in a straight-forward way.\n\n\nspinful fermions\n-----------------\n\n\nas illustrated in the above picture, you can think of spin-1/2 fermions on a chain as spinless fermions living on a ladder (and analogous mappings for higher dimensional lattices).\neach rung (a blue box in the picture) forms a tenpy.networks.site.spinhalffermionsite\nwhich is composed of two tenpy.networks.site.fermionsite (the circles in the picture) for spin-up and spin-down.\nthe mapping of the spin-1/2 fermions onto the ladder induces an ordering of the spins, as the final result must again be a one-dimensional chain, now containing both spin species.\nthe solid line indicates the convention for the ordering, the dashed lines indicate spin-preserving hopping :math:`c^\\dagger_{s,i} c_{s,i+1} + h.c.`\nand visualize the ladder structure.\nmore generally, each species of fermions appearing in your model gets a separate label, and its jordan-wigner string\nincludes the signs :math:`(-1)^{n_l}` of *all* species of fermions to the 'left' of it (in the sense of the ordering indicated by the solid line in the picture).\n\nin the case of spin-1/2 fermions labeled by :math:`\\uparrow` and :math:`\\downarrow` on each `site`, the complete mapping is given (where `j` and `l` are indices of the tenpy.networks.site.fermionsite):\n\n    n_{\\uparrow,j} &\\leftrightarrow (\\sigma^{z}_{\\uparrow,j} + 1)/2                                                                                  \\\\\n    n_{\\downarrow,j} &\\leftrightarrow (\\sigma^{z}_{\\downarrow,j} + 1)/2                                                                              \\\\\n    c_{\\uparrow,j} &\\leftrightarrow (-1)^{\\sum_{l < j} n_{\\uparrow,l} + n_{\\downarrow,l}} \\sigma^{-}_{\\uparrow,j}                                    \\\\\n    c^\\dagger_{\\uparrow,j} &\\leftrightarrow (-1)^{\\sum_{l < j} n_{\\uparrow,l} + n_{\\downarrow,l}} \\sigma^{+}_{\\uparrow,j}                           \\\\\n    c_{\\downarrow,j} &\\leftrightarrow (-1)^{\\sum_{l < j} n_{\\uparrow,l} + n_{\\downarrow,l}} (-1)^{n_{\\uparrow,j}} \\sigma^{-}_{\\downarrow,j}          \\\\\n    c^\\dagger_{\\downarrow,j} &\\leftrightarrow (-1)^{\\sum_{l < j} n_{\\uparrow,l} + n_{\\downarrow,l}} (-1)^{n_{\\uparrow,j}} \\sigma^{+}_{\\downarrow,j} \\\\\n\nin each of the above mappings the operators on the right hand sides commute; we can rewrite\n:math:`(-1)^{\\sum_{l < j} n_{\\uparrow,l} + n_{\\downarrow,l}} = \\prod_{l < j} (-1)^{n_{\\uparrow,l}} (-1)^{n_{\\downarrow,l}}`,\nwhich resembles the actual structure in the code more closely.\nthe parts of the operator acting in the same box of the picture, i.e. which have the same index `j` or `l`,\nare the 'onsite' operators in the tenpy.networks.site.spinhalffermionsite:\nfor example ``jw`` on site `j` is given by :math:`(-1)^{n_{\\uparrow,j}} (-1)^{n_{\\downarrow,j}}`,\n``cu`` is just the :math:`\\sigma^{-}_{\\uparrow,j}`, ``cdu`` is :math:`\\sigma^{+}_{\\uparrow,j}`,\n``cd`` is :math:`(-1)^{n_{\\uparrow,j}} \\sigma^{-}_{\\downarrow,j}`.\nand ``cdd`` is :math:`(-1)^{n_{\\uparrow,j}} \\sigma^{+}_{\\downarrow,j}`.\nnote the asymmetry regarding the spin in the definition of the onsite operators:\nthe spin-down operators include jordan-wigner signs for the spin-up fermions on the same site.\nthis asymmetry stems from the ordering convention introduced by the solid line in the picture, according to which the spin-up site\nis \"left\" of the spin-down site. with the above definition, the operators within the same tenpy.networks.site.spinhalffermionsite fulfill the expected commutation relations,\nfor example ``\"cu cdd\" == - \"cdd cu\"``, but again the ``jw`` on sites left of the operator pair is crucial to get the correct\ncommutation relations globally.\n\n    again, the fermionic operators :math:`c_{\\uparrow,j}, c^\\dagger_{\\uparrow,j}, c_{\\downarrow,j}, c^\\dagger_{\\downarrow,j}` correspond to  *global* operators consisting of\n    the jordan-wigner string built by the local operator ``jw`` on sites ``l < j`` *and* the local operators ``'cu', 'cdu', 'cd', 'cdd'`` on site ``j``.\n\nwritten explicitly in terms of onsite operators defined in the tenpy.networks.sites.fermionsite,\nwith the `j`-th entry entry in the list acting on site `j`, the relations are::\n\n    [\"jw\", ..., \"jw\", \"cu\",  \"id\", ..., \"id\"]    # for the annihilation operator spin-up\n    [\"jw\", ..., \"jw\", \"cd\",  \"id\", ..., \"id\"]    # for the annihilation operator spin-down\n    [\"jw\", ..., \"jw\", \"cdu\",  \"id\", ..., \"id\"]   # for the creation operator spin-up\n    [\"jw\", ..., \"jw\", \"cdd\",  \"id\", ..., \"id\"]   # for the creation operator spin-down\n\nas you can see, the asymmetry regarding the spins in the definition of the local onsite operators ``\"cu\", \"cd\", \"cdu\", \"cdd\"`` lead to a symmetric definition in the global sense.\nif you look at the definitions very closely, you can see that in terms like ``[\"id\", \"cd jw\", \"jw\", \"cd\"]`` the\njordan-wigner sign :math:`(-1)^{n_\\uparrow,2}` appears twice (namely once in the definition of ``\"cd\"`` and once in the ``\"jw\"`` on site\n2) and could in principle be canceled, however in favor of a simplified handling in the code we do not recommend you to cancel it.\nsimilar, within a spinless tenpy.networks.site.fermionsite, one can simplify ``\"cd jw\" == \"cd\"`` and ``\"jw c\" == \"c\"``,\nbut these relations do *not* hold in the tenpy.networks.site.spinhalffermionsite,\nand for consistency we recommend to explicitly keep the ``\"jw\"`` operator string even in nearest-neighbor models where it is not strictly necessary.\n\n\nhow to handle jordan-wigner strings in practice\n-----------------------------------------------\n\nthere are only a few pitfalls where you have to keep the mapping in mind:\nwhen **building a model**, you map the physical fermionic operators to the usual spin/bosonic operators.\nthe algorithms don't care about the mapping, they just use the given hamiltonian, be it given as mpo for dmrg or as nearest neighbor couplings for tebd.\nonly when you do a **measurement** (e.g. by calculating an expectation value or a correlation function), you have to reverse this mapping.\nbe aware that in certain cases, e.g. when calculating the entanglement entropy on a certain bond,\nyou cannot reverse this mapping (in a straightforward way), and thus your results might depend on how you defined the jordan-wigner string.\n\nwhatever you do, you should first think about if (and how much of) the jordan-wigner string cancels.\nfor example for many of the onsite operators (like the particle number operator ``n`` or the spin operators in the tenpy.networks.site.spinhalffermionsite)\nthe jordan-wigner string cancels completely and you can just ignore it both in onsite-terms and couplings.\nin case of two operators acting on different sites, you typically have a jordan-wigner string inbetween (e.g. for the\n:math:`c^\\dagger_i c_j` examples described above and below) or no jordan-wigner strings at all (e.g. for density-density\ninteractions :math:`n_i n_j`).\nin fact, the case that the jordan wigner string on the left of the first non-trivial operator does not cancel is currently not supported\nfor models and expectation values, as it usually doesn't appear in practice.\nfor terms involving more operators, things tend to get more complicated, e.g. :math:`c^\\dagger_i c^\\dagger_j c_k c_l` with\n:math:`i < j < k < l` requires a jordan-wigner string on sites `m` with :math:`i \\leq m <j` or :math:`k \\leq m <l`, but\nnot for :math:`j < m < k`.\n\n    tenpy keeps track of which onsite operators need a jordan-wigner string in the tenpy.networks.site.site class,\n    specifically in tenpy.networks.site.site.need_jw_string and tenpy.networks.site.site.op_needs_jw.\n    hence, when you define custom sites or add extra operators to the sites, make sure that\n    tenpy.networks.site.site.op_needs_jw returns the expected results.\n\nwhen **building a model** the jordan-wigner strings need to be taken into account.\nif you just specify the `h_mpo` or `h_bond`, it is *your* responsibility to use the correct mapping.\nhowever, if you use the tenpy.models.model.couplingmodel.add_coupling method of the\ntenpy.models.model.couplingmodel ,\n(or the generalization tenpy.models.model.couplingmodel.add_multi_coupling for more than 2 operators),\ntenpy can use the information from the `site` class to *automatically add jordan-wigner* strings as needed.\nindeed, with the default argument ``op_string=none``, `add_coupling` will automatically check whether the operators\nneed jordan-wigner strings and correspondingly set ``op_string='jw', str_on_first=true``, if necessary.\nfor `add_multi_coupling`, you can't even explicitly specify the correct jordan-wigner strings, but you **must use**\n``op_string=none``, from which it will automatically determine where jordan-wigner strings are needed.\n\nobviously, you should be careful about the convention which of the operators is applied first (in a physical\nsense as an operator acting on a state), as this corresponds to a sign of the prefactor.\nread the doc-strings of tenpy.models.model.couplingmodel.add_coupling\ntenpy.models.model.couplingmodel.add_multi_coupling for details.\n\nas a concrete example, let us specify a hopping\n:math:`\\sum_{i} (c^\\dagger_i c_{i+1} + h.c.) = \\sum_{i} (c^\\dagger_i c_{i+1} + c^\\dagger_{i} c_{i-1})`\nin a 1d chain of tenpy.networks.site.fermionsite with tenpy.models.model.couplingmodel.add_coupling.\nthe recommended way is just::\n\n    self.add_coupling(strength, 0, 'cd', 0, 'c', 1, plus_hc=true)\n\nif you want to specify both the jordan-wigner string and the ``h.c.`` term explicitly, you can use::\n\n    self.add_coupling(strength, 0, 'cd', 0, 'c', 1, op_string='jw', str_on_first=true)\n    self.add_coupling(strength, 0, 'cd', 0, 'c', -1, op_string='jw', str_on_first=true)\n\nslightly more complicated, to specify the hopping\n:math:`\\sum_{\\langle i, j\\rangle, s} (c^\\dagger_{s,i} c_{s,j} + h.c.)`\nin the fermi-hubbard model on a 2d square lattice, we could use::\n\n    for (dx, dy) in [(1, 0), (0, 1)]:\n        self.add_coupling(strength, 0, 'cdu', 0, 'cu', (dx, dy), plus_hc=true)  # spin up\n        self.add_coupling(strength, 0, 'cdd', 0, 'cd', (dx, dy), plus_hc=true)  # spin down\n\n    # or without `plus_hc`\n    for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:  # include -dx !\n        self.add_coupling(strength, 0, 'cdu', 0, 'cu', (dx, dy))  # spin up\n        self.add_coupling(strength, 0, 'cdd', 0, 'cd', (dx, dy))  # spin down\n\n    # or specifying the 'jw' string explicitly\n    for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n        self.add_coupling(strength, 0, 'cdu', 0, 'cu', (dx, dy), 'jw', true)  # spin up\n        self.add_coupling(strength, 0, 'cdd', 0, 'cd', (dx, dy), 'jw', true)  # spin down\n\n\nthe most important functions for doing **measurements** are probably tenpy.networks.mps.mps.expectation_value\nand tenpy.networks.mps.mps.correlation_function. again, if all the jordan-wigner strings cancel, you don't have\nto worry about them at all, e.g. for many onsite operators or correlation functions involving only number operators.\nif you build multi-site operators to be measured by `expectation_value`, take care to include the jordan-wigner\nstring correctly.\n\nsome mps methods like\ntenpy.networks.mps.mps.correlation_function,\ntenpy.networks.mps.mps.expectation_value_term and\ntenpy.networks.mps.mps.expectation_value_terms_sum automatically add jordan-wigner strings\n(at least with default arguments).\nother more low-level functions like tenpy.networks.mps.mps.expectation_value_multi_sites don't do it.\nhence, you should always watch out during measurements, if the function used needs special treatment for jordan-wigner strings. tutorial documentation jordanwigner",
    "tokens": 4758
  },
  {
    "category": "tutorials",
    "name": "doc.npc",
    "content": "--- DOCUMENTATION: npc ---\nCharge conservation with np_conserved\n=====================================\n\nThe basic idea is quickly summarized:\nBy inspecting the Hamiltonian, you can identify symmetries, which correspond to conserved quantities, called **charges**.\nThese charges divide the tensors into different sectors. This can be used to infer for example a block-diagonal structure\nof certain matrices, which in turn speeds up SVD or diagonalization a lot.\nEven for more general (non-square-matrix) tensors, charge conservation imposes restrictions which blocks of a tensor can\nbe non-zero. Only those blocks need to be saved, which ultimately (= for large enough arrays) leads to a speedup of many routines, e.g., tensordot.\n\nThis introduction covers our implementation of charges; explaining mathematical details of the underlying symmetry is beyond its scope.\nWe refer you to the corresponding chapter in our [TeNPyNotes]_ for a more general introduction of the idea (also stating\nthe \"charge rule\" introduced below).\nsingh2010 explains why it works form a mathematical point of view, singh2011 has the focus on a :math:`U(1)` symmetry and might be easier to read.\n\n\nWhat you really need to know about `np_conserved`\n-------------------------------------------------\n\nThe good news is: It is not necessary to understand all the details explained in the following sections\nif you just want to use TeNPy for \"standard\" simulations like TEBD and DMRG.\nIn praxis, **you will likely not have to define the charges by yourself**.\nFor most simulations using TeNPy, the charges are initially defined in the tenpy.networks.site.Site;\nand there are many pre-defined sites like the :class:tenpy.networks.site.SpinHalfSite, which you can just use.\nThe sites in turn are initialized by the Model class you are using (see also :doc:`/intro/model`).\nFrom there, all the necessary charge information is automatically propagated along with the tensors.\n\n\nHowever, you should definitely know a few basic facts about the usage of charge conservation in TeNPy:\n\n- Instead of using numpy arrays, tensors are represented by the tenpy.linalg.np_conserved.Array class.\n  This class is defined in tenpy.linalg.np_conserved (the name standing for \"numpy with charge conservation\").\n  Internally, it stores only non-zero blocks of the tensor, which are \"compatible\" with the charges of the indices.\n  It **has to have a well defined overall charge** tenpy.linalg.np_conserved.Array.qtotal.\n  This **excludes certain operators** (like :math:`S^x` for Sz conservation) and MPS which are a superpositions of states in different charge sectors.\n- There is a class tenpy.linalg.charges.ChargeInfo holding the general information what kind of charges we have,\n  and a tenpy.linalg.charges.LegCharge for the charge data on a given leg. The leg holds a flag `qconj` which\n  is +1 or -1, depending on whether the leg goes into the tensor (representing a vector space)\n  or out of the tensor (representing the corresponding dual vector space).\n- Besides the array class methods, there are a bunch of functions like tenpy.linalg.np_conserved.tensordot,\n  tenpy.linalg.np_conserved.svd or tenpy.linalg.np_conserved.eigh to manipulate tensors.\n  These function have a very similar call structure as the corresponding numpy functions, but they act on our tensor\n  Array class, and preserve the block structure (and exploit it for speed, wherever possible).\n- The only allowed \"reshaping\" operations for those tensors are to combine legs and to split previously combined legs.\n  See the corresponding :ref:`section below <leg_pipes>`.\n- It is convenient to use string labels instead of numbers to refer to the various legs of a tensor.\n  The rules how these labels change during the various operations are also described a :ref:`section below <leg_labeling>`.\n\n\n\nIntroduction to combine_legs, split_legs and LegPipes\n-----------------------------------------------------\n\nOften, it is necessary to \"combine\" multiple legs into one: for example to perform a SVD, a tensor needs to be viewed as a matrix.\nFor a flat array, this can be done with ``np.reshape``, e.g., if ``A`` has shape ``(10, 3, 7)`` then ``B = np.reshape(A, (30, 7))`` will\nresult in a (view of the) array with one less dimension, but a \"larger\" first leg. By default (``order='C'``), this\nresults in ::\n\n    B[i*3 + j , k] == A[i, j, k] for i in range(10) for j in range(3) for k in range(7)\n\nWhile for a np.array, also a reshaping ``(10, 3, 7) -> (2, 21, 5)`` would be allowed, it does not make sense\nphysically. The only sensible \"reshape\" operation on an tenpy.linalg.np_conserved.Array are\n\n1) to **combine** multiple legs into one **leg pipe** (tenpy.linalg.charges.LegPipe) with  tenpy.linalg.np_conserved.Array.combine_legs, or\n2) to **split** a pipe of previously combined legs with tenpy.linalg.np_conserved.Array.split_legs.\n\nEach leg has a Hilbert space, and a representation of the symmetry on that Hilbert space.\nCombining legs corresponds to the tensor product operation, and for abelian groups,\nthe corresponding \"fusion\" of the representation is the simple addition of charge.\n\nFusion is not a lossless process, so if we ever want to split the combined leg,\nwe need some additional data to tell us how to reverse the tensor product.\nThis data is saved in the class tenpy.linalg.charges.LegPipe, derived from the tenpy.linalg.charges.LegCharge and used as new `leg`.\nDetails of the information contained in a LegPipe are given in the class doc string.\n\nThe rough usage idea is as follows:\n\n1) You can call tenpy.linalg.np_conserved.Array.combine_legs without supplying any LegPipes, `combine_legs` will then make them for you.\n\n   Nevertheless, if you plan to perform the combination over and over again on sets of legs you know to be identical\n   [with same charges etc, up to an overall -1 in `qconj` on all incoming and outgoing Legs]\n   you might make a LegPipe anyway to save on the overhead of computing it each time.\n2) In any way, the resulting Array will have a tenpy.linalg.charges.LegPipe as a LegCharge on the combined leg.\n   Thus, it -- and all tensors inheriting the leg (e.g. the results of `svd`, `tensordot` etc.) -- will have the information\n   how to split the `LegPipe` back to the original legs.\n3) Once you performed the necessary operations, you can call tenpy.linalg.Array.split_legs.\n   This uses the information saved in the `LegPipe` to split the legs, recovering the original legs.\n\nFor a LegPipe, tenpy.linalg.charges.LegPipe.conj changes ``qconj`` for the outgoing pipe *and* the incoming legs.\nIf you need a `LegPipe` with the same incoming ``qconj``, use tenpy.linalg.charges.LegPipe.outer_conj.\n\n\n\nLeg labeling\n------------\n\nIt's convenient to name the legs of a tensor: for instance, we can name legs 0, 1, 2 to be ``'a', 'b', 'c'``: :math:`T_{i_a,i_b,i_c}`.\nThat way we don't have to remember the ordering! Under tensordot, we can then call ::\n\n    U = npc.tensordot(S, T, axes = [ [...],  ['b'] ] )\n\nwithout having to remember where exactly ``'b'`` is.\nObviously ``U`` should then inherit the name of its legs from the uncontracted legs of `S` and `T`.\nSo here is how it works:\n\n- Labels can *only* be strings. The labels should not include the characters ``.`` or ``?``.\n  Internally, the labels are stored as dict ``a.labels = {label: leg_position, ...}``. Not all legs need a label.\n- To set the labels, call ::\n\n        A.set_labels(['a', 'b', None, 'c', ... ])\n\n  which will set up the labeling ``{'a': 0, 'b': 1, 'c': 3 ...}``.\n\n- (Where implemented) the specification of axes can use either the labels **or** the index positions.\n  For instance, the call ``tensordot(A, B, [['a', 2, 'c'], [...]])`` will interpret ``'a'`` and  ``'c'`` as labels\n  (calling tenpy.linalg.np_conserved.Array.get_leg_indices to find their positions using the dict)\n  and 2 as 'the 2nd leg'. That's why we require labels to be strings!\n- Labels will be intelligently inherited through the various operations of `np_conserved`.\n    - Under `transpose`, labels are permuted.\n    - Under `tensordot`, labels are inherited from uncontracted legs. If there is a collision, both labels are dropped.\n    - Under `combine_legs`, labels get concatenated with a ``.`` delimiter and surrounded by brackets.\n      Example: let ``a.labels = {'a': 1, 'b': 2, 'c': 3}``.\n      Then if ``b = a.combine_legs([[0, 1], [2]])``, it will have ``b.labels = {'(a.b)': 0, '(c)': 1}``.\n      If some sub-leg of a combined leg isn't named, then a ``'?#'`` label is inserted (with ``#`` the leg index), e.g., ``'a.?0.c'``.\n    - Under `split_legs`, the labels are split using the delimiters (and the ``'?#'`` are dropped).\n    - Under `conj`, `iconj`: take  ``'a' -> 'a*'``, ``'a*' -> 'a'``, and ``'(a.(b*.c))' -> '(a*.(b.c*))'``\n    - Under `svd`, the outer labels are inherited, and inner labels can be optionally passed.\n    - Under `pinv`, the labels are transposed.\n\n\n\nIndexing of an Array\n--------------------\n\nAlthough it is usually not necessary to access single entries of an tenpy.linalg.np_conserved.Array, you can of course do that.\nIn the simplest case, this is something like ``A[0, 2, 1]`` for a rank-3 Array ``A``.\nHowever, accessing single entries is quite slow and usually not recommended. For small Arrays, it may be convenient to convert them\nback to flat numpy arrays with tenpy.linalg.np_conserved.Array.to_ndarray.\n\nOn top of that very basic indexing, `Array` supports slicing and some kind of advanced indexing, which is however\ndifferent from the one of numpy arrays (described `here <http://docs.scipy.org/doc/numpy/reference/arrays.indexing.html>`_).\nUnlike numpy arrays, our Array class does not broadcast existing index arrays -- this would be terribly slow.\nAlso, `np.newaxis` is not supported, since inserting new axes requires additional information for the charges.\n\nInstead, we allow just indexing of the legs independent of each other, of the form ``A[i0, i1, ...]``.\nIf all indices ``i0, i1, ...`` are integers, the single corresponding entry (of type `dtype`) is returned.\n\nHowever, the individual 'indices' ``i0`` for the individual legs can also be one of what is described in the following list.\nIn that case, a new tenpy.linalg.np_conserved.Array with less data (specified by the indices) is returned.\n\nThe 'indices' can be:\n\n- an `int`: fix the index of that axis, return array with one less dimension. See also tenpy.linalg.np_conserved.Array.take_slice.\n- a ``slice(None)`` or ``:``: keep the complete axis\n- an ``Ellipsis`` or ``...``: shorthand for ``slice(None)`` for missing axes to fix the len\n- an 1D bool `ndarray` ``mask``: apply a mask to that axis, see tenpy.linalg.np_conserved.Array.iproject.\n- a ``slice(start, stop, step)`` or ``start:stop:step``: keep only the indices specified by the slice. This is also implemented with `iproject`.\n- an 1D int `ndarray` ``mask``: keep only the indices specified by the array. This is also implemented with `iproject`.\n\nFor slices and 1D arrays, additional permutations may be performed with the help of tenpy.linalg.np_conserved.Array.permute.\n\nIf the number of indices is less than `rank`, the remaining axes remain free, so for a rank 4 Array ``A``, ``A[i0, i1] == A[i0, i1, ...] == A[i0, i1, :, :]``.\n\nNote that indexing always **copies** the data -- even if `int` contains just slices, in which case numpy would return a view.\nHowever, assigning with ``A[:, [3, 5], 3] = B`` should work as you would expect.\n\n\n    Due to numpy's advanced indexing, for 1D integer arrays ``a0`` and ``a1`` the following holds ::\n\n        A[a0, a1].to_ndarray() == A.to_ndarray()[np.ix_(a0, a1)] != A.to_ndarray()[a0, a1]\n\n    For a combination of slices and arrays, things get more complicated with numpys advanced indexing.\n    In that case, a simple ``np.ix_(...)`` doesn't help any more to emulate our version of indexing.\n\n\n\nDetails of the `np_conserved` implementation\n--------------------------------------------\n\nNotations\n+++++++++\nLets fix the notation of certain terms for this introduction and the doc-strings in tenpy.linalg.np_conserved.\nThis might be helpful if you know the basics from a different context.\nIf you're new to the subject, keep reading even if you don't understand each detail,\nand come back to this section when you encounter the corresponding terms again.\n\nA tenpy.linalg.np_conserved.Array is a multi-dimensional array representing a **tensor** with the entries:\n\n   T_{a_0, a_1, ... a_{rank-1}} \\quad \\text{ with } \\quad a_i \\in \\lbrace 0, ..., n_i-1 \\rbrace\n\nEach **leg** a_i corresponds the a vector space of dimension `n_i`.\n\nAn **index** of a leg is a particular value :math:`a_i \\in \\lbrace 0, ... ,n_i-1\\rbrace`.\n\nThe **rank** is the number of legs, the **shape** is :math:`(n_0, ..., n_{rank-1})`.\n\nWe restrict ourselves to abelian charges with entries in :math:`\\mathbb{Z}` or in :math:`\\mathbb{Z}_m`.\nThe nature of a charge is specified by m; we set :math:`m=1` for charges corresponding to :math:`\\mathbb{Z}`.\nThe number of charges is referred to as **qnumber** as a short hand, and the collection of m for each charge is called **qmod**.\nThe qnumber, qmod and possibly descriptive names of the charges are saved in an instance of tenpy.linalg.charges.ChargeInfo.\n\nTo each index of each leg, a value of the charge(s) is associated.\nA **charge block** is a contiguous slice corresponding to the same charge(s) of the leg.\nA **qindex** is an index in the list of charge blocks for a certain leg.\nA **charge sector** is for given charge(s) is the set of all qindices of that charge(s).\nA leg is **blocked** if all charge sectors map one-to-one to qindices.\nFinally, a leg is **sorted**, if the charges are sorted lexicographically.\nNote that a `sorted` leg is always `blocked`.\nWe can also speak of the complete array to be **blocked by charges** or **legcharge-sorted**,  which means that all of its legs are blocked or sorted, respectively.\nThe charge data for a single leg is collected in the class tenpy.linalg.charges.LegCharge.\nA tenpy.linalg.charges.LegCharge has also a flag **qconj**, which tells whether the charges\npoint *inward* (+1) or *outward* (-1). What that means, is explained later in nonzero_entries.\n\nFor completeness, let us also summarize also the internal structure of an tenpy.linalg.np_conserved.Array here:\nThe array saves only non-zero **blocks**, collected as a list of `np.array` in ``self._data``.\nThe qindices necessary to map these blocks to the original leg indices are collected in ``self._qdata``\nAn array is said to be **qdata-sorted** if its ``self._qdata`` is lexicographically sorted.\nMore details on this follow :ref:`later <array_storage_schema>`.\nHowever, note that you usually shouldn't access `_qdata` and `_data` directly - this\nis only necessary from within `tensordot`, `svd`, etc.\nAlso, an array has a **total charge**, defining which entries can be non-zero - details in nonzero_entries.\n\nFinally, a **leg pipe** (implemented in tenpy.linalg.charges.LegPipe)\nis used to formally combine multiple legs into one leg. Again, more details follow :ref:`later <leg_pipes>`.\n\n\nPhysical Example\n++++++++++++++++\nFor concreteness, you can think of the Hamiltonian :math:`H = -t \\sum_{<i,j>} (c^\\dagger_i c_j + H.c.) + U n_i n_j`\nwith :math:`n_i = c^\\dagger_i c_i`.\nThis Hamiltonian has the global :math:`U(1)` gauge symmetry :math:`c_i \\rightarrow c_i e^{i\\phi}`.\nThe corresponding charge is the total number of particles :math:`N = \\sum_i n_i`.\nYou would then introduce one charge with :math:`m=1`.\n\nNote that the total charge is a sum of local terms, living on single sites.\nThus, you can infer the charge of a single physical site: it's just the value :math:`q_i = n_i \\in \\mathbb{N}` for each of the states.\n\nNote that you can only assign integer charges. Consider for example the spin 1/2 Heisenberg chain.\nHere, you can naturally identify the magnetization :math:`S^z = \\sum_i S^z_i` as the conserved quantity,\nwith values :math:`S^z_i = \\pm \\frac{1}{2}`.\nObviously, if :math:`S^z` is conserved, then so is :math:`2 S^z`, so you can use the charges\n:math:`q_i = 2 S^z_i \\in \\lbrace-1, +1 \\rbrace` for the `down` and `up` states, respectively.\nAlternatively, you can also use a shift and define :math:`q_i = S^z_i + \\frac{1}{2} \\in \\lbrace 0, 1 \\rbrace`.\n\nAs another example, consider BCS like terms :math:`\\sum_k (c^\\dagger_k c^\\dagger_{-k} + H.c.)`.\nThese terms break the total particle conservation,\nbut they preserve the total parity, i.e., :math:`N \\mod 2` is conserved. Thus, you would introduce a charge with :math:`m = 2` in this case.\n\nIn the above examples, we had only a single charge conserved at a time, but you might be lucky and have multiple\nconserved quantities, e.g. if you have two chains coupled only by interactions.\nTeNPy is designed to handle the general case of multiple charges.\nWhen giving examples, we will restrict to one charge, but everything generalizes to multiple charges.\n\n\nThe different formats for LegCharge\n+++++++++++++++++++++++++++++++++++\nAs mentioned above, we assign charges to each index of each leg of a tensor.\nThis can be done in three formats: **qflat**, as **qind** and as **qdict**.\nLet me explain them with examples, for simplicity considering only a single charge (the most inner array has one entry\nfor each charge).\n\n**qflat** form: simply a list of charges for each index.\n    An example::\n\n        qflat = [[-2], [-1], [-1], [0], [0], [0], [0], [3], [3]]\n\n    This tells you that the leg has size 9, the charges for are ``[-2], [-1], [-1], ..., [3]`` for the indices ``0, 1, 2, 3,..., 8``.\n    You can identify four `charge blocks` ``slice(0, 1), slice(1, 3), slice(3, 7), slice(7, 9)`` in this example, which have charges ``[-2], [-1], [0], [3]``.\n    In other words, the indices ``1, 2`` (which are in ``slice(1, 3)``) have the same charge value ``[-1]``.\n    A `qindex` would just enumerate these blocks as ``0, 1, 2, 3``.\n\n**qind** form: a 1D array `slices` and a 2D array `charges`.\n    This is a more compact version than the `qflat` form:\n    the `slices` give a partition of the indices and the `charges` give the charge values. The same example as above\n    would simply be::\n\n        slices = [0, 1, 3, 7, 9]\n        charges = [[-2], [-1], [0], [3]]\n\n\n    Note that  `slices` includes ``0`` as first entry and the number of indices (here ``9``) as last entries.\n    Thus it has len ``block_number + 1``, where ``block_number`` (given by tenpy.linalg.charges.LegCharge.block_number)\n    is the number of charge blocks in the leg, i.e. a `qindex` runs from 0 to ``block_number-1``.\n    On the other hand, the 2D array `charges` has shape ``(block_number, qnumber)``, where ``qnumber`` is the\n    number of charges (given by tenpy.linalg.charges.ChargeInfo.qnumber).\n\n    In that way, the `qind` form maps an `qindex`, say ``qi``, to the indices ``slice(slices[qi], slices[qi+1])`` and\n    the charge(s) ``charges[qi]``.\n\n\n**qdict** form: a dictionary in the other direction than qind, taking charge tuples to slices.\n    Again for the same example::\n\n        {(-2,): slice(0, 1),\n         (-1,): slice(1, 3),\n         (0,) : slice(3, 7),\n         (3,) : slice(7, 9)}\n\n    Since the keys of a dictionary are unique, this form is only possible if the leg is `completely blocked`.\n\n\nThe tenpy.linalg.charges.LegCharge saves the charge data of a leg internally in `qind` form,\ndirectly in the attribute `slices` and `charges`.\nHowever, it also provides convenient functions for conversion between from and to the `qflat` and `qdict` form.\n\nThe above example was nice since all charges were sorted and the charge blocks were 'as large as possible'.\nThis is however not required.\n\nThe following example is also a valid `qind` form::\n\n    slices = [0, 1, 3, 5, 7, 9]\n    charges = [[-2], [-1], [0], [0], [3]]\n\nThis leads to the *same* `qflat` form as the above examples, thus representing the same charges on the leg indices.\nHowever, regarding our Arrays, this is quite different, since it divides the leg into 5 (instead of previously 4)\ncharge blocks. We say the latter example is `not bunched`, while the former one is `bunched`.\n\nTo make the different notions of `sorted` and `bunched` clearer, consider the following (valid) examples:\n\n================================  =========  =========  ==========\ncharges                           bunched    sorted     blocked\n================================  =========  =========  ==========\n``[[-2], [-1], [0], [1], [3]]``   ``True``   ``True``   ``True``\n--------------------------------  ---------  ---------  ----------\n``[[-2], [-1], [0], [0], [3]]``   ``False``  ``True``   ``False``\n--------------------------------  ---------  ---------  ----------\n``[[-2], [0], [-1], [1], [3]]``   ``True``   ``False``  ``True``\n--------------------------------  ---------  ---------  ----------\n``[[-2], [0], [-1], [0], [3]]``   ``True``   ``False``  ``False``\n================================  =========  =========  ==========\n\nIf a leg is `bunched` and `sorted`, it is automatically `blocked` (but not vice versa).\nSee also :ref:`below <blocking>` for further comments on that.\n\n\n\nWhich entries of the npc Array can be non-zero?\n+++++++++++++++++++++++++++++++++++++++++++++++\nThe reason for the speedup with np_conserved lies in the fact that it saves only the blocks 'compatible' with the charges.\nBut how is this 'compatible' defined?\n\nAssume you have a tensor, call it T, and the tenpy.linalg.charges.LegCharge for all of its legs, say :math:`a, b, c, ...`.\n\nRemember that the LegCharge associates to each index of the leg a charge value (for each of the charges, if `qnumber` > 1).\nLet ``a.to_qflat()[ia]`` denote the charge(s) of index ``ia`` for leg ``a``, and similar for other legs.\n\nIn addition, the LegCharge has a flag tenpy.linalg.charges.LegCharge.qconj. This flag **qconj** is only a sign,\nsaved as +1 or -1, specifying whether the charges point 'inward' (+1, default) or 'outward' (-1) of the tensor.\n\nThen, the **total charge of an entry** ``T[ia, ib, ic, ...]`` of the tensor is defined as::\n\n   qtotal[ia, ib, ic, ...] = a.to_qflat()[ia] * a.qconj + b.to_qflat()[ib] * b.qconj + c.to_qflat()[ic] * c.qconj + ...  modulo qmod\n\nThe rule which entries of the a tenpy.linalg.np_conserved.Array can be non-zero\n(i.e., are 'compatible' with the charges), is then very simple:\n\n\n    An entry ``ia, ib, ic, ...`` of a tenpy.linalg.np_conserved.Array can only be non-zero,\n    if ``qtotal[ia, ib, ic, ...]`` matches the *unique* tenpy.linalg.np_conserved.qtotal attribute of the class.\n\nIn other words, there is a *single* **total charge** ``.qtotal`` attribute of a tenpy.linalg.np_conserved.Array.\nAll indices ``ia, ib, ic, ...`` for which the above defined ``qtotal[ia, ib, ic, ...]`` matches this `total charge`,\nare said to be **compatible with the charges** and can be non-zero.\nAll other indices are **incompatible with the charges** and must be zero.\n\nIn case of multiple charges, `qnumber` > 1, is a straight-forward generalization:\nan entry can only be non-zero if it is `compatible` with each of the defined charges.\n\n\nThe pesky qconj - contraction as an example\n+++++++++++++++++++++++++++++++++++++++++++\nWhy did we introduce the ``qconj`` flag? Remember it's just a sign telling whether the charge points inward or outward.\nSo whats the reasoning?\n\nThe short answer is, that LegCharges actually live on bonds (i.e., legs which are to be contracted)\nrather than individual tensors. Thus, it is convenient to share the LegCharges between different legs and even tensors,\nand just adjust the sign of the charges with `qconj`.\n\nAs an example, consider the contraction of two tensors, :math:`C_{ia,ic} = \\sum_{ib} A_{ia,ib} B_{ib,ic}`.\nFor simplicity, say that the total charge of all three tensors is zero.\nWhat are the implications of the above rule for non-zero entries?\nOr rather, how can we ensure that ``C`` complies with the above rule?\nAn entry ``C[ia,ic]`` will only be non-zero,\nif there is an ``ib`` such that both ``A[ia,ib]`` and ``B[ib,ic]`` are non-zero, i.e., both of the following equations are\nfulfilled::\n\n    A.qtotal == A.legs[0].to_qflat()[ia] * A.legs[0].qconj + A.legs[1].to_qflat()[ib] * A.legs[1].qconj  modulo qmod\n    B.qtotal == B.legs[0].to_qflat()[ib] * B.legs[0].qconj + B.legs[1].to_qflat()[ic] * B.legs[1].qconj  modulo qmod\n\n(``A.legs[0]`` is the tenpy.linalg.charges.LegCharge saving the charges of the first leg (with index ``ia``) of `A`.)\n\nFor the uncontracted legs, we just keep the charges as they are::\n\n    C.legs = [A.legs[0], B.legs[1]]\n\nIt is then straight-forward to check, that the rule is fulfilled for C, if the following condition is met::\n\n   A.qtotal + B.qtotal - C.qtotal == A.legs[1].to_qflat()[ib] A.b.qconj + B.legs[0].to_qflat()[ib] B.b.qconj  modulo qmod\n\nThe easiest way to meet this condition is (1) to require that ``A.b`` and ``B.b`` share the *same* charges ``b.to_qflat()``, but have\nopposite `qconj`, and (2) to define ``C.qtotal = A.qtotal + B.qtotal``.\nThis justifies the introduction of `qconj`:\nwhen you define the tensors, you have to define the tenpy.linalg.charges.LegCharge for the `b` only once, say for ``A.legs[1]``.\nFor ``B.legs[0]`` you simply use ``A.legs[1].conj()`` which creates a copy of the LegCharge with shared `slices` and `charges`, but opposite `qconj`.\nAs a more impressive example, all 'physical' legs of an MPS can usually share the same\ntenpy.linalg.charges.LegCharge (up to different ``qconj`` if the local Hilbert space is the same).\nThis leads to the following convention:\n\n\n   When an npc algorithm makes tensors which share a bond (either with the input tensors, as for tensordot, or amongst the output tensors, as for SVD),\n   the algorithm is free, but not required, to use the **same** LegCharge for the tensors sharing the bond, *without* making a copy.\n   Thus, if you want to modify a LegCharge, you **must** make a copy first (e.g. by using methods of LegCharge for what you want to achieve).\n\n\nAssigning charges to non-physical legs\n++++++++++++++++++++++++++++++++++++++\nFrom the above physical examples, it should be clear how you assign charges to physical legs.\nBut what about other legs, e.g, the virtual bond of an MPS (or an MPO)?\n\nThe charge of these bonds must be derived by using the 'rule for non-zero entries', as far as they are not arbitrary.\nAs a concrete example, consider an MPS on just two spin 1/2 sites::\n\n    |        _____         _____\n    |   x->- | A | ->-y->- | B | ->-z\n    |        -----         -----\n    |          ^             ^\n    |          |p            |p\n\nThe two legs ``p`` are the physical legs and share the same charge, as they both describe the same local Hilbert space.\nFor better distinction, let me label the indices of them by :math:`\\uparrow=0` and :math:`\\downarrow=1`.\nAs noted above, we can associate the charges 1 (:math:`p=\\uparrow`) and -1 (:math:`p=\\downarrow`), respectively, so we define::\n\n    chinfo = npc.ChargeInfo([1], ['2*Sz'])\n    p  = npc.LegCharge.from_qflat(chinfo, [1, -1], qconj=+1)\n\nFor the ``qconj`` signs, we stick to the convention used in our MPS code and indicated by the\narrows in above 'picture': physical legs are incoming (``qconj=+1``), and from left to right on the virtual bonds.\nThis is achieved by using ``[p, x, y.conj()]`` as `legs` for ``A``, and ``[p, y, z.conj()]`` for ``B``, with the\ndefault ``qconj=+1`` for all ``p, x, y, z``: ``y.conj()`` has the same charges as ``y``, but opposite ``qconj=-1``.\n\nThe legs ``x`` and ``z`` of an ``L=2`` MPS, are 'dummy' legs with just one index ``0``.\nThe charge on one of them, as well as the total charge of both ``A`` and ``B`` is arbitrary (i.e., a gauge freedom),\nso we make a simple choice: total charge 0 on both arrays, as well as for :math:`x=0`,\n``x = npc.LegCharge.from_qflat(chinfo, [0], qconj=+1)``.\n\nThe charges on the bonds `y` and `z` then depend on the state the MPS represents.\nHere, we consider a singlet :math:`\\psi = (|\\uparrow \\downarrow\\rangle  - |\\downarrow \\uparrow\\rangle)/\\sqrt{2}`\nas a simple example. A possible MPS representation is given by::\n\n    A[up, :, :]   = [[1/2.**0.5, 0]]     B[up, :, :]   = [[0], [-1]]\n    A[down, :, :] = [[0, 1/2.**0.5]]     B[down, :, :] = [[1], [0]]\n\nThere are two non-zero entries in ``A``, for the indices :math:`(a, x, y) = (\\uparrow, 0, 0)` and :math:`(\\downarrow, 0, 1)`.\nFor :math:`(a, x, y) = (\\uparrow, 0, 0)`, we want::\n\n    A.qtotal = 0 = p.to_qflat()[up] * p.qconj + x.to_qflat()[0] * x.qconj + y.conj().to_qflat()[0] * y.conj().qconj\n                 = 1                * (+1)    + 0               * (+1)    + y.conj().to_qflat()[0] * (-1)\n\nThis fixes the charge of ``y=0`` to 1.\nA similar calculation for :math:`(a, x, y) = (\\downarrow, 0, 1)` yields the charge ``-1`` for ``y=1``.\nWe have thus all the charges of the leg ``y`` and can define ``y = npc.LegCharge.from_qflat(chinfo, [1, -1], qconj=+1)``.\n\nNow take a look at the entries of ``B``.\nFor the non-zero entry :math:`(b, y, z) = (\\uparrow, 1, 0)`, we want::\n\n    B.qtotal = 0 = p.to_qflat()[up] * p.qconj + y.to_qflat()[1] * y.qconj + z.conj().to_qflat()[0] * z.conj().qconj\n                 = 1                * (+1)    + (-1)            * (+1)    + z.conj().to_qflat()[0] * (-1)\n\nThis implies the charge 0 for `z` = 0, thus ``z = npc.LegCharge.form_qflat(chinfo, [0], qconj=+1)``.\nFinally, note that the rule for :math:`(b, y, z) = (\\downarrow, 0, 0)` is automatically fulfilled!\nThis is an implication of the fact that the singlet has a well defined value for :math:`S^z_a + S^z_b`.\nFor other states without fixed magnetization (e.g., :math:`|\\uparrow \\uparrow\\rangle + |\\downarrow \\downarrow\\rangle`)\nthis would not be the case, and we could not use charge conservation.\n\nAs an exercise, you can calculate the charge of `z` in the case that ``A.qtotal=5``, ``B.qtotal = -1`` and\ncharge ``2`` for ``x=0``. The result is -2.\n\n\n    This section is meant be an pedagogical introduction. In you program, you can use the functions\n    tenpy.linalg.np_conserved.detect_legcharge (which does exactly what's described above) or\n    tenpy.linalg.np_conserved.detect_qtotal (if you know all `LegCharges`, but not `qtotal`).\n\nArray creation\n++++++++++++++\n\nDirect creation\n^^^^^^^^^^^^^^^\n\nMaking an new tenpy.linalg.np_conserved.Array requires both the tensor entries (data) and charge data.\n\nThe default initialization ``a = Array(...)`` creates an empty Array, where all entries are zero\n(equivalent to tenpy.linalg.np_conserved.zeros).\n(Non-zero) data can be provided either as a dense `np.array` to tenpy.linalg.np_conserved.Array.from_ndarray,\nor by providing a numpy function such as `np.random`, `np.ones` etc. to tenpy.linalg.np_conserved.Array.from_func.\n\nIn both cases, the charge data is provided by one tenpy.linalg.charges.ChargeInfo,\nand a tenpy.linalg.charges.LegCharge instance for each of the legs.\n\n\n    The charge data instances are not copied, in order to allow it to be shared between different Arrays.\n    Consequently, you *must* make copies of the charge data, if you manipulate it directly.\n    (However, methods like tenpy.linalg.charges.LegCharge.sort do that for you.)\n\n\nIndirect creation by manipulating existing arrays\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOf course, a new tenpy.linalg.np_conserved.Array can also created using the charge data from existing Arrays,\nfor example with tenpy.linalg.np_conserved.Array.zeros_like or creating a (deep or shallow) tenpy.linalg.np_conserved.Array.copy.\nFurther, there are many higher level functions like tenpy.linalg.np_conserved.tensordot or tenpy.linalg.np_conserved.svd,\nwhich also return new Arrays.\n\n\n\nComplete blocking of Charges\n++++++++++++++++++++++++++++\n\nWhile the code was designed in such a way that each charge sector has a different charge, the code\nshould still run correctly if multiple charge sectors (for different qindex) correspond to the same charge.\nIn this sense tenpy.linalg.np_conserved.Array can act like a sparse array class to selectively store subblocks.\nAlgorithms which need a full blocking should state that explicitly in their doc-strings.\n(Some functions (like `svd` and `eigh`) require complete blocking internally, but if necessary they just work on\na temporary copy returned by tenpy.linalg.np_conserved.as_completely_blocked).\n\nIf you expect the tensor to be dense subject to charge constraints (as for MPS),\nit will be most efficient to fully block by charge, so that work is done on large chunks.\n\nHowever, if you expect the tensor to be sparser than required by charge (as for an MPO),\nit may be convenient not to completely block, which forces smaller matrices to be stored, and hence many zeroes to be dropped.\nNevertheless, the algorithms were not designed with this in mind, so it is not recommended in general.\n(If you want to use it, run a benchmark to check whether it is really faster!)\n\nIf you haven't created the array yet, you can call tenpy.linalg.charges.LegCharge.sort (with ``bunch=True``)\non each tenpy.linalg.charges.LegCharge which you want to block.\nThis sorts by charges and thus induces a permutation of the indices, which is also returned as an 1D array ``perm``.\nFor consistency, you have to apply this permutation to your flat data as well.\n\nAlternatively, you can simply call tenpy.linalg.np_conserved.Array.sort_legcharge on an existing tenpy.linalg.np_conserved.Array.\nIt calls tenpy.linalg.charges.LegCharge.sort internally on the specified legs and performs the necessary\npermutations directly to (a copy of) `self`. Yet, you should keep in mind, that the axes are permuted afterwards.\n\n\n\nInternal Storage schema of npc Arrays\n+++++++++++++++++++++++++++++++++++++\n\nThe actual data of the tensor is stored in ``_data``. Rather than keeping a single np.array (which would have many zeros in it),\nwe store only the non-zero sub blocks. So ``_data`` is a python list of `np.array`'s.\nThe order in which they are stored in the list is not physically meaningful, and so not guaranteed (more on this later).\nSo to figure out where the sub block sits in the tensor, we need the ``_qdata`` structure (on top of the LegCharges in ``legs``).\n\nConsider a rank 3 tensor ``T``, with the first leg like::\n\n    legs[0].slices = np.array([0, 1, 4, ...])\n    legs[0].charges = np.array([[-2], [1], ...])\n\nEach row of `charges` gives the charges for a `charge block` of the leg, with the actual indices of the\ntotal tensor determined by the `slices`.\nThe *qindex* simply enumerates the charge blocks of a lex.\nPicking a qindex (and thus a `charge block`) from each leg, we have a subblock of the tensor.\n\nFor each (non-zero) subblock of the tensor, we put a (numpy) ndarray entry in the ``_data`` list.\nSince each subblock of the tensor is specified by `rank` qindices,\nwe put a corresponding entry in ``_qdata``, which is a 2D array of shape ``(#stored_blocks, rank)``.\nEach row corresponds to a non-zero subblock, and there are rank columns giving the corresponding qindex for each leg.\n\nExample: for a rank 3 tensor we might have::\n\n    T._data = [t1, t2, t3, t4, ...]\n    T._qdata = np.array([[3, 2, 1],\n                         [1, 1, 1],\n                         [4, 2, 2],\n                         [2, 1, 2],\n                         ...       ])\n\nThe third subblock has an ndarray ``t3``, and qindices ``[4 2 2]`` for the three legs.\n\n- To find the position of ``t3`` in the actual tensor you can use tenpy.linalg.charges.LegCharge.get_slice::\n\n            T.legs[0].get_slice(4), T.legs[1].get_slice(2), T.legs[2].get_slice(2)\n\n  The function ``leg.get_charges(qi)`` simply returns ``slice(leg.slices[qi], leg.slices[qi+1])``\n\n- To find the charges of t3, we an use tenpy.linalg.charges.LegCharge.get_charge::\n\n            T.legs[0].get_charge(2), T.legs[1].get_charge(2), T.legs[2].get_charge(2)\n\n  The function ``leg.get_charge(qi)`` simply returns ``leg.charges[qi]*leg.qconj``.\n\n\n   Outside of `np_conserved`, you should use the API to access the entries.\n   If you really need to iterate over all blocks of an Array ``T``, try ``for (block, blockslices, charges, qindices) in T: do_something()``.\n\nThe order in which the blocks stored in ``_data``/``_qdata`` is arbitrary (although of course ``_data`` and ``_qdata`` must be in correspondence).\nHowever, for many purposes it is useful to sort them according to some convention.  So we include a flag ``._qdata_sorted`` to the array.\nSo, if sorted (with tenpy.linalg.np_conserved.Array.isort_qdata, the ``_qdata`` example above goes to ::\n\n    _qdata = np.array([[1, 1, 1],\n                       [3, 2, 1],\n                       [2, 1, 2],\n                       [4, 2, 2],\n                       ...       ])\n\nNote that `np.lexsort` chooses the right-most column to be the dominant key, a convention we follow throughout.\n\nIf ``_qdata_sorted == True``, ``_qdata`` and ``_data`` are guaranteed to be lexsorted. If ``_qdata_sorted == False``, there is no guarantee.\nIf an algorithm modifies ``_qdata``, it **must** set ``_qdata_sorted = False`` (unless it guarantees it is still sorted).\nThe routine tenpy.linalg.np_conserved.Array.sort_qdata brings the data to sorted form.\n\n\n\nDipole Conservation\n-------------------\n\nNormally, a conserved charge has the form :math:`Q = \\sum_i q_i` where the local charge q_i\nis (the expectation value of) some operator which does not explicitly depend on the position of the\nsite i it acts on. E.g. :math:`q_i = 2 * S_i^z` is independent of i in that sense.\n\nSome models, see e.g. tenpy.models.spins.DipolarSpinChain, have a symmetry which conserves\na charge that does not follow the above scheme.\nThe dipole charge of this model is :math:`P = \\sum_i p_i = \\sum_i r_i q_i`, where r_i is the\nposition of the site i. Clearly, the local charge p_i depends in the position of\nthe site i.\n\nWe support a general framework for conserved charges where the local charge has some non-trivial\ntransformation properties under spatial translations.\nWe do require, however, that the effect of spatial translation on a charge is independent of\nthe starting position and only depends on the vector of translation.\nRelaxing this assumption (e.g. to conserve quadrupole moments) would require substantially more\nbook-keeping and I (Jakob Unfried) am not even sure infinite MPS with such charges can be well\ndefined.\n\nWe internally refer to such symmetries as \"shift-symmetry\" and we call the transformation of\ncharges / legs / sites or arrays that results from spatial translations \"shifting\".\nWe implement methods in tenpy.linalg.charges.ChargeInfo that define how the charges\ntransform. The base class tenpy.linalg.charges.ChargeInfo implements only trivial\nversions of these methods, that do not change the charges at all.\nIt models charges with trivial translation properties, indicated by\ntenpy.linalg.charges.ChargeInfo.trivial_shift being ``True``.\nNon-trivially transforming charges should then be implemented in subclasses, such as\ntenpy.linalg.charges.DipolarChargeInfo.\n\nThe subclass tenpy.linalg.charges.DipolarChargeInfo supports one (or multiple) charges of\nthe dipole form above, i.e. :math:`p_i = r_i q_i` where q_i is another \"normal\" conserved\ncharge. See its docstring for further details on how to use it\nand tenpy.models.spins.DipolarSpinChain as an example that does.\n\nSuch a charge with non-tenpy.linalg.charges.ChargeInfo.trivial_shift has the following main\nimplications for MPS simulations in tenpy\n\n- The tenpy.networks.mps.MPS.sites of an MPS are no longer just given by the sites in the\n  tenpy.models.lattice.Lattice.unit_cell. If the MPS unit cell consists of multiple unit\n  cells of the lattice, the new positions of the site need be considered, since they affect the\n  charge values of the p_i on the respective physical legs.\n  We perform this shift in tenpy.models.lattice.Lattice.mps_sites.\n\n- For sweeping algorithms using infinite MPS, the charges also need to be adjusted when neighboring\n  unit cells are inserted, e.g. when a two-site update on sites ``L - 1, L`` is performed, the\n  (i)MPS tensor on site ``L`` is not the *same* as the one on site ``0``, but rather a shifted version.\n  We account for this in tenpy.networks.mps.MPS.get_B, tenpy.networks.mps.MPS.set_B\n  and in the similar methods for `S`.\n  Generally speaking , whenever the identification of arrays, sites or any quantity that carries\n  charge, between different unit cells of the iMPS is used, shifting needs to be taken into account.\n\nThe method tenpy.ChargeInfo.shift_charges implements how the local charge\nchanges when moved from one site to another. It takes an arbitrary translation vector as an\nargument. It is used, e.g., to create the tenpy.linalg.models.lattice.Lattice.mps_sites\nfrom the tenpy.linalg.models.lattice.Lattice.unit_cell of the lattice.\nIt turns out that the MPS algorithms only need a specialized version,\ntenpy.ChargeInfo.shift_charges_horizontal, which restricts to translations that are purely\nalong the first dimension of the lattice.\n\nIn the setting of using MPS in algorithms, we want to be as agnostic of the lattice geometry as\npossible. It turns out that in the concrete algorithms, and only for infinite MPS, we only need\nto shift Arrays / sites / charged by whole MPS unit cells (of length tenpy.MPS.L).\nThis is implemented in tenpy.MPS.shift_Array_unit_cell, etc., which uses the\ntenpy.networks.mps.MPSGeometry.unit_cell_width of the MPS, which is now also an attr of MPS.\n\nSee also\n--------\n- The module tenpy.linalg.np_conserved should contain all the API needed from the point of view of the algorithms.\n  It contains the fundamental tenpy.linalg.np_conserved.Array class and functions for working with them (creating and manipulating).\n- The module tenpy.linalg.charges contains implementations for the charge structure, for example the classes\n  tenpy.linalg.charges.ChargeInfo, tenpy.linalg.charges.LegCharge, and tenpy.linalg.charges.LegPipe.\n  As noted above, the 'public' API is imported to (and accessible from) tenpy.linalg.np_conserved.\n\nA full example code for spin-1/2\n--------------------------------\nBelow follows a full example demonstrating the creation and contraction of Arrays.\n(It's the file `a_np_conserved.py` in the examples folder of the tenpy source.)\n",
    "search_text": "doc.npc --- documentation: npc ---\ncharge conservation with np_conserved\n=====================================\n\nthe basic idea is quickly summarized:\nby inspecting the hamiltonian, you can identify symmetries, which correspond to conserved quantities, called **charges**.\nthese charges divide the tensors into different sectors. this can be used to infer for example a block-diagonal structure\nof certain matrices, which in turn speeds up svd or diagonalization a lot.\neven for more general (non-square-matrix) tensors, charge conservation imposes restrictions which blocks of a tensor can\nbe non-zero. only those blocks need to be saved, which ultimately (= for large enough arrays) leads to a speedup of many routines, e.g., tensordot.\n\nthis introduction covers our implementation of charges; explaining mathematical details of the underlying symmetry is beyond its scope.\nwe refer you to the corresponding chapter in our [tenpynotes]_ for a more general introduction of the idea (also stating\nthe \"charge rule\" introduced below).\nsingh2010 explains why it works form a mathematical point of view, singh2011 has the focus on a :math:`u(1)` symmetry and might be easier to read.\n\n\nwhat you really need to know about `np_conserved`\n-------------------------------------------------\n\nthe good news is: it is not necessary to understand all the details explained in the following sections\nif you just want to use tenpy for \"standard\" simulations like tebd and dmrg.\nin praxis, **you will likely not have to define the charges by yourself**.\nfor most simulations using tenpy, the charges are initially defined in the tenpy.networks.site.site;\nand there are many pre-defined sites like the :class:tenpy.networks.site.spinhalfsite, which you can just use.\nthe sites in turn are initialized by the model class you are using (see also :doc:`/intro/model`).\nfrom there, all the necessary charge information is automatically propagated along with the tensors.\n\n\nhowever, you should definitely know a few basic facts about the usage of charge conservation in tenpy:\n\n- instead of using numpy arrays, tensors are represented by the tenpy.linalg.np_conserved.array class.\n  this class is defined in tenpy.linalg.np_conserved (the name standing for \"numpy with charge conservation\").\n  internally, it stores only non-zero blocks of the tensor, which are \"compatible\" with the charges of the indices.\n  it **has to have a well defined overall charge** tenpy.linalg.np_conserved.array.qtotal.\n  this **excludes certain operators** (like :math:`s^x` for sz conservation) and mps which are a superpositions of states in different charge sectors.\n- there is a class tenpy.linalg.charges.chargeinfo holding the general information what kind of charges we have,\n  and a tenpy.linalg.charges.legcharge for the charge data on a given leg. the leg holds a flag `qconj` which\n  is +1 or -1, depending on whether the leg goes into the tensor (representing a vector space)\n  or out of the tensor (representing the corresponding dual vector space).\n- besides the array class methods, there are a bunch of functions like tenpy.linalg.np_conserved.tensordot,\n  tenpy.linalg.np_conserved.svd or tenpy.linalg.np_conserved.eigh to manipulate tensors.\n  these function have a very similar call structure as the corresponding numpy functions, but they act on our tensor\n  array class, and preserve the block structure (and exploit it for speed, wherever possible).\n- the only allowed \"reshaping\" operations for those tensors are to combine legs and to split previously combined legs.\n  see the corresponding :ref:`section below <leg_pipes>`.\n- it is convenient to use string labels instead of numbers to refer to the various legs of a tensor.\n  the rules how these labels change during the various operations are also described a :ref:`section below <leg_labeling>`.\n\n\n\nintroduction to combine_legs, split_legs and legpipes\n-----------------------------------------------------\n\noften, it is necessary to \"combine\" multiple legs into one: for example to perform a svd, a tensor needs to be viewed as a matrix.\nfor a flat array, this can be done with ``np.reshape``, e.g., if ``a`` has shape ``(10, 3, 7)`` then ``b = np.reshape(a, (30, 7))`` will\nresult in a (view of the) array with one less dimension, but a \"larger\" first leg. by default (``order='c'``), this\nresults in ::\n\n    b[i*3 + j , k] == a[i, j, k] for i in range(10) for j in range(3) for k in range(7)\n\nwhile for a np.array, also a reshaping ``(10, 3, 7) -> (2, 21, 5)`` would be allowed, it does not make sense\nphysically. the only sensible \"reshape\" operation on an tenpy.linalg.np_conserved.array are\n\n1) to **combine** multiple legs into one **leg pipe** (tenpy.linalg.charges.legpipe) with  tenpy.linalg.np_conserved.array.combine_legs, or\n2) to **split** a pipe of previously combined legs with tenpy.linalg.np_conserved.array.split_legs.\n\neach leg has a hilbert space, and a representation of the symmetry on that hilbert space.\ncombining legs corresponds to the tensor product operation, and for abelian groups,\nthe corresponding \"fusion\" of the representation is the simple addition of charge.\n\nfusion is not a lossless process, so if we ever want to split the combined leg,\nwe need some additional data to tell us how to reverse the tensor product.\nthis data is saved in the class tenpy.linalg.charges.legpipe, derived from the tenpy.linalg.charges.legcharge and used as new `leg`.\ndetails of the information contained in a legpipe are given in the class doc string.\n\nthe rough usage idea is as follows:\n\n1) you can call tenpy.linalg.np_conserved.array.combine_legs without supplying any legpipes, `combine_legs` will then make them for you.\n\n   nevertheless, if you plan to perform the combination over and over again on sets of legs you know to be identical\n   [with same charges etc, up to an overall -1 in `qconj` on all incoming and outgoing legs]\n   you might make a legpipe anyway to save on the overhead of computing it each time.\n2) in any way, the resulting array will have a tenpy.linalg.charges.legpipe as a legcharge on the combined leg.\n   thus, it -- and all tensors inheriting the leg (e.g. the results of `svd`, `tensordot` etc.) -- will have the information\n   how to split the `legpipe` back to the original legs.\n3) once you performed the necessary operations, you can call tenpy.linalg.array.split_legs.\n   this uses the information saved in the `legpipe` to split the legs, recovering the original legs.\n\nfor a legpipe, tenpy.linalg.charges.legpipe.conj changes ``qconj`` for the outgoing pipe *and* the incoming legs.\nif you need a `legpipe` with the same incoming ``qconj``, use tenpy.linalg.charges.legpipe.outer_conj.\n\n\n\nleg labeling\n------------\n\nit's convenient to name the legs of a tensor: for instance, we can name legs 0, 1, 2 to be ``'a', 'b', 'c'``: :math:`t_{i_a,i_b,i_c}`.\nthat way we don't have to remember the ordering! under tensordot, we can then call ::\n\n    u = npc.tensordot(s, t, axes = [ [...],  ['b'] ] )\n\nwithout having to remember where exactly ``'b'`` is.\nobviously ``u`` should then inherit the name of its legs from the uncontracted legs of `s` and `t`.\nso here is how it works:\n\n- labels can *only* be strings. the labels should not include the characters ``.`` or ``?``.\n  internally, the labels are stored as dict ``a.labels = {label: leg_position, ...}``. not all legs need a label.\n- to set the labels, call ::\n\n        a.set_labels(['a', 'b', none, 'c', ... ])\n\n  which will set up the labeling ``{'a': 0, 'b': 1, 'c': 3 ...}``.\n\n- (where implemented) the specification of axes can use either the labels **or** the index positions.\n  for instance, the call ``tensordot(a, b, [['a', 2, 'c'], [...]])`` will interpret ``'a'`` and  ``'c'`` as labels\n  (calling tenpy.linalg.np_conserved.array.get_leg_indices to find their positions using the dict)\n  and 2 as 'the 2nd leg'. that's why we require labels to be strings!\n- labels will be intelligently inherited through the various operations of `np_conserved`.\n    - under `transpose`, labels are permuted.\n    - under `tensordot`, labels are inherited from uncontracted legs. if there is a collision, both labels are dropped.\n    - under `combine_legs`, labels get concatenated with a ``.`` delimiter and surrounded by brackets.\n      example: let ``a.labels = {'a': 1, 'b': 2, 'c': 3}``.\n      then if ``b = a.combine_legs([[0, 1], [2]])``, it will have ``b.labels = {'(a.b)': 0, '(c)': 1}``.\n      if some sub-leg of a combined leg isn't named, then a ``'?#'`` label is inserted (with ``#`` the leg index), e.g., ``'a.?0.c'``.\n    - under `split_legs`, the labels are split using the delimiters (and the ``'?#'`` are dropped).\n    - under `conj`, `iconj`: take  ``'a' -> 'a*'``, ``'a*' -> 'a'``, and ``'(a.(b*.c))' -> '(a*.(b.c*))'``\n    - under `svd`, the outer labels are inherited, and inner labels can be optionally passed.\n    - under `pinv`, the labels are transposed.\n\n\n\nindexing of an array\n--------------------\n\nalthough it is usually not necessary to access single entries of an tenpy.linalg.np_conserved.array, you can of course do that.\nin the simplest case, this is something like ``a[0, 2, 1]`` for a rank-3 array ``a``.\nhowever, accessing single entries is quite slow and usually not recommended. for small arrays, it may be convenient to convert them\nback to flat numpy arrays with tenpy.linalg.np_conserved.array.to_ndarray.\n\non top of that very basic indexing, `array` supports slicing and some kind of advanced indexing, which is however\ndifferent from the one of numpy arrays (described `here <http://docs.scipy.org/doc/numpy/reference/arrays.indexing.html>`_).\nunlike numpy arrays, our array class does not broadcast existing index arrays -- this would be terribly slow.\nalso, `np.newaxis` is not supported, since inserting new axes requires additional information for the charges.\n\ninstead, we allow just indexing of the legs independent of each other, of the form ``a[i0, i1, ...]``.\nif all indices ``i0, i1, ...`` are integers, the single corresponding entry (of type `dtype`) is returned.\n\nhowever, the individual 'indices' ``i0`` for the individual legs can also be one of what is described in the following list.\nin that case, a new tenpy.linalg.np_conserved.array with less data (specified by the indices) is returned.\n\nthe 'indices' can be:\n\n- an `int`: fix the index of that axis, return array with one less dimension. see also tenpy.linalg.np_conserved.array.take_slice.\n- a ``slice(none)`` or ``:``: keep the complete axis\n- an ``ellipsis`` or ``...``: shorthand for ``slice(none)`` for missing axes to fix the len\n- an 1d bool `ndarray` ``mask``: apply a mask to that axis, see tenpy.linalg.np_conserved.array.iproject.\n- a ``slice(start, stop, step)`` or ``start:stop:step``: keep only the indices specified by the slice. this is also implemented with `iproject`.\n- an 1d int `ndarray` ``mask``: keep only the indices specified by the array. this is also implemented with `iproject`.\n\nfor slices and 1d arrays, additional permutations may be performed with the help of tenpy.linalg.np_conserved.array.permute.\n\nif the number of indices is less than `rank`, the remaining axes remain free, so for a rank 4 array ``a``, ``a[i0, i1] == a[i0, i1, ...] == a[i0, i1, :, :]``.\n\nnote that indexing always **copies** the data -- even if `int` contains just slices, in which case numpy would return a view.\nhowever, assigning with ``a[:, [3, 5], 3] = b`` should work as you would expect.\n\n\n    due to numpy's advanced indexing, for 1d integer arrays ``a0`` and ``a1`` the following holds ::\n\n        a[a0, a1].to_ndarray() == a.to_ndarray()[np.ix_(a0, a1)] != a.to_ndarray()[a0, a1]\n\n    for a combination of slices and arrays, things get more complicated with numpys advanced indexing.\n    in that case, a simple ``np.ix_(...)`` doesn't help any more to emulate our version of indexing.\n\n\n\ndetails of the `np_conserved` implementation\n--------------------------------------------\n\nnotations\n+++++++++\nlets fix the notation of certain terms for this introduction and the doc-strings in tenpy.linalg.np_conserved.\nthis might be helpful if you know the basics from a different context.\nif you're new to the subject, keep reading even if you don't understand each detail,\nand come back to this section when you encounter the corresponding terms again.\n\na tenpy.linalg.np_conserved.array is a multi-dimensional array representing a **tensor** with the entries:\n\n   t_{a_0, a_1, ... a_{rank-1}} \\quad \\text{ with } \\quad a_i \\in \\lbrace 0, ..., n_i-1 \\rbrace\n\neach **leg** a_i corresponds the a vector space of dimension `n_i`.\n\nan **index** of a leg is a particular value :math:`a_i \\in \\lbrace 0, ... ,n_i-1\\rbrace`.\n\nthe **rank** is the number of legs, the **shape** is :math:`(n_0, ..., n_{rank-1})`.\n\nwe restrict ourselves to abelian charges with entries in :math:`\\mathbb{z}` or in :math:`\\mathbb{z}_m`.\nthe nature of a charge is specified by m; we set :math:`m=1` for charges corresponding to :math:`\\mathbb{z}`.\nthe number of charges is referred to as **qnumber** as a short hand, and the collection of m for each charge is called **qmod**.\nthe qnumber, qmod and possibly descriptive names of the charges are saved in an instance of tenpy.linalg.charges.chargeinfo.\n\nto each index of each leg, a value of the charge(s) is associated.\na **charge block** is a contiguous slice corresponding to the same charge(s) of the leg.\na **qindex** is an index in the list of charge blocks for a certain leg.\na **charge sector** is for given charge(s) is the set of all qindices of that charge(s).\na leg is **blocked** if all charge sectors map one-to-one to qindices.\nfinally, a leg is **sorted**, if the charges are sorted lexicographically.\nnote that a `sorted` leg is always `blocked`.\nwe can also speak of the complete array to be **blocked by charges** or **legcharge-sorted**,  which means that all of its legs are blocked or sorted, respectively.\nthe charge data for a single leg is collected in the class tenpy.linalg.charges.legcharge.\na tenpy.linalg.charges.legcharge has also a flag **qconj**, which tells whether the charges\npoint *inward* (+1) or *outward* (-1). what that means, is explained later in nonzero_entries.\n\nfor completeness, let us also summarize also the internal structure of an tenpy.linalg.np_conserved.array here:\nthe array saves only non-zero **blocks**, collected as a list of `np.array` in ``self._data``.\nthe qindices necessary to map these blocks to the original leg indices are collected in ``self._qdata``\nan array is said to be **qdata-sorted** if its ``self._qdata`` is lexicographically sorted.\nmore details on this follow :ref:`later <array_storage_schema>`.\nhowever, note that you usually shouldn't access `_qdata` and `_data` directly - this\nis only necessary from within `tensordot`, `svd`, etc.\nalso, an array has a **total charge**, defining which entries can be non-zero - details in nonzero_entries.\n\nfinally, a **leg pipe** (implemented in tenpy.linalg.charges.legpipe)\nis used to formally combine multiple legs into one leg. again, more details follow :ref:`later <leg_pipes>`.\n\n\nphysical example\n++++++++++++++++\nfor concreteness, you can think of the hamiltonian :math:`h = -t \\sum_{<i,j>} (c^\\dagger_i c_j + h.c.) + u n_i n_j`\nwith :math:`n_i = c^\\dagger_i c_i`.\nthis hamiltonian has the global :math:`u(1)` gauge symmetry :math:`c_i \\rightarrow c_i e^{i\\phi}`.\nthe corresponding charge is the total number of particles :math:`n = \\sum_i n_i`.\nyou would then introduce one charge with :math:`m=1`.\n\nnote that the total charge is a sum of local terms, living on single sites.\nthus, you can infer the charge of a single physical site: it's just the value :math:`q_i = n_i \\in \\mathbb{n}` for each of the states.\n\nnote that you can only assign integer charges. consider for example the spin 1/2 heisenberg chain.\nhere, you can naturally identify the magnetization :math:`s^z = \\sum_i s^z_i` as the conserved quantity,\nwith values :math:`s^z_i = \\pm \\frac{1}{2}`.\nobviously, if :math:`s^z` is conserved, then so is :math:`2 s^z`, so you can use the charges\n:math:`q_i = 2 s^z_i \\in \\lbrace-1, +1 \\rbrace` for the `down` and `up` states, respectively.\nalternatively, you can also use a shift and define :math:`q_i = s^z_i + \\frac{1}{2} \\in \\lbrace 0, 1 \\rbrace`.\n\nas another example, consider bcs like terms :math:`\\sum_k (c^\\dagger_k c^\\dagger_{-k} + h.c.)`.\nthese terms break the total particle conservation,\nbut they preserve the total parity, i.e., :math:`n \\mod 2` is conserved. thus, you would introduce a charge with :math:`m = 2` in this case.\n\nin the above examples, we had only a single charge conserved at a time, but you might be lucky and have multiple\nconserved quantities, e.g. if you have two chains coupled only by interactions.\ntenpy is designed to handle the general case of multiple charges.\nwhen giving examples, we will restrict to one charge, but everything generalizes to multiple charges.\n\n\nthe different formats for legcharge\n+++++++++++++++++++++++++++++++++++\nas mentioned above, we assign charges to each index of each leg of a tensor.\nthis can be done in three formats: **qflat**, as **qind** and as **qdict**.\nlet me explain them with examples, for simplicity considering only a single charge (the most inner array has one entry\nfor each charge).\n\n**qflat** form: simply a list of charges for each index.\n    an example::\n\n        qflat = [[-2], [-1], [-1], [0], [0], [0], [0], [3], [3]]\n\n    this tells you that the leg has size 9, the charges for are ``[-2], [-1], [-1], ..., [3]`` for the indices ``0, 1, 2, 3,..., 8``.\n    you can identify four `charge blocks` ``slice(0, 1), slice(1, 3), slice(3, 7), slice(7, 9)`` in this example, which have charges ``[-2], [-1], [0], [3]``.\n    in other words, the indices ``1, 2`` (which are in ``slice(1, 3)``) have the same charge value ``[-1]``.\n    a `qindex` would just enumerate these blocks as ``0, 1, 2, 3``.\n\n**qind** form: a 1d array `slices` and a 2d array `charges`.\n    this is a more compact version than the `qflat` form:\n    the `slices` give a partition of the indices and the `charges` give the charge values. the same example as above\n    would simply be::\n\n        slices = [0, 1, 3, 7, 9]\n        charges = [[-2], [-1], [0], [3]]\n\n\n    note that  `slices` includes ``0`` as first entry and the number of indices (here ``9``) as last entries.\n    thus it has len ``block_number + 1``, where ``block_number`` (given by tenpy.linalg.charges.legcharge.block_number)\n    is the number of charge blocks in the leg, i.e. a `qindex` runs from 0 to ``block_number-1``.\n    on the other hand, the 2d array `charges` has shape ``(block_number, qnumber)``, where ``qnumber`` is the\n    number of charges (given by tenpy.linalg.charges.chargeinfo.qnumber).\n\n    in that way, the `qind` form maps an `qindex`, say ``qi``, to the indices ``slice(slices[qi], slices[qi+1])`` and\n    the charge(s) ``charges[qi]``.\n\n\n**qdict** form: a dictionary in the other direction than qind, taking charge tuples to slices.\n    again for the same example::\n\n        {(-2,): slice(0, 1),\n         (-1,): slice(1, 3),\n         (0,) : slice(3, 7),\n         (3,) : slice(7, 9)}\n\n    since the keys of a dictionary are unique, this form is only possible if the leg is `completely blocked`.\n\n\nthe tenpy.linalg.charges.legcharge saves the charge data of a leg internally in `qind` form,\ndirectly in the attribute `slices` and `charges`.\nhowever, it also provides convenient functions for conversion between from and to the `qflat` and `qdict` form.\n\nthe above example was nice since all charges were sorted and the charge blocks were 'as large as possible'.\nthis is however not required.\n\nthe following example is also a valid `qind` form::\n\n    slices = [0, 1, 3, 5, 7, 9]\n    charges = [[-2], [-1], [0], [0], [3]]\n\nthis leads to the *same* `qflat` form as the above examples, thus representing the same charges on the leg indices.\nhowever, regarding our arrays, this is quite different, since it divides the leg into 5 (instead of previously 4)\ncharge blocks. we say the latter example is `not bunched`, while the former one is `bunched`.\n\nto make the different notions of `sorted` and `bunched` clearer, consider the following (valid) examples:\n\n================================  =========  =========  ==========\ncharges                           bunched    sorted     blocked\n================================  =========  =========  ==========\n``[[-2], [-1], [0], [1], [3]]``   ``true``   ``true``   ``true``\n--------------------------------  ---------  ---------  ----------\n``[[-2], [-1], [0], [0], [3]]``   ``false``  ``true``   ``false``\n--------------------------------  ---------  ---------  ----------\n``[[-2], [0], [-1], [1], [3]]``   ``true``   ``false``  ``true``\n--------------------------------  ---------  ---------  ----------\n``[[-2], [0], [-1], [0], [3]]``   ``true``   ``false``  ``false``\n================================  =========  =========  ==========\n\nif a leg is `bunched` and `sorted`, it is automatically `blocked` (but not vice versa).\nsee also :ref:`below <blocking>` for further comments on that.\n\n\n\nwhich entries of the npc array can be non-zero?\n+++++++++++++++++++++++++++++++++++++++++++++++\nthe reason for the speedup with np_conserved lies in the fact that it saves only the blocks 'compatible' with the charges.\nbut how is this 'compatible' defined?\n\nassume you have a tensor, call it t, and the tenpy.linalg.charges.legcharge for all of its legs, say :math:`a, b, c, ...`.\n\nremember that the legcharge associates to each index of the leg a charge value (for each of the charges, if `qnumber` > 1).\nlet ``a.to_qflat()[ia]`` denote the charge(s) of index ``ia`` for leg ``a``, and similar for other legs.\n\nin addition, the legcharge has a flag tenpy.linalg.charges.legcharge.qconj. this flag **qconj** is only a sign,\nsaved as +1 or -1, specifying whether the charges point 'inward' (+1, default) or 'outward' (-1) of the tensor.\n\nthen, the **total charge of an entry** ``t[ia, ib, ic, ...]`` of the tensor is defined as::\n\n   qtotal[ia, ib, ic, ...] = a.to_qflat()[ia] * a.qconj + b.to_qflat()[ib] * b.qconj + c.to_qflat()[ic] * c.qconj + ...  modulo qmod\n\nthe rule which entries of the a tenpy.linalg.np_conserved.array can be non-zero\n(i.e., are 'compatible' with the charges), is then very simple:\n\n\n    an entry ``ia, ib, ic, ...`` of a tenpy.linalg.np_conserved.array can only be non-zero,\n    if ``qtotal[ia, ib, ic, ...]`` matches the *unique* tenpy.linalg.np_conserved.qtotal attribute of the class.\n\nin other words, there is a *single* **total charge** ``.qtotal`` attribute of a tenpy.linalg.np_conserved.array.\nall indices ``ia, ib, ic, ...`` for which the above defined ``qtotal[ia, ib, ic, ...]`` matches this `total charge`,\nare said to be **compatible with the charges** and can be non-zero.\nall other indices are **incompatible with the charges** and must be zero.\n\nin case of multiple charges, `qnumber` > 1, is a straight-forward generalization:\nan entry can only be non-zero if it is `compatible` with each of the defined charges.\n\n\nthe pesky qconj - contraction as an example\n+++++++++++++++++++++++++++++++++++++++++++\nwhy did we introduce the ``qconj`` flag? remember it's just a sign telling whether the charge points inward or outward.\nso whats the reasoning?\n\nthe short answer is, that legcharges actually live on bonds (i.e., legs which are to be contracted)\nrather than individual tensors. thus, it is convenient to share the legcharges between different legs and even tensors,\nand just adjust the sign of the charges with `qconj`.\n\nas an example, consider the contraction of two tensors, :math:`c_{ia,ic} = \\sum_{ib} a_{ia,ib} b_{ib,ic}`.\nfor simplicity, say that the total charge of all three tensors is zero.\nwhat are the implications of the above rule for non-zero entries?\nor rather, how can we ensure that ``c`` complies with the above rule?\nan entry ``c[ia,ic]`` will only be non-zero,\nif there is an ``ib`` such that both ``a[ia,ib]`` and ``b[ib,ic]`` are non-zero, i.e., both of the following equations are\nfulfilled::\n\n    a.qtotal == a.legs[0].to_qflat()[ia] * a.legs[0].qconj + a.legs[1].to_qflat()[ib] * a.legs[1].qconj  modulo qmod\n    b.qtotal == b.legs[0].to_qflat()[ib] * b.legs[0].qconj + b.legs[1].to_qflat()[ic] * b.legs[1].qconj  modulo qmod\n\n(``a.legs[0]`` is the tenpy.linalg.charges.legcharge saving the charges of the first leg (with index ``ia``) of `a`.)\n\nfor the uncontracted legs, we just keep the charges as they are::\n\n    c.legs = [a.legs[0], b.legs[1]]\n\nit is then straight-forward to check, that the rule is fulfilled for c, if the following condition is met::\n\n   a.qtotal + b.qtotal - c.qtotal == a.legs[1].to_qflat()[ib] a.b.qconj + b.legs[0].to_qflat()[ib] b.b.qconj  modulo qmod\n\nthe easiest way to meet this condition is (1) to require that ``a.b`` and ``b.b`` share the *same* charges ``b.to_qflat()``, but have\nopposite `qconj`, and (2) to define ``c.qtotal = a.qtotal + b.qtotal``.\nthis justifies the introduction of `qconj`:\nwhen you define the tensors, you have to define the tenpy.linalg.charges.legcharge for the `b` only once, say for ``a.legs[1]``.\nfor ``b.legs[0]`` you simply use ``a.legs[1].conj()`` which creates a copy of the legcharge with shared `slices` and `charges`, but opposite `qconj`.\nas a more impressive example, all 'physical' legs of an mps can usually share the same\ntenpy.linalg.charges.legcharge (up to different ``qconj`` if the local hilbert space is the same).\nthis leads to the following convention:\n\n\n   when an npc algorithm makes tensors which share a bond (either with the input tensors, as for tensordot, or amongst the output tensors, as for svd),\n   the algorithm is free, but not required, to use the **same** legcharge for the tensors sharing the bond, *without* making a copy.\n   thus, if you want to modify a legcharge, you **must** make a copy first (e.g. by using methods of legcharge for what you want to achieve).\n\n\nassigning charges to non-physical legs\n++++++++++++++++++++++++++++++++++++++\nfrom the above physical examples, it should be clear how you assign charges to physical legs.\nbut what about other legs, e.g, the virtual bond of an mps (or an mpo)?\n\nthe charge of these bonds must be derived by using the 'rule for non-zero entries', as far as they are not arbitrary.\nas a concrete example, consider an mps on just two spin 1/2 sites::\n\n    |        _____         _____\n    |   x->- | a | ->-y->- | b | ->-z\n    |        -----         -----\n    |          ^             ^\n    |          |p            |p\n\nthe two legs ``p`` are the physical legs and share the same charge, as they both describe the same local hilbert space.\nfor better distinction, let me label the indices of them by :math:`\\uparrow=0` and :math:`\\downarrow=1`.\nas noted above, we can associate the charges 1 (:math:`p=\\uparrow`) and -1 (:math:`p=\\downarrow`), respectively, so we define::\n\n    chinfo = npc.chargeinfo([1], ['2*sz'])\n    p  = npc.legcharge.from_qflat(chinfo, [1, -1], qconj=+1)\n\nfor the ``qconj`` signs, we stick to the convention used in our mps code and indicated by the\narrows in above 'picture': physical legs are incoming (``qconj=+1``), and from left to right on the virtual bonds.\nthis is achieved by using ``[p, x, y.conj()]`` as `legs` for ``a``, and ``[p, y, z.conj()]`` for ``b``, with the\ndefault ``qconj=+1`` for all ``p, x, y, z``: ``y.conj()`` has the same charges as ``y``, but opposite ``qconj=-1``.\n\nthe legs ``x`` and ``z`` of an ``l=2`` mps, are 'dummy' legs with just one index ``0``.\nthe charge on one of them, as well as the total charge of both ``a`` and ``b`` is arbitrary (i.e., a gauge freedom),\nso we make a simple choice: total charge 0 on both arrays, as well as for :math:`x=0`,\n``x = npc.legcharge.from_qflat(chinfo, [0], qconj=+1)``.\n\nthe charges on the bonds `y` and `z` then depend on the state the mps represents.\nhere, we consider a singlet :math:`\\psi = (|\\uparrow \\downarrow\\rangle  - |\\downarrow \\uparrow\\rangle)/\\sqrt{2}`\nas a simple example. a possible mps representation is given by::\n\n    a[up, :, :]   = [[1/2.**0.5, 0]]     b[up, :, :]   = [[0], [-1]]\n    a[down, :, :] = [[0, 1/2.**0.5]]     b[down, :, :] = [[1], [0]]\n\nthere are two non-zero entries in ``a``, for the indices :math:`(a, x, y) = (\\uparrow, 0, 0)` and :math:`(\\downarrow, 0, 1)`.\nfor :math:`(a, x, y) = (\\uparrow, 0, 0)`, we want::\n\n    a.qtotal = 0 = p.to_qflat()[up] * p.qconj + x.to_qflat()[0] * x.qconj + y.conj().to_qflat()[0] * y.conj().qconj\n                 = 1                * (+1)    + 0               * (+1)    + y.conj().to_qflat()[0] * (-1)\n\nthis fixes the charge of ``y=0`` to 1.\na similar calculation for :math:`(a, x, y) = (\\downarrow, 0, 1)` yields the charge ``-1`` for ``y=1``.\nwe have thus all the charges of the leg ``y`` and can define ``y = npc.legcharge.from_qflat(chinfo, [1, -1], qconj=+1)``.\n\nnow take a look at the entries of ``b``.\nfor the non-zero entry :math:`(b, y, z) = (\\uparrow, 1, 0)`, we want::\n\n    b.qtotal = 0 = p.to_qflat()[up] * p.qconj + y.to_qflat()[1] * y.qconj + z.conj().to_qflat()[0] * z.conj().qconj\n                 = 1                * (+1)    + (-1)            * (+1)    + z.conj().to_qflat()[0] * (-1)\n\nthis implies the charge 0 for `z` = 0, thus ``z = npc.legcharge.form_qflat(chinfo, [0], qconj=+1)``.\nfinally, note that the rule for :math:`(b, y, z) = (\\downarrow, 0, 0)` is automatically fulfilled!\nthis is an implication of the fact that the singlet has a well defined value for :math:`s^z_a + s^z_b`.\nfor other states without fixed magnetization (e.g., :math:`|\\uparrow \\uparrow\\rangle + |\\downarrow \\downarrow\\rangle`)\nthis would not be the case, and we could not use charge conservation.\n\nas an exercise, you can calculate the charge of `z` in the case that ``a.qtotal=5``, ``b.qtotal = -1`` and\ncharge ``2`` for ``x=0``. the result is -2.\n\n\n    this section is meant be an pedagogical introduction. in you program, you can use the functions\n    tenpy.linalg.np_conserved.detect_legcharge (which does exactly what's described above) or\n    tenpy.linalg.np_conserved.detect_qtotal (if you know all `legcharges`, but not `qtotal`).\n\narray creation\n++++++++++++++\n\ndirect creation\n^^^^^^^^^^^^^^^\n\nmaking an new tenpy.linalg.np_conserved.array requires both the tensor entries (data) and charge data.\n\nthe default initialization ``a = array(...)`` creates an empty array, where all entries are zero\n(equivalent to tenpy.linalg.np_conserved.zeros).\n(non-zero) data can be provided either as a dense `np.array` to tenpy.linalg.np_conserved.array.from_ndarray,\nor by providing a numpy function such as `np.random`, `np.ones` etc. to tenpy.linalg.np_conserved.array.from_func.\n\nin both cases, the charge data is provided by one tenpy.linalg.charges.chargeinfo,\nand a tenpy.linalg.charges.legcharge instance for each of the legs.\n\n\n    the charge data instances are not copied, in order to allow it to be shared between different arrays.\n    consequently, you *must* make copies of the charge data, if you manipulate it directly.\n    (however, methods like tenpy.linalg.charges.legcharge.sort do that for you.)\n\n\nindirect creation by manipulating existing arrays\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nof course, a new tenpy.linalg.np_conserved.array can also created using the charge data from existing arrays,\nfor example with tenpy.linalg.np_conserved.array.zeros_like or creating a (deep or shallow) tenpy.linalg.np_conserved.array.copy.\nfurther, there are many higher level functions like tenpy.linalg.np_conserved.tensordot or tenpy.linalg.np_conserved.svd,\nwhich also return new arrays.\n\n\n\ncomplete blocking of charges\n++++++++++++++++++++++++++++\n\nwhile the code was designed in such a way that each charge sector has a different charge, the code\nshould still run correctly if multiple charge sectors (for different qindex) correspond to the same charge.\nin this sense tenpy.linalg.np_conserved.array can act like a sparse array class to selectively store subblocks.\nalgorithms which need a full blocking should state that explicitly in their doc-strings.\n(some functions (like `svd` and `eigh`) require complete blocking internally, but if necessary they just work on\na temporary copy returned by tenpy.linalg.np_conserved.as_completely_blocked).\n\nif you expect the tensor to be dense subject to charge constraints (as for mps),\nit will be most efficient to fully block by charge, so that work is done on large chunks.\n\nhowever, if you expect the tensor to be sparser than required by charge (as for an mpo),\nit may be convenient not to completely block, which forces smaller matrices to be stored, and hence many zeroes to be dropped.\nnevertheless, the algorithms were not designed with this in mind, so it is not recommended in general.\n(if you want to use it, run a benchmark to check whether it is really faster!)\n\nif you haven't created the array yet, you can call tenpy.linalg.charges.legcharge.sort (with ``bunch=true``)\non each tenpy.linalg.charges.legcharge which you want to block.\nthis sorts by charges and thus induces a permutation of the indices, which is also returned as an 1d array ``perm``.\nfor consistency, you have to apply this permutation to your flat data as well.\n\nalternatively, you can simply call tenpy.linalg.np_conserved.array.sort_legcharge on an existing tenpy.linalg.np_conserved.array.\nit calls tenpy.linalg.charges.legcharge.sort internally on the specified legs and performs the necessary\npermutations directly to (a copy of) `self`. yet, you should keep in mind, that the axes are permuted afterwards.\n\n\n\ninternal storage schema of npc arrays\n+++++++++++++++++++++++++++++++++++++\n\nthe actual data of the tensor is stored in ``_data``. rather than keeping a single np.array (which would have many zeros in it),\nwe store only the non-zero sub blocks. so ``_data`` is a python list of `np.array`'s.\nthe order in which they are stored in the list is not physically meaningful, and so not guaranteed (more on this later).\nso to figure out where the sub block sits in the tensor, we need the ``_qdata`` structure (on top of the legcharges in ``legs``).\n\nconsider a rank 3 tensor ``t``, with the first leg like::\n\n    legs[0].slices = np.array([0, 1, 4, ...])\n    legs[0].charges = np.array([[-2], [1], ...])\n\neach row of `charges` gives the charges for a `charge block` of the leg, with the actual indices of the\ntotal tensor determined by the `slices`.\nthe *qindex* simply enumerates the charge blocks of a lex.\npicking a qindex (and thus a `charge block`) from each leg, we have a subblock of the tensor.\n\nfor each (non-zero) subblock of the tensor, we put a (numpy) ndarray entry in the ``_data`` list.\nsince each subblock of the tensor is specified by `rank` qindices,\nwe put a corresponding entry in ``_qdata``, which is a 2d array of shape ``(#stored_blocks, rank)``.\neach row corresponds to a non-zero subblock, and there are rank columns giving the corresponding qindex for each leg.\n\nexample: for a rank 3 tensor we might have::\n\n    t._data = [t1, t2, t3, t4, ...]\n    t._qdata = np.array([[3, 2, 1],\n                         [1, 1, 1],\n                         [4, 2, 2],\n                         [2, 1, 2],\n                         ...       ])\n\nthe third subblock has an ndarray ``t3``, and qindices ``[4 2 2]`` for the three legs.\n\n- to find the position of ``t3`` in the actual tensor you can use tenpy.linalg.charges.legcharge.get_slice::\n\n            t.legs[0].get_slice(4), t.legs[1].get_slice(2), t.legs[2].get_slice(2)\n\n  the function ``leg.get_charges(qi)`` simply returns ``slice(leg.slices[qi], leg.slices[qi+1])``\n\n- to find the charges of t3, we an use tenpy.linalg.charges.legcharge.get_charge::\n\n            t.legs[0].get_charge(2), t.legs[1].get_charge(2), t.legs[2].get_charge(2)\n\n  the function ``leg.get_charge(qi)`` simply returns ``leg.charges[qi]*leg.qconj``.\n\n\n   outside of `np_conserved`, you should use the api to access the entries.\n   if you really need to iterate over all blocks of an array ``t``, try ``for (block, blockslices, charges, qindices) in t: do_something()``.\n\nthe order in which the blocks stored in ``_data``/``_qdata`` is arbitrary (although of course ``_data`` and ``_qdata`` must be in correspondence).\nhowever, for many purposes it is useful to sort them according to some convention.  so we include a flag ``._qdata_sorted`` to the array.\nso, if sorted (with tenpy.linalg.np_conserved.array.isort_qdata, the ``_qdata`` example above goes to ::\n\n    _qdata = np.array([[1, 1, 1],\n                       [3, 2, 1],\n                       [2, 1, 2],\n                       [4, 2, 2],\n                       ...       ])\n\nnote that `np.lexsort` chooses the right-most column to be the dominant key, a convention we follow throughout.\n\nif ``_qdata_sorted == true``, ``_qdata`` and ``_data`` are guaranteed to be lexsorted. if ``_qdata_sorted == false``, there is no guarantee.\nif an algorithm modifies ``_qdata``, it **must** set ``_qdata_sorted = false`` (unless it guarantees it is still sorted).\nthe routine tenpy.linalg.np_conserved.array.sort_qdata brings the data to sorted form.\n\n\n\ndipole conservation\n-------------------\n\nnormally, a conserved charge has the form :math:`q = \\sum_i q_i` where the local charge q_i\nis (the expectation value of) some operator which does not explicitly depend on the position of the\nsite i it acts on. e.g. :math:`q_i = 2 * s_i^z` is independent of i in that sense.\n\nsome models, see e.g. tenpy.models.spins.dipolarspinchain, have a symmetry which conserves\na charge that does not follow the above scheme.\nthe dipole charge of this model is :math:`p = \\sum_i p_i = \\sum_i r_i q_i`, where r_i is the\nposition of the site i. clearly, the local charge p_i depends in the position of\nthe site i.\n\nwe support a general framework for conserved charges where the local charge has some non-trivial\ntransformation properties under spatial translations.\nwe do require, however, that the effect of spatial translation on a charge is independent of\nthe starting position and only depends on the vector of translation.\nrelaxing this assumption (e.g. to conserve quadrupole moments) would require substantially more\nbook-keeping and i (jakob unfried) am not even sure infinite mps with such charges can be well\ndefined.\n\nwe internally refer to such symmetries as \"shift-symmetry\" and we call the transformation of\ncharges / legs / sites or arrays that results from spatial translations \"shifting\".\nwe implement methods in tenpy.linalg.charges.chargeinfo that define how the charges\ntransform. the base class tenpy.linalg.charges.chargeinfo implements only trivial\nversions of these methods, that do not change the charges at all.\nit models charges with trivial translation properties, indicated by\ntenpy.linalg.charges.chargeinfo.trivial_shift being ``true``.\nnon-trivially transforming charges should then be implemented in subclasses, such as\ntenpy.linalg.charges.dipolarchargeinfo.\n\nthe subclass tenpy.linalg.charges.dipolarchargeinfo supports one (or multiple) charges of\nthe dipole form above, i.e. :math:`p_i = r_i q_i` where q_i is another \"normal\" conserved\ncharge. see its docstring for further details on how to use it\nand tenpy.models.spins.dipolarspinchain as an example that does.\n\nsuch a charge with non-tenpy.linalg.charges.chargeinfo.trivial_shift has the following main\nimplications for mps simulations in tenpy\n\n- the tenpy.networks.mps.mps.sites of an mps are no longer just given by the sites in the\n  tenpy.models.lattice.lattice.unit_cell. if the mps unit cell consists of multiple unit\n  cells of the lattice, the new positions of the site need be considered, since they affect the\n  charge values of the p_i on the respective physical legs.\n  we perform this shift in tenpy.models.lattice.lattice.mps_sites.\n\n- for sweeping algorithms using infinite mps, the charges also need to be adjusted when neighboring\n  unit cells are inserted, e.g. when a two-site update on sites ``l - 1, l`` is performed, the\n  (i)mps tensor on site ``l`` is not the *same* as the one on site ``0``, but rather a shifted version.\n  we account for this in tenpy.networks.mps.mps.get_b, tenpy.networks.mps.mps.set_b\n  and in the similar methods for `s`.\n  generally speaking , whenever the identification of arrays, sites or any quantity that carries\n  charge, between different unit cells of the imps is used, shifting needs to be taken into account.\n\nthe method tenpy.chargeinfo.shift_charges implements how the local charge\nchanges when moved from one site to another. it takes an arbitrary translation vector as an\nargument. it is used, e.g., to create the tenpy.linalg.models.lattice.lattice.mps_sites\nfrom the tenpy.linalg.models.lattice.lattice.unit_cell of the lattice.\nit turns out that the mps algorithms only need a specialized version,\ntenpy.chargeinfo.shift_charges_horizontal, which restricts to translations that are purely\nalong the first dimension of the lattice.\n\nin the setting of using mps in algorithms, we want to be as agnostic of the lattice geometry as\npossible. it turns out that in the concrete algorithms, and only for infinite mps, we only need\nto shift arrays / sites / charged by whole mps unit cells (of length tenpy.mps.l).\nthis is implemented in tenpy.mps.shift_array_unit_cell, etc., which uses the\ntenpy.networks.mps.mpsgeometry.unit_cell_width of the mps, which is now also an attr of mps.\n\nsee also\n--------\n- the module tenpy.linalg.np_conserved should contain all the api needed from the point of view of the algorithms.\n  it contains the fundamental tenpy.linalg.np_conserved.array class and functions for working with them (creating and manipulating).\n- the module tenpy.linalg.charges contains implementations for the charge structure, for example the classes\n  tenpy.linalg.charges.chargeinfo, tenpy.linalg.charges.legcharge, and tenpy.linalg.charges.legpipe.\n  as noted above, the 'public' api is imported to (and accessible from) tenpy.linalg.np_conserved.\n\na full example code for spin-1/2\n--------------------------------\nbelow follows a full example demonstrating the creation and contraction of arrays.\n(it's the file `a_np_conserved.py` in the examples folder of the tenpy source.)\n tutorial documentation npc",
    "tokens": 11103
  },
  {
    "category": "tutorials",
    "name": "doc.model",
    "content": "--- DOCUMENTATION: model ---\nModels (Introduction)\n=====================\n\nThis is an introduction to models in TeNPy, intended to guide new-comers towards defining\ntheir own custom models.\n\nWe go step by step to introduce the relevant concepts and \"derive\" how you could have come up\nwith the following example code to implement an anisotropic Heisenberg model on a square lattice::\n\n    class MyModel(CouplingMPOModel):\n        r\"\"\"The anisotropic spin-1/2 Heisenberg model in an external field.\n\n        This is a pedagogical example, and you should probably use the SpinModel instead.\n        The Hamiltonian is:\n\n            H = J_x \\sum_i (S^x_i S^x_{i+1} + S^y_i S^y_{i+1})\n                + J_z \\sum_i S^z_i S^z_{i+1}\n                - h_x \\sum_i S^z_i - h_z \\sum_i S^z_i\n        \"\"\"\n\n        def init_sites(self, model_params):\n            conserve = model_params.get('conserve', 'best')\n            if conserve == 'best':\n                if model_params.get('hx', 0) == 0:\n                    conserve = 'Sz'\n                else:\n                    conserve = None\n            return SpinHalfSite(conserve=conserve)\n\n        def init_terms(self, model_params):\n            Jx = model_params.get('Jx', 1.)\n            Jz = model_params.get('Jz', 1.)\n            hx = model_params.get('hx', 0.)\n            hz = model_params.get('hz', 0.)\n\n            for u in range(len(self.lat.unit_cell)):\n                self.add_onsite(-hx, u, 'Sx')\n                self.add_onsite(-hz, u, 'Sz')\n\n            for u1, u2, dx in self.lat.pairs['nearest_neighbors']:\n                self.add_coupling(Jz, u1, 'Sz', u2, 'Sz', dx)\n                self.add_coupling(.5 * Jx, u1, 'Sp', u2, 'Sm', dx, plus_hc=True)\n\n    model = MyModel({'lattice': 'Square', 'Lx': 2, 'Ly': 4, 'Jx': 0})\n\n\nWhat is a model?\n----------------\n\nAbstractly, a **model** stands for some physical (quantum) system, described by a Hamiltonian.\nFor example, let us consider an anisotropic spin-1/2 Heisenberg model in a field, described by\n\n\n    H = J_x \\sum_i (S^x_i S^x_{i+1} + S^y_i S^y_{i+1}) + J_z \\sum_i S^z_i S^z_{i+1} - h_x \\sum_i S^x_i - h_z \\sum_i S^z_i\n\nThe main features that need to be defined for a model are\n\n1. The local Hilbert space. In this example it is a Spin-1/2 degree of freedom with the usual spin operators :math:`S^x, S^y, S^z`.\n2. The problem geometry, in terms of lattice type, size and boundary conditions.\n3. The Hamiltonian itself. Here, it is naturally expressed as a sum of couplings.\n\nIn the following, we guide you towards defining your own custom model, with the above case as an example.\nWe follow the most direct route, using the tenpy.models.model.CouplingMPOModel framework,\nfor more flexible alternatives see :doc:`/intro/model_details`.\n\n    This Hamiltonian is already implemented as one of the pre-defined models.\n    Here, we implement it from scratch as an example, but if you wanted to simulate this particular\n    Hamiltonian in practice, you would use the tenpy.models.spins.SpinModel, which has a\n    more general Hamiltonian and contains our example as a special case.\n\n\nThe first step is to identify what the **parameters** of your model are.\nIn this case, we have the coupling constants :math:`J_x, J_z, h_x, h_z`, and parameters that specify\nthe lattice geometry (discussed later). In the TeNPy ecosystem, these parameters are\ngathered into dictionary-like tenpy.tools.params.Config objects, and for the rest of this\nguide you can think of ``model_params`` as a dictionary of these parameters, e.g.\n``model_params = {'Jx': 0.5, 'Jz': 1}``.\nIt is common practice to make all parameters optional, in which case you should think about\n(and ideally document) the default values for the parameters.\n\nWe start implementing our custom model by defining a class for it::\n\n    class MyModel(CouplingMPOModel):\n        r\"\"\"The anisotropic spin-1/2 Heisenberg model in an external field.\n\n        This is a pedagogical example, and you should probably use the SpinModel instead.\n        The Hamiltonian is:\n\n            H = J_x \\sum_i (S^x_i S^x_{i+1} + S^y_i S^y_{i+1})\n                + J_z \\sum_i S^z_i S^z_{i+1}\n                - h_x \\sum_i S^z_i - h_z \\sum_i S^z_i\n\n        \"\"\"\n        pass  # content will be added later\n\n\nNote that we define our model as a subclass of tenpy.models.model.CouplingMPOModel.\nThis means our model inherits all the machinery to build Hamiltonians etc, and we only need\nto implement the code that is specific to our model.\n\n\nThe local Hilbert space\n-----------------------\nThe **local Hilbert** space is represented by a tenpy.networks.site.Site (read its doc-string!).\nA site defines the meaning of each basis state (i.e. by fixing an order, to define e.g.\nthat the state are ``spin_down, spin_up``). Additionally, it stores common local operators, such as\n:math:`S^z` and makes them accessible by name.\n\nWe need to tell our model, what its local Hilbert space is.\nThis is done by implementing the tenpy.models.model.CouplingMPOModel.init_sites method.\nIt needs to take the ``model_params`` as input and returns one tenpy.networks.site.Site\ninstance per site in the unit cell of the lattice (see lattice section below, here this is one site).\nThe most common sites -- e.g. for spins, spin-less or spin-full fermions, or bosons -- are predefined\nin the module tenpy.networks.site, and in this example we can use one of them directly::\n\n    class MyModel(CouplingMPOModel):\n\n        def init_sites(self, model_params):\n            # simple version: no charge conservation\n            return SpinHalfSite(conserve='None')\n\n\nIf necessary, you can easily extend a pre-defined site by adding further local operators or\ncompletely write your own subclasses of tenpy.networks.site.Site.\n\nIf you want to use charge conservation (and you probably should, if possible), we need to specify\nwhat charges are conserved at this point already, i.e. we should give a value to the ``conserve``\nargument of the site.\n\n\n    If you don't know about :doc:`/intro/npc` yet, but want to get started with models right away,\n    you can set ``conserve=None`` in the existing sites as above and skip the rest of this\n    section. If you need a custom site, you can use\n    ``leg = tenpy.linalg.np_conserved.LegCharge.from_trivial(d)`` for an implementation of your\n    site, where `d` is the dimension of the local Hilbert space.\n\n\nIn many cases, the possible symmetries we may exploit depend on the\nvalues of the parameters, which is why they are an input to ``init_sites``.\nIn our example, we can conserve the total :math:`S^z` if :math:`h_x = 0`::\n\n    class MyModel(CouplingMPOModel):\n\n        def init_sites(self, model_params):\n            conserve = model_params.get('conserve', 'best')\n            if conserve == 'best':\n                if model_params.get('hx', 0) == 0:\n                    conserve = 'Sz'\n                else:\n                    conserve = None\n            return SpinHalfSite(conserve=conserve)\n\n\nNote that we added ``conserve`` as a model parameter, such that we can later turn charge\nconservation on or off. The possible values for ``conserve`` are documented in the site class,\nhere tenpy.networks.site.SpinHalfSite, and it is common to support ``'best'``\nas a value for the ``conserve`` model parameter and translate it to the largest possible symmetry,\ngiven the values of the coupling strengths.\n\n\n    The tenpy.linalg.charges.LegCharge of all involved sites need to have a common\n    tenpy.linalg.charges.ChargeInfo in order to allow the contraction of tensors\n    acting on the various sites.\n    This can be ensured with the function tenpy.networks.site.set_common_charges.\n\n    An example where tenpy.networks.site.set_common_charges is needed would be a coupling\n    of different types of sites, e.g., when a tight binding chain of fermions is coupled to some\n    local spin degrees of freedom. Another use case of this function would be a model with a U(1)\n    symmetry involving only half the sites, say :math:`\\sum_{i=0}^{L/2} n_{2i}`.\n\n\nThe geometry (lattice)\n----------------------\nThe geometry is usually given by some kind of **lattice** structure that determines how the sites\nare arranged spatially. This implicitly defines e.g. the meaning of a sum over nearest neighbors\n:math:`\\sum_{<i, j>}`.\nIn TeNPy, this is specified by a tenpy.models.lattice.Lattice class, which contains a unit cell of\na few tenpy.networks.site.Site\\s which are repeated periodically according to the lattice\nbasis vectors, to form a regular lattice.\nAgain, we have pre-defined some basic lattices like a tenpy.models.lattice.Chain,\ntwo chains coupled as a tenpy.models.lattice.Ladder or 2D lattices like the\ntenpy.models.lattice.Square, tenpy.models.lattice.Honeycomb and\ntenpy.models.lattice.Kagome lattices; but you are also free to define your own generalizations.\nSee :doc:`/intro/lattices`.\n\n\nBy default, the tenpy.models.model.CouplingMPOModel puts your model on\na tenpy.models.lattice.Chain, and looks for its length as ``model_params['L']``.\nIf you want to use a different pre-defined lattice, you can put it into the parameters, e.g.\nas ``model_params['lattice'] = 'Square'``, and the size is taken from ``model_params['Lx']``\nand ``model_params['Ly']``, while the boundary conditions are ``model_params['bc_x']``\nand ``model_params['bc_y']``.\nOf course, simply changing the lattice only makes sense if the Hamiltonian is defined in a lattice\nindependent language, e.g. in terms of \"nearest neighbor pairs\".\nAs we will explore in the next section, this is in fact the natural way to define Hamiltonians in TeNPy.\n\nIt is also common to have specialized classes for special lattices::\n\n    class MyModelKagome(MyModel):\n        default_lattice = Kagome\n        force_default_lattice = True\n\n        def init_sites(self, model_params):\n            # note: Kagome has three sites per unit-cell\n            site = MyModel.init_site(model_params)\n            return (site, site, site)\n\n\nSetting ``default_lattice = Kagome`` means that the lattice defaults to Kagome, if ``'lattice' not in model_params``,\nwhile setting ``force_default_lattice = True`` means that this model does not allow any other\nlattice. Thus, ``MyModelKagome`` does what its name promises to do.\n\nFor custom lattices, or more complicated code, you can overwrite the\ntenpy.models.model.CouplingMPOModel.init_lattice method, similar to how we did\nfor ``init_sites`` above.\n\n\nThe Hamiltonian\n---------------\nThe last ingredient we need to implement for a custom model is its Hamiltonian.\nTo that end, we override the tenpy.models.model.CouplingMPOModel.init_terms method.\nAt this point during model initialization, the lattice is already initialized, and we\nmay access ``self.lat`` and use e.g. the tenpy.models.lattice.Lattice.pairs attribute\nfor convenient definition of couplings between e.g. nearest-neighbor pairs.\n\nThere are a bunch of convenience methods implemented in tenpy.models.model.CouplingModel,\nwhich make this easy. Let us summarize them here:\n\n- tenpy.models.model.CouplingModel.add_onsite for a sum of onsite terms :math:`\\sum_i h_i \\hat{A}_i`.\n- tenpy.models.model.CouplingModel.add_coupling for a sum of two-body couplings :math:`\\sum_i J_i \\hat{A}_i \\hat{B}_{i+n}`.\n- tenpy.models.model.CouplingModel.add_multi_coupling for a sum of multi-body couplings :math:`\\sum_i J_i \\hat{A}_i \\hat{B}_{i+n} ... \\hat{F}_{i+m}`.\n\n    A single call to each of these methods adds an extensive number of terms to your Hamiltonian,\n    as it includes a sum over all sites in the definition.\n    This means that a Hamiltonian like :math:`H = -3 \\sum_i S_i^z` is realized as a **single** call to\n    tenpy.models.model.CouplingModel.add_onsite, **without**  an explicit loop over `i`.\n\n    These methods allow the prefactors to be site-dependent; you can either give a single number\n    as the prefactor, or a list/array that is tiled to fit the size.\n    E.g. if an onsite term with ``strength=1`` gives you a uniform magnetic field,\n    ``strength=[1, -1]`` gives you the corresponding staggered field,\n    assuming a chain of even length.\n\n- tenpy.models.model.CouplingModel.add_local_term for a single term :math:`\\hat{A}_i` or :math:`\\hat{A}_i \\hat{B}_{j}`\n  or :math:`\\hat{A}_i \\hat{B}_{j} ... \\hat{F}_k`.\n\n    You probably should not directly use tenpy.models.model.CouplingModel.add_onsite_term,\n    tenpy.models.model.CouplingModel.add_coupling_term and\n    tenpy.models.model.CouplingModel.add_multi_coupling_term.\n    They do not handle Jordan-Wigner strings and they need MPS indices as inputs, not\n    lattice positions.\n\nSee also tenpy.models.model.CouplingModel.add_exponentially_decaying_coupling\n\n    Instead of a single operator name like ``'Sx'``, you can put multiple operator names\n    separated by whitespace to represent the product of these operators.\n    For example, ``self.add_onsite(-2.j * (-hz), u, 'Sx Sy')`` is equivalent to (but worse than)\n    to ``self.add_onsite(-hz, u, 'Sz')``.\n\nFor our example, we define the Hamiltonian by implementing::\n\n    class MyModel(CouplingMPOModel):\n\n        def init_sites(self, model_params):\n            ...\n\n        def init_terms(self, model_params):\n            Jx = model_params.get('Jx', 1.)\n            Jz = model_params.get('Jz', 1.)\n            hx = model_params.get('hx', 0.)\n            hz = model_params.get('hz', 0.)\n\n            for u in range(len(self.lat.unit_cell)):\n                self.add_onsite(-hx, u, 'Sx')\n                self.add_onsite(-hz, u, 'Sz')\n\n            for u1, u2, dx in self.lat.pairs['nearest_neighbors']:\n                self.add_coupling(Jz, u1, 'Sz', u2, 'Sz', dx)\n\n                # Sx and Sy violate Sz conservation.\n                # need to define them using Sp = Sx + i Sy, Sm = Sx - i Sy\n                # Sx.Sx + Sy.Sy = .5 * (Sp.Sm + Sm.Sp) = .5 * (Sp.Sm + hc)\n                self.add_coupling(.5 * Jx, u1, 'Sp', u2, 'Sm', dx, plus_hc=True)\n\n    If we did not care about charge conservation, we could have also done\n    ``add_coupling(Jx, u1, 'Sx', u2, 'Sx', dx)`` and\n    ``add_coupling(Jx, u1, 'Sy', u2, 'Sy', dx)``.\n    This only works if we set ``conserve='None'`` or ``conserve='parity'``,\n    as otherwise the site does not even define ``'Sx'``.\n\n    Also, note that that the on-site operators ``Sp=``:math:`S^+_i` and ``Sm=``:math:`S^-_i`\n    do not conserve the total :math:`S^z`, but you can still use them to define the combined\n    coupling :math:`S^+_i S^-_j` that *does* conserve :math:`S^z`.\n\n\nAt this point we are done defining our model, and have reproduced the result at the very top\nof the chapter. We should, however, make sure that we defined the model correctly.\n\n\nVerifying models\n----------------\nEspecially when you define custom models, we strongly recommend you triple-check if you correctly\nimplemented the model you are interested in (i.e. have the correct couplings between correct sites).\nThis is a crucial step to make sure you are in fact simulating the model that you are thinking\nabout and not some random other model with entirely different physics.\n\n    If the model contains Fermions, you should read the introduction to :doc:`/intro/JordanWigner`.\n\n\nTo verify that you have added the correct terms, initialize the model on a small lattice (we also\nset :math:`J_x=0` here for readability, but you should turn it on to verify the full model),\ne.g.::\n\n    model = MyModel({'lattice': 'Square', 'Lx': 2, 'Ly': 3, 'Jx': 0, 'hz': 0.2})\n\n\nNow, print all couplings and onsite terms in the model to console::\n\n    print(model.all_coupling_terms().to_TermList() + model.all_onsite_terms().to_TermList())\n\n\nWhich gives you the following output for our example::\n\n    1.00000 * Sz_0 Sz_1 +\n    1.00000 * Sz_0 Sz_2 +\n    1.00000 * Sz_0 Sz_3 +\n    1.00000 * Sz_1 Sz_2 +\n    1.00000 * Sz_1 Sz_4 +\n    1.00000 * Sz_2 Sz_5 +\n    1.00000 * Sz_3 Sz_4 +\n    1.00000 * Sz_3 Sz_5 +\n    1.00000 * Sz_4 Sz_5 +\n    -0.20000 * Sz_0 +\n    -0.20000 * Sz_1 +\n    -0.20000 * Sz_2 +\n    -0.20000 * Sz_3 +\n    -0.20000 * Sz_4 +\n    -0.20000 * Sz_5\n\n\nYou may be surprised to see nine different two-body couplings on this ``2 x 3`` square patch.\nLet us look at the couplings in detail to figure out why this might be.\nWe need to understand the meaning of the site indices, i.e. where does ``Sz_4`` live spatially?\nThe convention for site indices comes from the MPS geometry and may be hard to read.\nTo visualize the site order of the lattice, you may run the following snippet::\n\n    import matplotlib.pyplot as plt\n    plt.figure(figsize=(5, 6))\n    ax = plt.gca()\n    model.lat.plot_coupling(ax)\n    model.lat.plot_sites(ax)\n    model.lat.plot_order(ax)\n    plt.show()\n\n\n\n    from tenpy import SpinHalfSite\n    from tenpy.models import CouplingMPOModel\n    import matplotlib.pyplot as plt\n\n    class MyModel(CouplingMPOModel):\n        def init_sites(self, model_params):\n            return SpinHalfSite()\n\n        def init_terms(self, model_params):\n            # note: terms dont matter for this plot, so we simplify here\n            self.add_onsite(1., 0, 'Sz')\n\n    model = MyModel({'lattice': 'Square', 'Lx': 2, 'Ly': 3})\n    plt.figure(figsize=(5, 6))\n    ax = plt.gca()\n    model.lat.plot_coupling(ax)\n    model.lat.plot_sites(ax)\n    model.lat.plot_order(ax)\n    plt.show()\n\n\nWe see the lattice plotted in black. Concretely, we get a black line for each pair of nearest-neighbor\nsites. The red line goes through the sites in order, and we see the site indices labelled.\n\nIn particular, we can now understand why we get nine different couplings; we see from the plot\nthat the lattice has open boundaries in x-direction but periodic boundaries in y-direction.\nTry playing around with different boundary conditions, e.g.\n``MyModel({'lattice': 'Square', 'Lx': 2, 'Ly': 3, 'Jx': 0, 'bc_y': 'open'})``\nor\n``MyModel({'lattice': 'Square', 'Lx': 2, 'Ly': 3, 'Jx': 0, 'bc_x': 'periodic'})``.\nSee :doc:`/intro/lattices` regarding boundary conditions.\n\nYou can also use tenpy.algorithms.exact_diag.get_numpy_Hamiltonian to see if the Hamiltonian\nis what you expect it to be.\nYou will need to choose a relatively small system for the full Hamiltonian to fit into RAM.\nThis is strongly recommended if you defined your own operators, as e.g. the\ntenpy.models.pxp.PXPChain does.\n\n\nContribute your model?\n----------------------\nIf you have implemented a model, and you think it may be useful to the broader community, consider\ncontributing it to TeNPy via a pull request.\nWe have :doc:`/contr/guidelines`, and you can have a look at the implementation\nof e.g. the tenpy.models.spins.SpinModel as a guide, but do not let formalities\nstop you from sharing your code, we can always address any nitpicks ourselves.\n\n\nFurther Reading\n---------------\n- Details and ideas behind the implementation: :doc:`/intro/model_details`\n- Look at the implementation of the pre-defined models in tenpy.models.\n  Most are based on the tenpy.models.model.CouplingMPOModel as discussed here.\n- The tenpy.models.aklt.AKLTChain is a notable counter-example where it is actually\n  easier to define ``H_bond`` than to write down couplings.\n- If the Hamiltonian is already given in MPO form (e.g. because it comes from some other software),\n  it can be used to directly build a model, as is done in ``examples/mpo_exponentially_decaying.py``.",
    "search_text": "doc.model --- documentation: model ---\nmodels (introduction)\n=====================\n\nthis is an introduction to models in tenpy, intended to guide new-comers towards defining\ntheir own custom models.\n\nwe go step by step to introduce the relevant concepts and \"derive\" how you could have come up\nwith the following example code to implement an anisotropic heisenberg model on a square lattice::\n\n    class mymodel(couplingmpomodel):\n        r\"\"\"the anisotropic spin-1/2 heisenberg model in an external field.\n\n        this is a pedagogical example, and you should probably use the spinmodel instead.\n        the hamiltonian is:\n\n            h = j_x \\sum_i (s^x_i s^x_{i+1} + s^y_i s^y_{i+1})\n                + j_z \\sum_i s^z_i s^z_{i+1}\n                - h_x \\sum_i s^z_i - h_z \\sum_i s^z_i\n        \"\"\"\n\n        def init_sites(self, model_params):\n            conserve = model_params.get('conserve', 'best')\n            if conserve == 'best':\n                if model_params.get('hx', 0) == 0:\n                    conserve = 'sz'\n                else:\n                    conserve = none\n            return spinhalfsite(conserve=conserve)\n\n        def init_terms(self, model_params):\n            jx = model_params.get('jx', 1.)\n            jz = model_params.get('jz', 1.)\n            hx = model_params.get('hx', 0.)\n            hz = model_params.get('hz', 0.)\n\n            for u in range(len(self.lat.unit_cell)):\n                self.add_onsite(-hx, u, 'sx')\n                self.add_onsite(-hz, u, 'sz')\n\n            for u1, u2, dx in self.lat.pairs['nearest_neighbors']:\n                self.add_coupling(jz, u1, 'sz', u2, 'sz', dx)\n                self.add_coupling(.5 * jx, u1, 'sp', u2, 'sm', dx, plus_hc=true)\n\n    model = mymodel({'lattice': 'square', 'lx': 2, 'ly': 4, 'jx': 0})\n\n\nwhat is a model?\n----------------\n\nabstractly, a **model** stands for some physical (quantum) system, described by a hamiltonian.\nfor example, let us consider an anisotropic spin-1/2 heisenberg model in a field, described by\n\n\n    h = j_x \\sum_i (s^x_i s^x_{i+1} + s^y_i s^y_{i+1}) + j_z \\sum_i s^z_i s^z_{i+1} - h_x \\sum_i s^x_i - h_z \\sum_i s^z_i\n\nthe main features that need to be defined for a model are\n\n1. the local hilbert space. in this example it is a spin-1/2 degree of freedom with the usual spin operators :math:`s^x, s^y, s^z`.\n2. the problem geometry, in terms of lattice type, size and boundary conditions.\n3. the hamiltonian itself. here, it is naturally expressed as a sum of couplings.\n\nin the following, we guide you towards defining your own custom model, with the above case as an example.\nwe follow the most direct route, using the tenpy.models.model.couplingmpomodel framework,\nfor more flexible alternatives see :doc:`/intro/model_details`.\n\n    this hamiltonian is already implemented as one of the pre-defined models.\n    here, we implement it from scratch as an example, but if you wanted to simulate this particular\n    hamiltonian in practice, you would use the tenpy.models.spins.spinmodel, which has a\n    more general hamiltonian and contains our example as a special case.\n\n\nthe first step is to identify what the **parameters** of your model are.\nin this case, we have the coupling constants :math:`j_x, j_z, h_x, h_z`, and parameters that specify\nthe lattice geometry (discussed later). in the tenpy ecosystem, these parameters are\ngathered into dictionary-like tenpy.tools.params.config objects, and for the rest of this\nguide you can think of ``model_params`` as a dictionary of these parameters, e.g.\n``model_params = {'jx': 0.5, 'jz': 1}``.\nit is common practice to make all parameters optional, in which case you should think about\n(and ideally document) the default values for the parameters.\n\nwe start implementing our custom model by defining a class for it::\n\n    class mymodel(couplingmpomodel):\n        r\"\"\"the anisotropic spin-1/2 heisenberg model in an external field.\n\n        this is a pedagogical example, and you should probably use the spinmodel instead.\n        the hamiltonian is:\n\n            h = j_x \\sum_i (s^x_i s^x_{i+1} + s^y_i s^y_{i+1})\n                + j_z \\sum_i s^z_i s^z_{i+1}\n                - h_x \\sum_i s^z_i - h_z \\sum_i s^z_i\n\n        \"\"\"\n        pass  # content will be added later\n\n\nnote that we define our model as a subclass of tenpy.models.model.couplingmpomodel.\nthis means our model inherits all the machinery to build hamiltonians etc, and we only need\nto implement the code that is specific to our model.\n\n\nthe local hilbert space\n-----------------------\nthe **local hilbert** space is represented by a tenpy.networks.site.site (read its doc-string!).\na site defines the meaning of each basis state (i.e. by fixing an order, to define e.g.\nthat the state are ``spin_down, spin_up``). additionally, it stores common local operators, such as\n:math:`s^z` and makes them accessible by name.\n\nwe need to tell our model, what its local hilbert space is.\nthis is done by implementing the tenpy.models.model.couplingmpomodel.init_sites method.\nit needs to take the ``model_params`` as input and returns one tenpy.networks.site.site\ninstance per site in the unit cell of the lattice (see lattice section below, here this is one site).\nthe most common sites -- e.g. for spins, spin-less or spin-full fermions, or bosons -- are predefined\nin the module tenpy.networks.site, and in this example we can use one of them directly::\n\n    class mymodel(couplingmpomodel):\n\n        def init_sites(self, model_params):\n            # simple version: no charge conservation\n            return spinhalfsite(conserve='none')\n\n\nif necessary, you can easily extend a pre-defined site by adding further local operators or\ncompletely write your own subclasses of tenpy.networks.site.site.\n\nif you want to use charge conservation (and you probably should, if possible), we need to specify\nwhat charges are conserved at this point already, i.e. we should give a value to the ``conserve``\nargument of the site.\n\n\n    if you don't know about :doc:`/intro/npc` yet, but want to get started with models right away,\n    you can set ``conserve=none`` in the existing sites as above and skip the rest of this\n    section. if you need a custom site, you can use\n    ``leg = tenpy.linalg.np_conserved.legcharge.from_trivial(d)`` for an implementation of your\n    site, where `d` is the dimension of the local hilbert space.\n\n\nin many cases, the possible symmetries we may exploit depend on the\nvalues of the parameters, which is why they are an input to ``init_sites``.\nin our example, we can conserve the total :math:`s^z` if :math:`h_x = 0`::\n\n    class mymodel(couplingmpomodel):\n\n        def init_sites(self, model_params):\n            conserve = model_params.get('conserve', 'best')\n            if conserve == 'best':\n                if model_params.get('hx', 0) == 0:\n                    conserve = 'sz'\n                else:\n                    conserve = none\n            return spinhalfsite(conserve=conserve)\n\n\nnote that we added ``conserve`` as a model parameter, such that we can later turn charge\nconservation on or off. the possible values for ``conserve`` are documented in the site class,\nhere tenpy.networks.site.spinhalfsite, and it is common to support ``'best'``\nas a value for the ``conserve`` model parameter and translate it to the largest possible symmetry,\ngiven the values of the coupling strengths.\n\n\n    the tenpy.linalg.charges.legcharge of all involved sites need to have a common\n    tenpy.linalg.charges.chargeinfo in order to allow the contraction of tensors\n    acting on the various sites.\n    this can be ensured with the function tenpy.networks.site.set_common_charges.\n\n    an example where tenpy.networks.site.set_common_charges is needed would be a coupling\n    of different types of sites, e.g., when a tight binding chain of fermions is coupled to some\n    local spin degrees of freedom. another use case of this function would be a model with a u(1)\n    symmetry involving only half the sites, say :math:`\\sum_{i=0}^{l/2} n_{2i}`.\n\n\nthe geometry (lattice)\n----------------------\nthe geometry is usually given by some kind of **lattice** structure that determines how the sites\nare arranged spatially. this implicitly defines e.g. the meaning of a sum over nearest neighbors\n:math:`\\sum_{<i, j>}`.\nin tenpy, this is specified by a tenpy.models.lattice.lattice class, which contains a unit cell of\na few tenpy.networks.site.site\\s which are repeated periodically according to the lattice\nbasis vectors, to form a regular lattice.\nagain, we have pre-defined some basic lattices like a tenpy.models.lattice.chain,\ntwo chains coupled as a tenpy.models.lattice.ladder or 2d lattices like the\ntenpy.models.lattice.square, tenpy.models.lattice.honeycomb and\ntenpy.models.lattice.kagome lattices; but you are also free to define your own generalizations.\nsee :doc:`/intro/lattices`.\n\n\nby default, the tenpy.models.model.couplingmpomodel puts your model on\na tenpy.models.lattice.chain, and looks for its length as ``model_params['l']``.\nif you want to use a different pre-defined lattice, you can put it into the parameters, e.g.\nas ``model_params['lattice'] = 'square'``, and the size is taken from ``model_params['lx']``\nand ``model_params['ly']``, while the boundary conditions are ``model_params['bc_x']``\nand ``model_params['bc_y']``.\nof course, simply changing the lattice only makes sense if the hamiltonian is defined in a lattice\nindependent language, e.g. in terms of \"nearest neighbor pairs\".\nas we will explore in the next section, this is in fact the natural way to define hamiltonians in tenpy.\n\nit is also common to have specialized classes for special lattices::\n\n    class mymodelkagome(mymodel):\n        default_lattice = kagome\n        force_default_lattice = true\n\n        def init_sites(self, model_params):\n            # note: kagome has three sites per unit-cell\n            site = mymodel.init_site(model_params)\n            return (site, site, site)\n\n\nsetting ``default_lattice = kagome`` means that the lattice defaults to kagome, if ``'lattice' not in model_params``,\nwhile setting ``force_default_lattice = true`` means that this model does not allow any other\nlattice. thus, ``mymodelkagome`` does what its name promises to do.\n\nfor custom lattices, or more complicated code, you can overwrite the\ntenpy.models.model.couplingmpomodel.init_lattice method, similar to how we did\nfor ``init_sites`` above.\n\n\nthe hamiltonian\n---------------\nthe last ingredient we need to implement for a custom model is its hamiltonian.\nto that end, we override the tenpy.models.model.couplingmpomodel.init_terms method.\nat this point during model initialization, the lattice is already initialized, and we\nmay access ``self.lat`` and use e.g. the tenpy.models.lattice.lattice.pairs attribute\nfor convenient definition of couplings between e.g. nearest-neighbor pairs.\n\nthere are a bunch of convenience methods implemented in tenpy.models.model.couplingmodel,\nwhich make this easy. let us summarize them here:\n\n- tenpy.models.model.couplingmodel.add_onsite for a sum of onsite terms :math:`\\sum_i h_i \\hat{a}_i`.\n- tenpy.models.model.couplingmodel.add_coupling for a sum of two-body couplings :math:`\\sum_i j_i \\hat{a}_i \\hat{b}_{i+n}`.\n- tenpy.models.model.couplingmodel.add_multi_coupling for a sum of multi-body couplings :math:`\\sum_i j_i \\hat{a}_i \\hat{b}_{i+n} ... \\hat{f}_{i+m}`.\n\n    a single call to each of these methods adds an extensive number of terms to your hamiltonian,\n    as it includes a sum over all sites in the definition.\n    this means that a hamiltonian like :math:`h = -3 \\sum_i s_i^z` is realized as a **single** call to\n    tenpy.models.model.couplingmodel.add_onsite, **without**  an explicit loop over `i`.\n\n    these methods allow the prefactors to be site-dependent; you can either give a single number\n    as the prefactor, or a list/array that is tiled to fit the size.\n    e.g. if an onsite term with ``strength=1`` gives you a uniform magnetic field,\n    ``strength=[1, -1]`` gives you the corresponding staggered field,\n    assuming a chain of even length.\n\n- tenpy.models.model.couplingmodel.add_local_term for a single term :math:`\\hat{a}_i` or :math:`\\hat{a}_i \\hat{b}_{j}`\n  or :math:`\\hat{a}_i \\hat{b}_{j} ... \\hat{f}_k`.\n\n    you probably should not directly use tenpy.models.model.couplingmodel.add_onsite_term,\n    tenpy.models.model.couplingmodel.add_coupling_term and\n    tenpy.models.model.couplingmodel.add_multi_coupling_term.\n    they do not handle jordan-wigner strings and they need mps indices as inputs, not\n    lattice positions.\n\nsee also tenpy.models.model.couplingmodel.add_exponentially_decaying_coupling\n\n    instead of a single operator name like ``'sx'``, you can put multiple operator names\n    separated by whitespace to represent the product of these operators.\n    for example, ``self.add_onsite(-2.j * (-hz), u, 'sx sy')`` is equivalent to (but worse than)\n    to ``self.add_onsite(-hz, u, 'sz')``.\n\nfor our example, we define the hamiltonian by implementing::\n\n    class mymodel(couplingmpomodel):\n\n        def init_sites(self, model_params):\n            ...\n\n        def init_terms(self, model_params):\n            jx = model_params.get('jx', 1.)\n            jz = model_params.get('jz', 1.)\n            hx = model_params.get('hx', 0.)\n            hz = model_params.get('hz', 0.)\n\n            for u in range(len(self.lat.unit_cell)):\n                self.add_onsite(-hx, u, 'sx')\n                self.add_onsite(-hz, u, 'sz')\n\n            for u1, u2, dx in self.lat.pairs['nearest_neighbors']:\n                self.add_coupling(jz, u1, 'sz', u2, 'sz', dx)\n\n                # sx and sy violate sz conservation.\n                # need to define them using sp = sx + i sy, sm = sx - i sy\n                # sx.sx + sy.sy = .5 * (sp.sm + sm.sp) = .5 * (sp.sm + hc)\n                self.add_coupling(.5 * jx, u1, 'sp', u2, 'sm', dx, plus_hc=true)\n\n    if we did not care about charge conservation, we could have also done\n    ``add_coupling(jx, u1, 'sx', u2, 'sx', dx)`` and\n    ``add_coupling(jx, u1, 'sy', u2, 'sy', dx)``.\n    this only works if we set ``conserve='none'`` or ``conserve='parity'``,\n    as otherwise the site does not even define ``'sx'``.\n\n    also, note that that the on-site operators ``sp=``:math:`s^+_i` and ``sm=``:math:`s^-_i`\n    do not conserve the total :math:`s^z`, but you can still use them to define the combined\n    coupling :math:`s^+_i s^-_j` that *does* conserve :math:`s^z`.\n\n\nat this point we are done defining our model, and have reproduced the result at the very top\nof the chapter. we should, however, make sure that we defined the model correctly.\n\n\nverifying models\n----------------\nespecially when you define custom models, we strongly recommend you triple-check if you correctly\nimplemented the model you are interested in (i.e. have the correct couplings between correct sites).\nthis is a crucial step to make sure you are in fact simulating the model that you are thinking\nabout and not some random other model with entirely different physics.\n\n    if the model contains fermions, you should read the introduction to :doc:`/intro/jordanwigner`.\n\n\nto verify that you have added the correct terms, initialize the model on a small lattice (we also\nset :math:`j_x=0` here for readability, but you should turn it on to verify the full model),\ne.g.::\n\n    model = mymodel({'lattice': 'square', 'lx': 2, 'ly': 3, 'jx': 0, 'hz': 0.2})\n\n\nnow, print all couplings and onsite terms in the model to console::\n\n    print(model.all_coupling_terms().to_termlist() + model.all_onsite_terms().to_termlist())\n\n\nwhich gives you the following output for our example::\n\n    1.00000 * sz_0 sz_1 +\n    1.00000 * sz_0 sz_2 +\n    1.00000 * sz_0 sz_3 +\n    1.00000 * sz_1 sz_2 +\n    1.00000 * sz_1 sz_4 +\n    1.00000 * sz_2 sz_5 +\n    1.00000 * sz_3 sz_4 +\n    1.00000 * sz_3 sz_5 +\n    1.00000 * sz_4 sz_5 +\n    -0.20000 * sz_0 +\n    -0.20000 * sz_1 +\n    -0.20000 * sz_2 +\n    -0.20000 * sz_3 +\n    -0.20000 * sz_4 +\n    -0.20000 * sz_5\n\n\nyou may be surprised to see nine different two-body couplings on this ``2 x 3`` square patch.\nlet us look at the couplings in detail to figure out why this might be.\nwe need to understand the meaning of the site indices, i.e. where does ``sz_4`` live spatially?\nthe convention for site indices comes from the mps geometry and may be hard to read.\nto visualize the site order of the lattice, you may run the following snippet::\n\n    import matplotlib.pyplot as plt\n    plt.figure(figsize=(5, 6))\n    ax = plt.gca()\n    model.lat.plot_coupling(ax)\n    model.lat.plot_sites(ax)\n    model.lat.plot_order(ax)\n    plt.show()\n\n\n\n    from tenpy import spinhalfsite\n    from tenpy.models import couplingmpomodel\n    import matplotlib.pyplot as plt\n\n    class mymodel(couplingmpomodel):\n        def init_sites(self, model_params):\n            return spinhalfsite()\n\n        def init_terms(self, model_params):\n            # note: terms dont matter for this plot, so we simplify here\n            self.add_onsite(1., 0, 'sz')\n\n    model = mymodel({'lattice': 'square', 'lx': 2, 'ly': 3})\n    plt.figure(figsize=(5, 6))\n    ax = plt.gca()\n    model.lat.plot_coupling(ax)\n    model.lat.plot_sites(ax)\n    model.lat.plot_order(ax)\n    plt.show()\n\n\nwe see the lattice plotted in black. concretely, we get a black line for each pair of nearest-neighbor\nsites. the red line goes through the sites in order, and we see the site indices labelled.\n\nin particular, we can now understand why we get nine different couplings; we see from the plot\nthat the lattice has open boundaries in x-direction but periodic boundaries in y-direction.\ntry playing around with different boundary conditions, e.g.\n``mymodel({'lattice': 'square', 'lx': 2, 'ly': 3, 'jx': 0, 'bc_y': 'open'})``\nor\n``mymodel({'lattice': 'square', 'lx': 2, 'ly': 3, 'jx': 0, 'bc_x': 'periodic'})``.\nsee :doc:`/intro/lattices` regarding boundary conditions.\n\nyou can also use tenpy.algorithms.exact_diag.get_numpy_hamiltonian to see if the hamiltonian\nis what you expect it to be.\nyou will need to choose a relatively small system for the full hamiltonian to fit into ram.\nthis is strongly recommended if you defined your own operators, as e.g. the\ntenpy.models.pxp.pxpchain does.\n\n\ncontribute your model?\n----------------------\nif you have implemented a model, and you think it may be useful to the broader community, consider\ncontributing it to tenpy via a pull request.\nwe have :doc:`/contr/guidelines`, and you can have a look at the implementation\nof e.g. the tenpy.models.spins.spinmodel as a guide, but do not let formalities\nstop you from sharing your code, we can always address any nitpicks ourselves.\n\n\nfurther reading\n---------------\n- details and ideas behind the implementation: :doc:`/intro/model_details`\n- look at the implementation of the pre-defined models in tenpy.models.\n  most are based on the tenpy.models.model.couplingmpomodel as discussed here.\n- the tenpy.models.aklt.akltchain is a notable counter-example where it is actually\n  easier to define ``h_bond`` than to write down couplings.\n- if the hamiltonian is already given in mpo form (e.g. because it comes from some other software),\n  it can be used to directly build a model, as is done in ``examples/mpo_exponentially_decaying.py``. tutorial documentation model",
    "tokens": 5047
  },
  {
    "category": "tutorials",
    "name": "doc.input_output",
    "content": "--- DOCUMENTATION: input_output ---\nSaving to disk: input/output\n============================\n\n.. This file is maintained in the repository https://github.com/tenpy/hdf5_io.git\n.. It can be read online at https://tenpy.readthedocs.io/en/latest/intro/input_output.html\n\nUsing pickle\n------------\n\nA simple and pythonic way to store data of TeNPy arrays is to use pickle from the Python standard library.\nPickle allows you to store (almost) arbitrary python objects,\nand the tenpy.linalg.np_conserved.Array is no exception (and neither are other TeNPy classes).\n\nSay that you have run DMRG to get a ground state `psi` as an tenpy.networks.mps.MPS.\nWith pickle, you can save it to disk as follows::\n\n    import pickle\n    with open('my_psi_file.pkl', 'wb') as f:\n        pickle.dump(psi, f)\n\nHere, the ``with ... :`` structure ensures that the file gets closed after the pickle dump, and the ``'wb'`` indicates\nthe file opening mode is set to \"write binary\".\nReading the data from disk is as easy as (``'rb'`` for reading binary)::\n\n    with open('my_psi_file.pkl', 'rb') as f:\n        psi = pickle.load(f)\n\n    It is a good (scientific) practice to include meta-data to the file, like the parameters you used to generate that state.\n    Instead of just the `psi`, you can simply store a dictionary containing `psi` and other data, e.g.,\n    ``data = {'psi': psi, 'dmrg_params': dmrg_params, 'model_params': model_params}``.\n    This can *save you a lot of pain*, when you come back to look at the files a few month later and forgot what you've done to generate them!\n\nIn some cases, compression can significantly reduce the space needed to save the data.\nThis can for example be done with gzip (as well in the Python standard library).\nHowever, be warned that it might cause longer loading and saving times, i.e. it comes at the penalty of more CPU usage for the input/output.\nIn Python, this requires only small adjustments::\n\n    import pickle\n    import gzip\n\n    # to save:\n    with gzip.open('my_data_file.pkl', 'wb') as f:\n        pickle.dump(data, f)\n    # and to load:\n    with gzip.open('my_data_file.pkl', 'rb') as f:\n        data = pickle.load(data, f)\n\n\nUsing HDF5 with h5py\n--------------------\n\nWhile pickle is great for simple input/output of python objects, it also has disadvantages. The probably most\ndramatic one is the limited portability: saving data on one PC and loading it on another one might fail!\nEven exporting data from Python 2 to load them in Python 3 on the same machine can give quite some troubles.\nMoreover, pickle requires to load the whole file at once, which might be unnecessary if you only need part of the data,\nor even lead to memory problems if you have more data on disk than fits into RAM.\n\nHence, we support saving to `HDF5 <https://portal.hdfgroup.org/display/HDF5/HDF5>`_ files as an alternative.\nThe `h5py <https://docs.h5py.org>`_ package provides a dictionary-like interface for the file/group objects with\nnumpy-like data sets, and is quite easy to use.\nIf you don't know about HDF5, read the :ref:`quickstart <h5py:quick>` of the `h5py`_ documentation (and this guide).\n\nThe implementation can be found in the tenpy.tools.hdf5_io module with the\ntenpy.tools.hdf5_io.Hdf5Saver and tenpy.tools.hdf5_io.Hdf5Loader classes\nand the wrapper functions tenpy.tools.hdf5_io.save_to_hdf5, tenpy.tools.hdf5_io.load_from_hdf5.\n\nThe usage is very similar to pickle::\n\n    import h5py\n    from tenpy.tools import hdf5_io\n\n    data = {\"psi\": psi,  # e.g. an MPS\n            \"model\": my_model,\n            \"parameters\": {\"L\": 6, \"g\": 1.3}}\n\n    with h5py.File(\"file.h5\", 'w') as f:\n        hdf5_io.save_to_hdf5(f, data)\n    # ...\n    with h5py.File(\"file.h5\", 'r') as f:\n        data = hdf5_io.load_from_hdf5(f)\n        # or for partial reading:\n        pars = hdf5_io.load_from_hdf5(f, \"/parameters\")\n\n    Like loading a pickle file, loading data from a manipulated HDF5 file with the functions\n    described has the potential to cause arbitrary code execution.\n    Only load data from trusted sources!\n\n\n    The `hickle <https://github.com/telegraphic/hickle>`_ package imitates the pickle functionality\n    while saving the data to HDF5 files.\n    However, since it aims to be close to pickle, it results in a more complicated data structure than we want here.\n\n    To use the export/import features to HDF5, you need to install the `h5py`_ python package\n    (and hence some version of the HDF5 library).\n\n\nData format specification for saving to HDF5\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis section motivates and defines the format how we save data of TeNPy-defined classes.\nThe goal is to have the tenpy.tools.hdf5_io.save_to_hdf5 function for saving sufficiently simple enough python\nobjects (supported by the format) to disk in an HDF5 file, such that they can be reconstructed with the\ntenpy.tools.hdf5_io.load_from_hdf5 function, as outlined in the example code above.\n\nGuidelines of the format:\n\n0. Store enough data such that tenpy.tools.hdf5_io.load_from_hdf5 can reconstruct a copy of the object\n   (provided that the save did not fail with an error).\n1. Objects of a type supported by the HDF5 datasets (with the `h5py`_ interface) should be directly stored as h5py Dataset.\n   Such objects are for example numpy arrays (of non-object `dtype`), scalars and strings.\n2. Allow to save (nested) python lists, tuples and dictionaries with values (and keys) which can be saved.\n3. Allow user-defined classes to implement a well-defined interface which allows to save instances of that class, hence extending what data can be saved.\n   An instance of a class supporting the interface gets saved as an HDF5 Group.\n   Class attributes are stored as entries of the group, metadata like the type should be stored in HDF5 attributes, see :ref:`attributes <h5py:attributes>`.\n4. Simple and intuitive, human-readable structure for the HDF5 paths.\n   For example, saving a simple dictionary ``{'a': np.arange(10), 'b': 123.45}`` should result in an\n   HDF5 file with just the two data sets ``/a`` and ``/b``.\n5. Allow loading only a subset of the data by specifying the `path` of the HDF5 group to be loaded.\n   For the above example, specifying the path ``/b`` should result in loading the float ``123.45``, not the array.\n6. Avoid unnecessary copies if the same python object is referenced by different names, e.g,\n   for the data ``{'c': large_obj, 'd': large_obj}`` with to references to the same `large_obj`, save it only once and use HDF5 hard-links\n   such that ``/c`` and ``/d`` are the same HDF5 dataset/group.\n   Also avoid the copies during the loading, i.e., the loaded dictionary should again have two references to a single object `large_obj`.\n   This is also necessary to allow saving and loading of objects with cyclic references.\n\n\nThe full format specification is given by the what the code in tenpy.tools.hdf5_io does...\nSince this is not trivial to understand, let me summarize it here:\n\n- Following 1), simple scalars, strings and numpy arrays are saved as Dataset.\n  Other objects are saved as a HDF5 Group, with the actual data being saved as group members (as sub-groups and\n  sub-datasets) or as attributes (for metadata or simple data).\n- The type of the object is stored in the HDF5 attribute ``'type'``, which is one of the global ``REPR_*`` variables in\n  tenpy.tools.hdf5_io. The type determines the format for saving/loading of builtin types (list, ...)\n- Userdefined classes which should be possible to export/import need to implement the methods ``save_hdf5`` and ``from_hdf5``\n  as specified in tenpy.tools.hdf5_io.Hdf5Exportable.\n  When saving such a class, the attribute ``'type'`` is automatically set to ``'instance'``, and the class name and\n  module are saved under the attributes ``'module'`` and ``'class'``. During loading, this information is used to\n  automatically import the module, get the class and call the classmethod ``from_hdf5`` for reconstruction.\n  This can only work if the class definition already exists, i.e., you can only save class instances, not classes itself.\n- For most (python) classes, simply subclassing tenpy.tools.hdf5_io.Hdf5Exportable should work to make the class exportable.\n  The latter saves the contents of object.__dict__, with the extra attribute ``'format'`` specifying\n  whether the dictionary is \"simple\" (see below.).\n- The ``None`` object is saved as a group with the attribute ``'type'`` being ``'None'`` and no subgroups.\n- For iterables (list, tuple and set), we simple enumerate the entries and save entries as group members under the\n  names ``'0', '1', '2', ...``, and a maximum ``'len'`` attribute.\n- The format for dictionaries depends on whether all keys are \"simple\", which we define as being strings which are valid\n  path names in HDF5, see tenpy.tools.hdf5_io.valid_hdf5_path_component.\n  Following 4), the keys of a simple dictionary are directly used as names for group members,\n  and the values being whatever object the group member represents.\n- Partial loading along 5) is possible by directly specifying the subgroup or the path to tenpy.tools.hdf5_io.load_from_hdf5.\n- Guideline 6) is ensured as much as possible. However, there is a bug/exception:\n  tuples with cyclic references are not re-constructed correctly; the inner objects will be lists instead of tuples\n  (but with the same object entries).\n\nFinally, we have to mention that many TeNPy classes are tenpy.tools.hdf5_io.Hdf5Exportable.\nIn particular, the tenpy.linalg.np_conserved.Array supports this.\nTo see what the exact format for those classes is, look at the `save_hdf5` and `from_hdf5` methods of those classes.\n\n    There can be multiple possible output formats for the same object.\n    The dictionary -- with the format for simple keys or general keys -- is such an example,\n    but userdefined classes can use the same technique in their `from_hdf5` method.\n    The user might also explicitly choose a \"lossy\" output format (e.g. \"flat\" for np_conserved Arrays and LegCharges).\n\n    The above format specification is quite general and not bound to TeNPy. Feel free to use it in your own projects ;-)\n    To separate the development, versions and issues of the format clearly from TeNPy, we maintain the code for it in a separate git repository,\n    https://github.com/tenpy/hdf5_io",
    "search_text": "doc.input_output --- documentation: input_output ---\nsaving to disk: input/output\n============================\n\n.. this file is maintained in the repository https://github.com/tenpy/hdf5_io.git\n.. it can be read online at https://tenpy.readthedocs.io/en/latest/intro/input_output.html\n\nusing pickle\n------------\n\na simple and pythonic way to store data of tenpy arrays is to use pickle from the python standard library.\npickle allows you to store (almost) arbitrary python objects,\nand the tenpy.linalg.np_conserved.array is no exception (and neither are other tenpy classes).\n\nsay that you have run dmrg to get a ground state `psi` as an tenpy.networks.mps.mps.\nwith pickle, you can save it to disk as follows::\n\n    import pickle\n    with open('my_psi_file.pkl', 'wb') as f:\n        pickle.dump(psi, f)\n\nhere, the ``with ... :`` structure ensures that the file gets closed after the pickle dump, and the ``'wb'`` indicates\nthe file opening mode is set to \"write binary\".\nreading the data from disk is as easy as (``'rb'`` for reading binary)::\n\n    with open('my_psi_file.pkl', 'rb') as f:\n        psi = pickle.load(f)\n\n    it is a good (scientific) practice to include meta-data to the file, like the parameters you used to generate that state.\n    instead of just the `psi`, you can simply store a dictionary containing `psi` and other data, e.g.,\n    ``data = {'psi': psi, 'dmrg_params': dmrg_params, 'model_params': model_params}``.\n    this can *save you a lot of pain*, when you come back to look at the files a few month later and forgot what you've done to generate them!\n\nin some cases, compression can significantly reduce the space needed to save the data.\nthis can for example be done with gzip (as well in the python standard library).\nhowever, be warned that it might cause longer loading and saving times, i.e. it comes at the penalty of more cpu usage for the input/output.\nin python, this requires only small adjustments::\n\n    import pickle\n    import gzip\n\n    # to save:\n    with gzip.open('my_data_file.pkl', 'wb') as f:\n        pickle.dump(data, f)\n    # and to load:\n    with gzip.open('my_data_file.pkl', 'rb') as f:\n        data = pickle.load(data, f)\n\n\nusing hdf5 with h5py\n--------------------\n\nwhile pickle is great for simple input/output of python objects, it also has disadvantages. the probably most\ndramatic one is the limited portability: saving data on one pc and loading it on another one might fail!\neven exporting data from python 2 to load them in python 3 on the same machine can give quite some troubles.\nmoreover, pickle requires to load the whole file at once, which might be unnecessary if you only need part of the data,\nor even lead to memory problems if you have more data on disk than fits into ram.\n\nhence, we support saving to `hdf5 <https://portal.hdfgroup.org/display/hdf5/hdf5>`_ files as an alternative.\nthe `h5py <https://docs.h5py.org>`_ package provides a dictionary-like interface for the file/group objects with\nnumpy-like data sets, and is quite easy to use.\nif you don't know about hdf5, read the :ref:`quickstart <h5py:quick>` of the `h5py`_ documentation (and this guide).\n\nthe implementation can be found in the tenpy.tools.hdf5_io module with the\ntenpy.tools.hdf5_io.hdf5saver and tenpy.tools.hdf5_io.hdf5loader classes\nand the wrapper functions tenpy.tools.hdf5_io.save_to_hdf5, tenpy.tools.hdf5_io.load_from_hdf5.\n\nthe usage is very similar to pickle::\n\n    import h5py\n    from tenpy.tools import hdf5_io\n\n    data = {\"psi\": psi,  # e.g. an mps\n            \"model\": my_model,\n            \"parameters\": {\"l\": 6, \"g\": 1.3}}\n\n    with h5py.file(\"file.h5\", 'w') as f:\n        hdf5_io.save_to_hdf5(f, data)\n    # ...\n    with h5py.file(\"file.h5\", 'r') as f:\n        data = hdf5_io.load_from_hdf5(f)\n        # or for partial reading:\n        pars = hdf5_io.load_from_hdf5(f, \"/parameters\")\n\n    like loading a pickle file, loading data from a manipulated hdf5 file with the functions\n    described has the potential to cause arbitrary code execution.\n    only load data from trusted sources!\n\n\n    the `hickle <https://github.com/telegraphic/hickle>`_ package imitates the pickle functionality\n    while saving the data to hdf5 files.\n    however, since it aims to be close to pickle, it results in a more complicated data structure than we want here.\n\n    to use the export/import features to hdf5, you need to install the `h5py`_ python package\n    (and hence some version of the hdf5 library).\n\n\ndata format specification for saving to hdf5\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nthis section motivates and defines the format how we save data of tenpy-defined classes.\nthe goal is to have the tenpy.tools.hdf5_io.save_to_hdf5 function for saving sufficiently simple enough python\nobjects (supported by the format) to disk in an hdf5 file, such that they can be reconstructed with the\ntenpy.tools.hdf5_io.load_from_hdf5 function, as outlined in the example code above.\n\nguidelines of the format:\n\n0. store enough data such that tenpy.tools.hdf5_io.load_from_hdf5 can reconstruct a copy of the object\n   (provided that the save did not fail with an error).\n1. objects of a type supported by the hdf5 datasets (with the `h5py`_ interface) should be directly stored as h5py dataset.\n   such objects are for example numpy arrays (of non-object `dtype`), scalars and strings.\n2. allow to save (nested) python lists, tuples and dictionaries with values (and keys) which can be saved.\n3. allow user-defined classes to implement a well-defined interface which allows to save instances of that class, hence extending what data can be saved.\n   an instance of a class supporting the interface gets saved as an hdf5 group.\n   class attributes are stored as entries of the group, metadata like the type should be stored in hdf5 attributes, see :ref:`attributes <h5py:attributes>`.\n4. simple and intuitive, human-readable structure for the hdf5 paths.\n   for example, saving a simple dictionary ``{'a': np.arange(10), 'b': 123.45}`` should result in an\n   hdf5 file with just the two data sets ``/a`` and ``/b``.\n5. allow loading only a subset of the data by specifying the `path` of the hdf5 group to be loaded.\n   for the above example, specifying the path ``/b`` should result in loading the float ``123.45``, not the array.\n6. avoid unnecessary copies if the same python object is referenced by different names, e.g,\n   for the data ``{'c': large_obj, 'd': large_obj}`` with to references to the same `large_obj`, save it only once and use hdf5 hard-links\n   such that ``/c`` and ``/d`` are the same hdf5 dataset/group.\n   also avoid the copies during the loading, i.e., the loaded dictionary should again have two references to a single object `large_obj`.\n   this is also necessary to allow saving and loading of objects with cyclic references.\n\n\nthe full format specification is given by the what the code in tenpy.tools.hdf5_io does...\nsince this is not trivial to understand, let me summarize it here:\n\n- following 1), simple scalars, strings and numpy arrays are saved as dataset.\n  other objects are saved as a hdf5 group, with the actual data being saved as group members (as sub-groups and\n  sub-datasets) or as attributes (for metadata or simple data).\n- the type of the object is stored in the hdf5 attribute ``'type'``, which is one of the global ``repr_*`` variables in\n  tenpy.tools.hdf5_io. the type determines the format for saving/loading of builtin types (list, ...)\n- userdefined classes which should be possible to export/import need to implement the methods ``save_hdf5`` and ``from_hdf5``\n  as specified in tenpy.tools.hdf5_io.hdf5exportable.\n  when saving such a class, the attribute ``'type'`` is automatically set to ``'instance'``, and the class name and\n  module are saved under the attributes ``'module'`` and ``'class'``. during loading, this information is used to\n  automatically import the module, get the class and call the classmethod ``from_hdf5`` for reconstruction.\n  this can only work if the class definition already exists, i.e., you can only save class instances, not classes itself.\n- for most (python) classes, simply subclassing tenpy.tools.hdf5_io.hdf5exportable should work to make the class exportable.\n  the latter saves the contents of object.__dict__, with the extra attribute ``'format'`` specifying\n  whether the dictionary is \"simple\" (see below.).\n- the ``none`` object is saved as a group with the attribute ``'type'`` being ``'none'`` and no subgroups.\n- for iterables (list, tuple and set), we simple enumerate the entries and save entries as group members under the\n  names ``'0', '1', '2', ...``, and a maximum ``'len'`` attribute.\n- the format for dictionaries depends on whether all keys are \"simple\", which we define as being strings which are valid\n  path names in hdf5, see tenpy.tools.hdf5_io.valid_hdf5_path_component.\n  following 4), the keys of a simple dictionary are directly used as names for group members,\n  and the values being whatever object the group member represents.\n- partial loading along 5) is possible by directly specifying the subgroup or the path to tenpy.tools.hdf5_io.load_from_hdf5.\n- guideline 6) is ensured as much as possible. however, there is a bug/exception:\n  tuples with cyclic references are not re-constructed correctly; the inner objects will be lists instead of tuples\n  (but with the same object entries).\n\nfinally, we have to mention that many tenpy classes are tenpy.tools.hdf5_io.hdf5exportable.\nin particular, the tenpy.linalg.np_conserved.array supports this.\nto see what the exact format for those classes is, look at the `save_hdf5` and `from_hdf5` methods of those classes.\n\n    there can be multiple possible output formats for the same object.\n    the dictionary -- with the format for simple keys or general keys -- is such an example,\n    but userdefined classes can use the same technique in their `from_hdf5` method.\n    the user might also explicitly choose a \"lossy\" output format (e.g. \"flat\" for np_conserved arrays and legcharges).\n\n    the above format specification is quite general and not bound to tenpy. feel free to use it in your own projects ;-)\n    to separate the development, versions and issues of the format clearly from tenpy, we maintain the code for it in a separate git repository,\n    https://github.com/tenpy/hdf5_io tutorial documentation input_output",
    "tokens": 2514
  },
  {
    "category": "tutorials",
    "name": "doc.logging",
    "content": "--- DOCUMENTATION: logging ---\nLogging and terminal output\n===========================\n\nBy default, calling (almost) any function in TeNPy will not print output, apart from error messages, tracebacks, and warnings.\nInstead, we use Python's logging module to allow fine-grained redirecting of status messages etc.\n\nOf course, when you get an error message, you should be concerned to find out what it is about and how to fix it.\n(If you believe it is a bug, `report <https://github.com/tenpy/tenpy/issues/new/choose>`_ it.)\nWarnings can be reported either using ``warnings.warn(...)`` or with the logging mechanism ``logger.warning(...)``.\nThe former is used for warnings about things in your setup that you *should* fix.\nThe latter give you notifications about bad things that can happen in calculations, e.g. bad conditioning of a matrix, but there\nis not much you can do about it. Those warnings indicate that you should take your results with a grain of salt and carefully double-check them.\n\n\nConfiguring logging\n-------------------\nIf you also want to see status messages (e.g. during a DMRG run whenever a checkpoint is reached), you can use\nset the logging level to `logging.INFO` with the following, basic setup::\n\n    import logging\n    logging.basicConfig(level=logging.INFO)\n\nWe use this snippet in our examples to activate the printing of info messages to the standard output stream.\nFor really detailed output, you can even set the level to `logging.DEBUG`.\nlogging.basicConfig also takes a `filename` argument, which allows to redirect the output to a file\ninstead of stdout. Note that you should call `basicConfig` only once; subsequent calls have no effect.\n\n\nMore detailed configurations can be made through logging.config.\nFor example, the following both prints log messages to stdout and saves them to ``output_filename.log``::\n\n    import logging.config\n    conf = {\n        'version': 1\n        'disable_existing_loggers': False,\n        'formatters': {'custom': {'format': '%(levelname)-8s: %(message)s'}},\n        'handlers': {'to_file': {'class': 'logging.FileHandler',\n                                 'filename': 'output_filename.log',\n                                 'formatter': 'custom',\n                                 'level': 'INFO',\n                                 'mode': 'a'},\n                    'to_stdout': {'class': 'logging.StreamHandler',\n                                  'formatter': 'custom',\n                                  'level': 'INFO',\n                                  'stream': 'ext://sys.stdout'}},\n        'root': {'handlers': ['to_stdout', 'to_file'], 'level': 'DEBUG'},\n    }\n    logging.config.dictConfig(conf)\n\n\n    Whether you use logging.config.fileConfig or the logging.config.dictConfig,\n    make sure that you also set ``disable_existing_loggers=False``.\n    Otherwise, it will not work as expected in the case where you ``import tenpy`` before setting up the logging.\n\nTo also capture warnings, you might also want to call logging.captureWarnings.\n\nIn fact, the above is the default configuration used by tenpy.tools.misc.setup_logging.\nIf you use a tenpy.simulations.simulation.Simulation class, it will automatically\ncall tenpy.tools.misc.setup_logging for you, saving the log to the same filename as the :cfgSimulation.output_filename but with a ``.log`` ending.\nMoreover, you can easily adjust the log levels with simple parameters, for example with the following configuration (using [yaml]_ notation):\n\n\n    log_params:\n        to_stdout:     # nothing in yaml -> None in python => no logging to stdout\n        to_file: INFO\n        logger_levels:\n            tenpy.tools.params : WARNING  # suppress INFO/DEBUG output for any logging of parameters\n\nOf course, you can also explicitly call the tenpy.tools.misc.setup_logging yourself, if you don't use the `Simulation` classes::\n\n    tenpy.tools.misc.setup_logging({'to_stdout': None, 'to_file': 'INFO', 'filename': 'my_log.txt',\n                                    'log_levels': {'tenpy.tools.params': 'WARNING'}})\n\n\nHow to write your own logging (and warning) code\n------------------------------------------------\nOf course, you can still use simple ``print(...)`` statements in your code, and they will just appear on your screen.\nIn fact, this is one of the benefits of logging: you can make sure that you *only* get the print statements you have put\nyourself, and at the same time redirect the logging messages of tenpy to a file, if you want.\n\nHowever, these ``print(...)`` statements are not re-directed to the log-files.\nTherefore, if you write your own sub-classes like Models, I would recommended that you also use the loggers instead of\nsimple print statements.\nYou can read the `official logging tutorial <https://docs.python.org/3/howto/logging.html>`_ for details,\nbut it's actually straight-forward, and just requires at most two steps.\n\n1.  If necessary, import the necessary modules and create a logger at the top of your module::\n\n        import warnings\n        import logging\n        logger = logging.getLogger(__name__)\n\n\n        Most TeNPy classes that you might want to subclass, like models, algorithm engines or simulations,\n        provide a logging.Logger as ``self.logger`` class attribute.\n        In that case you can even **skip** this step and just use ``self.logger`` instead of ``logger`` in the snippets\n        below.\n\n2.  Inside your functions/methods/..., make calls like this::\n\n        if is_likely_bad(options['parameter']):\n            # this can be fixed by the user!\n            warnings.warn(\"This is a bad parameter, you shouldn't do this!\")\n        if \"old_parameter\" in options:\n            warnings.warn(\"Use `new_parameter` instead of `old_parameter`\", FutureWarning, 2)\n\n        logger.info(\"starting some lengthy calculation\")\n        n_steps = do_calculation()\n        if something_bad_happened():\n            # the user can't do anything about it\n            logger.warning(\"Something bad happened\")\n        logger.info(\"calculation finished after %d steps\", n_steps)\n\n    You can use `printf-formatting <https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting>`_\n    for the arguments of ``logger.debug(...), logger.info(...), logger.warning(...)``, as illustrated in the last line.\n\nIn summary, instead of just ``print(\"do X\")`` statements, use ``self.logger.info(\"do X\")`` inside TeNPy classes, or just\n``logger.info(\"do X\")`` for the module-wide logger, which you can initialize right at the top of your file with the import\nstatements. If you have non-string arguments, add a formatter string, e.g. replace ``print(max(psi.chi))`` with\n``logger.info(\"%d\", max(psi.chi))``, or even better, ``logger.info(\"max(chi)=%d\", max(psi.chi))``.\nFor generic types, use ``\"%s\"`` or ``\"%r\"``, which converts the other arguments to strings with ``str(...)`` or ``repr(...)``, respectively.",
    "search_text": "doc.logging --- documentation: logging ---\nlogging and terminal output\n===========================\n\nby default, calling (almost) any function in tenpy will not print output, apart from error messages, tracebacks, and warnings.\ninstead, we use python's logging module to allow fine-grained redirecting of status messages etc.\n\nof course, when you get an error message, you should be concerned to find out what it is about and how to fix it.\n(if you believe it is a bug, `report <https://github.com/tenpy/tenpy/issues/new/choose>`_ it.)\nwarnings can be reported either using ``warnings.warn(...)`` or with the logging mechanism ``logger.warning(...)``.\nthe former is used for warnings about things in your setup that you *should* fix.\nthe latter give you notifications about bad things that can happen in calculations, e.g. bad conditioning of a matrix, but there\nis not much you can do about it. those warnings indicate that you should take your results with a grain of salt and carefully double-check them.\n\n\nconfiguring logging\n-------------------\nif you also want to see status messages (e.g. during a dmrg run whenever a checkpoint is reached), you can use\nset the logging level to `logging.info` with the following, basic setup::\n\n    import logging\n    logging.basicconfig(level=logging.info)\n\nwe use this snippet in our examples to activate the printing of info messages to the standard output stream.\nfor really detailed output, you can even set the level to `logging.debug`.\nlogging.basicconfig also takes a `filename` argument, which allows to redirect the output to a file\ninstead of stdout. note that you should call `basicconfig` only once; subsequent calls have no effect.\n\n\nmore detailed configurations can be made through logging.config.\nfor example, the following both prints log messages to stdout and saves them to ``output_filename.log``::\n\n    import logging.config\n    conf = {\n        'version': 1\n        'disable_existing_loggers': false,\n        'formatters': {'custom': {'format': '%(levelname)-8s: %(message)s'}},\n        'handlers': {'to_file': {'class': 'logging.filehandler',\n                                 'filename': 'output_filename.log',\n                                 'formatter': 'custom',\n                                 'level': 'info',\n                                 'mode': 'a'},\n                    'to_stdout': {'class': 'logging.streamhandler',\n                                  'formatter': 'custom',\n                                  'level': 'info',\n                                  'stream': 'ext://sys.stdout'}},\n        'root': {'handlers': ['to_stdout', 'to_file'], 'level': 'debug'},\n    }\n    logging.config.dictconfig(conf)\n\n\n    whether you use logging.config.fileconfig or the logging.config.dictconfig,\n    make sure that you also set ``disable_existing_loggers=false``.\n    otherwise, it will not work as expected in the case where you ``import tenpy`` before setting up the logging.\n\nto also capture warnings, you might also want to call logging.capturewarnings.\n\nin fact, the above is the default configuration used by tenpy.tools.misc.setup_logging.\nif you use a tenpy.simulations.simulation.simulation class, it will automatically\ncall tenpy.tools.misc.setup_logging for you, saving the log to the same filename as the :cfgsimulation.output_filename but with a ``.log`` ending.\nmoreover, you can easily adjust the log levels with simple parameters, for example with the following configuration (using [yaml]_ notation):\n\n\n    log_params:\n        to_stdout:     # nothing in yaml -> none in python => no logging to stdout\n        to_file: info\n        logger_levels:\n            tenpy.tools.params : warning  # suppress info/debug output for any logging of parameters\n\nof course, you can also explicitly call the tenpy.tools.misc.setup_logging yourself, if you don't use the `simulation` classes::\n\n    tenpy.tools.misc.setup_logging({'to_stdout': none, 'to_file': 'info', 'filename': 'my_log.txt',\n                                    'log_levels': {'tenpy.tools.params': 'warning'}})\n\n\nhow to write your own logging (and warning) code\n------------------------------------------------\nof course, you can still use simple ``print(...)`` statements in your code, and they will just appear on your screen.\nin fact, this is one of the benefits of logging: you can make sure that you *only* get the print statements you have put\nyourself, and at the same time redirect the logging messages of tenpy to a file, if you want.\n\nhowever, these ``print(...)`` statements are not re-directed to the log-files.\ntherefore, if you write your own sub-classes like models, i would recommended that you also use the loggers instead of\nsimple print statements.\nyou can read the `official logging tutorial <https://docs.python.org/3/howto/logging.html>`_ for details,\nbut it's actually straight-forward, and just requires at most two steps.\n\n1.  if necessary, import the necessary modules and create a logger at the top of your module::\n\n        import warnings\n        import logging\n        logger = logging.getlogger(__name__)\n\n\n        most tenpy classes that you might want to subclass, like models, algorithm engines or simulations,\n        provide a logging.logger as ``self.logger`` class attribute.\n        in that case you can even **skip** this step and just use ``self.logger`` instead of ``logger`` in the snippets\n        below.\n\n2.  inside your functions/methods/..., make calls like this::\n\n        if is_likely_bad(options['parameter']):\n            # this can be fixed by the user!\n            warnings.warn(\"this is a bad parameter, you shouldn't do this!\")\n        if \"old_parameter\" in options:\n            warnings.warn(\"use `new_parameter` instead of `old_parameter`\", futurewarning, 2)\n\n        logger.info(\"starting some lengthy calculation\")\n        n_steps = do_calculation()\n        if something_bad_happened():\n            # the user can't do anything about it\n            logger.warning(\"something bad happened\")\n        logger.info(\"calculation finished after %d steps\", n_steps)\n\n    you can use `printf-formatting <https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting>`_\n    for the arguments of ``logger.debug(...), logger.info(...), logger.warning(...)``, as illustrated in the last line.\n\nin summary, instead of just ``print(\"do x\")`` statements, use ``self.logger.info(\"do x\")`` inside tenpy classes, or just\n``logger.info(\"do x\")`` for the module-wide logger, which you can initialize right at the top of your file with the import\nstatements. if you have non-string arguments, add a formatter string, e.g. replace ``print(max(psi.chi))`` with\n``logger.info(\"%d\", max(psi.chi))``, or even better, ``logger.info(\"max(chi)=%d\", max(psi.chi))``.\nfor generic types, use ``\"%s\"`` or ``\"%r\"``, which converts the other arguments to strings with ``str(...)`` or ``repr(...)``, respectively. tutorial documentation logging",
    "tokens": 1478
  },
  {
    "category": "tutorials",
    "name": "doc.todo",
    "content": "--- DOCUMENTATION: todo ---\nTo-Do list\n==========\n\nYou can check https://github.com/tenpy/tenpy/issues for things to be done.\n\nThe following list is auto-generated by sphinx, extracting ``.. todo ::`` blocks from doc-strings of the code.\n",
    "search_text": "doc.todo --- documentation: todo ---\nto-do list\n==========\n\nyou can check https://github.com/tenpy/tenpy/issues for things to be done.\n\nthe following list is auto-generated by sphinx, extracting ``.. todo ::`` blocks from doc-strings of the code.\n tutorial documentation todo",
    "tokens": 58
  },
  {
    "category": "tutorials",
    "name": "doc.guidelines",
    "content": "--- DOCUMENTATION: guidelines ---\nCoding Guidelines\n=================\nWe ask you to comply with the following guidelines for contributions\nMost of our coding guidelines are explicitly checked by the GitHub actions that run on every pull\nrequest, but there are some extra guidelines below.\n\nWe have a `pre-commit <https://pre-commit.com/>`_ configuration in the repository that should make\nit easy for somewhat experienced developers to adhere to the automatically checked rules.\nIf it detects any violation it stops the commit, reports them and automatically fixes them if possible.\nIn addition, follow the list of guidelines below, which is not automatically checked by tools.\n\nIf you are having trouble with the guidelines, please don't let that stop you from sharing your contribution.\nSomeone from the team can finish up.\n\n\nGuidelines\n~~~~~~~~~~\n\n- Summarize the changes you have made in the changelog.\n  Make a new file, and e.g. name it after the PR, ``doc/changelog/latest/pr_401.txt`` or similar.\n  Make sure to use ``.txt`` suffix.\n  It should contain only bullet points.\n  See e.g. `this example <https://github.com/tenpy/tenpy/blob/b49485e7cfdfe9ec4fe740e6dbeea3451783840b/doc/changelog/latest/pr_520.txt>`_.\n\n- If you add a new toycode or example: add a reference to include it in the documentation.\n\n- Use relative imports within TeNPy. Example::\n\n      from ..linalg import np_conserved as npc\n\n\n- Include documentation, Put a docstring on every new module, class and function.\n  See the section on docs below.\n\n- Include tests for your new features. See the existing ones in the ``tests/`` folder.\n\n- Long running tests are marked with ``@pytest.mark.slow``. You can exclude them by running only\n  ``pytest -m \"not slow\"``. If your new tests are slow (``> 10s`` total), mark them accordingly.\n\n- Preserve backwards compatibility as far as possible.\n  If you change how a feature works, or how it is accessed or what its function signature is,\n  keep the deprecated version around with suitable deprecation warnings.\n  Issue a ``DeprecationWarning`` or ``FutureWarning`` when the deprecated implementation is used.\n  A common pattern for deprecated classes is to subclass from the new implementation and override\n  methods as needed.\n  Use the ``.. deprecated ::`` directive in the docstring and describe what should be used instead.\n  Include a version number roughly 2-3 versions in the future, at which the deprecated version will\n  be removed.\n  Make sure you update the changelog, clearly stating which new feature replaces which old one in\n  what circumstance.\n  For deprecated config options use tenpy.tools.config.Config.deprecated_alias or\n  tenpy.tools.config.Config.deprecated_ignore.\n\n- Prefer GitHub issues over todo comments in the code.\n  Do not leave todo comments unless you take responsibility to take care of the todo later.\n  Even if you do, GitHub issues are a better place to keep track of open todos.\n\n- Unfinished functions should ``raise NotImplementedError()``.\n\n\n\nLinter rules\n~~~~~~~~~~~~\nThe following rules are explicitly checked both by GitHub actions, as well as by the pre-commit\nconfiguration\n\n- Basic sanity checks (dont push private keys, yaml files should be valid, no debugging leftovers, ...)\n\n- Linting of the python code using ``ruff check``, with the rules configured in ``pyproject.toml``.\n\n- Linting of docstrings using ``flake8-rst-docstrings``, with the rules configured in ``.flake8``\n\n- Autoformatting using ``ruff format``. The pre-commit simply does these changes and amends them,\n  the GitHub action only checks that another run would not change anything but does not propose\n  these changes. You can either read the diff in the action logs, or better run ``ruff`` locally,\n  e.g. via ``pre-commit``.\n\n- Check that text files do not contain the specific strings ``FIXME`` and ``DONTSHIP``.\n  You may use them in your workflow as reminders to do something before committing/pushing.\n\n\nWorkarounds\n~~~~~~~~~~~\nAutomated tools are never perfect.\nIf the tool complains and you are reasonably sure that it is wrong, you can use the following workarounds.\nUse them *responsibly* and *sparingly*.\n\n- You can disable linters locally using ``# noqa <rule>`` comments.\n  See `ruff: Error suppression <https://docs.astral.sh/ruff/linter/#error-suppression>`_.\n\n- You can ignore linter rules in ``pyproject.toml``. Prefer per-file ignores over global ignores.\n  See `ruff: Error suppression <https://docs.astral.sh/ruff/linter/#error-suppression>`_.\n\n- You can disable autoformatting locally by using\n  `pragma comments <https://docs.astral.sh/ruff/formatter/#format-suppression>`_.\n\n- You can exclude files for ruff in ``pyproject.toml``. Do this only with a solid reason!\n  See `ruff: exclude <https://docs.astral.sh/ruff/settings/#exclude>`_.\n\n\nDocumentation\n~~~~~~~~~~~~~\n- Every function/class/module should be documented by its doc-string, see 257.\n\n  Additional documentation for the user guide is in the folder ``doc/``.\n\n  The documentation uses `reStructuredText`. If you are new to `reStructuredText`, read this `introduction <http://www.sphinx-doc.org/en/stable/rest.html>`_.\n  We use the `numpy` style for doc-strings (with the `napoleon <https://www.sphinx-doc.org/en/master/usage/extensions/napoleon.html>`_ extension to sphinx).\n  You can read about them in these `Instructions for the doc strings <https://numpydoc.readthedocs.io/en/latest/format.html>`_.\n  In addition, you can take a look at the following `example file <https://github.com/numpy/numpydoc/blob/main/doc/example.py>`_.\n  Helpful hints on top of that::\n\n        r\"\"\"<- this r makes me a raw string, thus '\\' has no special meaning.\n        Otherwise you would need to escape backslashes, e.g. in math formulas.\n\n        You can include cross references to classes, methods, functions, modules like\n        tenpy.linalg.np_conserved.Array, tenpy.linalg.np_conserved.Array.to_ndarray,\n        tenpy.tools.math.toiterable, tenpy.linalg.np_conserved.\n        The ~ in the beginning makes only the last part of the name appear in the generated documentation.\n        Documents of the userguide can be referenced with :doc:`/intro_npc` even from inside the doc-strings.\n        You can also cross-link to other documentations, e.g. numpy.ndarray, :func`scipy.linalg.svd` and :mod: will work.\n\n        Moreover, you can link to github issues, arXiv papers, dois, and topics in the community forum with\n        e.g. 5, 1805.00055, :doi:`10.1000/1` and 3.\n\n        Citations from the literature list can be cited as white1992 using the bibtex key.\n\n        Write inline formulas as :math:`H |\\Psi\\rangle = E |\\Psi\\rangle` or displayed equations as\n\n            e^{i\\pi} + 1 = 0\n\n        To refer to variables within math, use `\\mathtt{varname}`.\n\n        \"\"\"\n\n- We've created a sphinx extensions for `documenting config-option dictionaries <https://sphinx-cfg-options.readthedocs.io/en/latest/>`_.\n  If a class takes a dictionary of options, we usually call it ``options``,\n  convert it to a tenpy.tools.params.Config at the very beginning of the ``__init__`` with\n  tenpy.tools.params.asConfig, save it as ``self.options``,\n  and document it in the class doc-string with a ``.. cfg:config ::`` directive.\n  The name of the ``config`` should usually be the class-name (if that is sufficiently unique),\n  or for algorithms directly the common name of the algorithm, e.g. \"DMRG\"; use the same name for the\n  use the same name for the documentation of the ``.. cfg:config ::`` directive as for the\n  tenpy.tools.params.Config class instance.\n  Attributes which are simply read-out options should be documented by just referencing the options with the\n  ``:cfgconfigname.optionname`` role.",
    "search_text": "doc.guidelines --- documentation: guidelines ---\ncoding guidelines\n=================\nwe ask you to comply with the following guidelines for contributions\nmost of our coding guidelines are explicitly checked by the github actions that run on every pull\nrequest, but there are some extra guidelines below.\n\nwe have a `pre-commit <https://pre-commit.com/>`_ configuration in the repository that should make\nit easy for somewhat experienced developers to adhere to the automatically checked rules.\nif it detects any violation it stops the commit, reports them and automatically fixes them if possible.\nin addition, follow the list of guidelines below, which is not automatically checked by tools.\n\nif you are having trouble with the guidelines, please don't let that stop you from sharing your contribution.\nsomeone from the team can finish up.\n\n\nguidelines\n~~~~~~~~~~\n\n- summarize the changes you have made in the changelog.\n  make a new file, and e.g. name it after the pr, ``doc/changelog/latest/pr_401.txt`` or similar.\n  make sure to use ``.txt`` suffix.\n  it should contain only bullet points.\n  see e.g. `this example <https://github.com/tenpy/tenpy/blob/b49485e7cfdfe9ec4fe740e6dbeea3451783840b/doc/changelog/latest/pr_520.txt>`_.\n\n- if you add a new toycode or example: add a reference to include it in the documentation.\n\n- use relative imports within tenpy. example::\n\n      from ..linalg import np_conserved as npc\n\n\n- include documentation, put a docstring on every new module, class and function.\n  see the section on docs below.\n\n- include tests for your new features. see the existing ones in the ``tests/`` folder.\n\n- long running tests are marked with ``@pytest.mark.slow``. you can exclude them by running only\n  ``pytest -m \"not slow\"``. if your new tests are slow (``> 10s`` total), mark them accordingly.\n\n- preserve backwards compatibility as far as possible.\n  if you change how a feature works, or how it is accessed or what its function signature is,\n  keep the deprecated version around with suitable deprecation warnings.\n  issue a ``deprecationwarning`` or ``futurewarning`` when the deprecated implementation is used.\n  a common pattern for deprecated classes is to subclass from the new implementation and override\n  methods as needed.\n  use the ``.. deprecated ::`` directive in the docstring and describe what should be used instead.\n  include a version number roughly 2-3 versions in the future, at which the deprecated version will\n  be removed.\n  make sure you update the changelog, clearly stating which new feature replaces which old one in\n  what circumstance.\n  for deprecated config options use tenpy.tools.config.config.deprecated_alias or\n  tenpy.tools.config.config.deprecated_ignore.\n\n- prefer github issues over todo comments in the code.\n  do not leave todo comments unless you take responsibility to take care of the todo later.\n  even if you do, github issues are a better place to keep track of open todos.\n\n- unfinished functions should ``raise notimplementederror()``.\n\n\n\nlinter rules\n~~~~~~~~~~~~\nthe following rules are explicitly checked both by github actions, as well as by the pre-commit\nconfiguration\n\n- basic sanity checks (dont push private keys, yaml files should be valid, no debugging leftovers, ...)\n\n- linting of the python code using ``ruff check``, with the rules configured in ``pyproject.toml``.\n\n- linting of docstrings using ``flake8-rst-docstrings``, with the rules configured in ``.flake8``\n\n- autoformatting using ``ruff format``. the pre-commit simply does these changes and amends them,\n  the github action only checks that another run would not change anything but does not propose\n  these changes. you can either read the diff in the action logs, or better run ``ruff`` locally,\n  e.g. via ``pre-commit``.\n\n- check that text files do not contain the specific strings ``fixme`` and ``dontship``.\n  you may use them in your workflow as reminders to do something before committing/pushing.\n\n\nworkarounds\n~~~~~~~~~~~\nautomated tools are never perfect.\nif the tool complains and you are reasonably sure that it is wrong, you can use the following workarounds.\nuse them *responsibly* and *sparingly*.\n\n- you can disable linters locally using ``# noqa <rule>`` comments.\n  see `ruff: error suppression <https://docs.astral.sh/ruff/linter/#error-suppression>`_.\n\n- you can ignore linter rules in ``pyproject.toml``. prefer per-file ignores over global ignores.\n  see `ruff: error suppression <https://docs.astral.sh/ruff/linter/#error-suppression>`_.\n\n- you can disable autoformatting locally by using\n  `pragma comments <https://docs.astral.sh/ruff/formatter/#format-suppression>`_.\n\n- you can exclude files for ruff in ``pyproject.toml``. do this only with a solid reason!\n  see `ruff: exclude <https://docs.astral.sh/ruff/settings/#exclude>`_.\n\n\ndocumentation\n~~~~~~~~~~~~~\n- every function/class/module should be documented by its doc-string, see 257.\n\n  additional documentation for the user guide is in the folder ``doc/``.\n\n  the documentation uses `restructuredtext`. if you are new to `restructuredtext`, read this `introduction <http://www.sphinx-doc.org/en/stable/rest.html>`_.\n  we use the `numpy` style for doc-strings (with the `napoleon <https://www.sphinx-doc.org/en/master/usage/extensions/napoleon.html>`_ extension to sphinx).\n  you can read about them in these `instructions for the doc strings <https://numpydoc.readthedocs.io/en/latest/format.html>`_.\n  in addition, you can take a look at the following `example file <https://github.com/numpy/numpydoc/blob/main/doc/example.py>`_.\n  helpful hints on top of that::\n\n        r\"\"\"<- this r makes me a raw string, thus '\\' has no special meaning.\n        otherwise you would need to escape backslashes, e.g. in math formulas.\n\n        you can include cross references to classes, methods, functions, modules like\n        tenpy.linalg.np_conserved.array, tenpy.linalg.np_conserved.array.to_ndarray,\n        tenpy.tools.math.toiterable, tenpy.linalg.np_conserved.\n        the ~ in the beginning makes only the last part of the name appear in the generated documentation.\n        documents of the userguide can be referenced with :doc:`/intro_npc` even from inside the doc-strings.\n        you can also cross-link to other documentations, e.g. numpy.ndarray, :func`scipy.linalg.svd` and :mod: will work.\n\n        moreover, you can link to github issues, arxiv papers, dois, and topics in the community forum with\n        e.g. 5, 1805.00055, :doi:`10.1000/1` and 3.\n\n        citations from the literature list can be cited as white1992 using the bibtex key.\n\n        write inline formulas as :math:`h |\\psi\\rangle = e |\\psi\\rangle` or displayed equations as\n\n            e^{i\\pi} + 1 = 0\n\n        to refer to variables within math, use `\\mathtt{varname}`.\n\n        \"\"\"\n\n- we've created a sphinx extensions for `documenting config-option dictionaries <https://sphinx-cfg-options.readthedocs.io/en/latest/>`_.\n  if a class takes a dictionary of options, we usually call it ``options``,\n  convert it to a tenpy.tools.params.config at the very beginning of the ``__init__`` with\n  tenpy.tools.params.asconfig, save it as ``self.options``,\n  and document it in the class doc-string with a ``.. cfg:config ::`` directive.\n  the name of the ``config`` should usually be the class-name (if that is sufficiently unique),\n  or for algorithms directly the common name of the algorithm, e.g. \"dmrg\"; use the same name for the\n  use the same name for the documentation of the ``.. cfg:config ::`` directive as for the\n  tenpy.tools.params.config class instance.\n  attributes which are simply read-out options should be documented by just referencing the options with the\n  ``:cfgconfigname.optionname`` role. tutorial documentation guidelines",
    "tokens": 1805
  },
  {
    "category": "tutorials",
    "name": "doc.build_doc",
    "content": "--- DOCUMENTATION: build_doc ---\nBuilding the documentation\n==========================\n\nYou can use `Sphinx <https://www.sphinx-doc.org>`_ to generate the full documentation\nin various formats (including HTML or PDF) yourself, as described in the following.\n\nFirst, I will assume that you downloaded the [TeNPySource]_ repository with::\n\n    git clone --recursive https://github.com/tenpy/tenpy\n\nThis includes the [TeNPyNotebooks]_ as a git submodule; you might need to `git submodule update` if it is out of date.\n\nBuilding the documentation requires a few more packages (including `Sphinx`_).\nThe recommended way is to create a separate conda environment for it with::\n\n    conda env create -f doc/environment.yml  # make sure to use the file from the doc/ subfolder!\n    conda activate tenpydoc\n\nAlternatively, you can use `pip` and ``pip install -r doc/requirements.txt``, but this will not be able to install\nall dependencies: some packages like `Graphviz <https://graphviz.org/>`_ are not available from pip alone.\n\nAfterwards, simply go to the folder ``doc/`` and run the following command::\n\n    make html\n\nThis should generate the html documentation in the folder `doc/sphinx_build/html`.\nOpen this folder (or to be precise: the file `index.html` in it) in your webbrowser\nand enjoy this and other documentation beautifully rendered, with cross links, math formulas\nand even a search function.\nOther output formats are available as other make targets, e.g., ``make latexpdf``.\n\n\n   Building the documentation with sphinx requires loading the TeNPy modules.\n   The `conf.py` adjusts the python `sys.path` to include the `/tenpy` folder from root directory of the git repository.\n   It will not use the cython-compiled parts.\n\nTroubleshooting\n---------------\n\nIf you get an error along the lines of ::\n\n    Exception occurred:\n    File \"/home/runner/work/tenpy/tenpy/doc/sphinx_ext/sphinx_cfg_options.py\", line 227, in run\n        assert isinstance(desc_content, addnodes.desc_content)\n\nMake sure that the config directives, such as e.g. ``.. cfg:config ::`` or ``.. cfg:configoptions ::``\nare followed by an empty line.",
    "search_text": "doc.build_doc --- documentation: build_doc ---\nbuilding the documentation\n==========================\n\nyou can use `sphinx <https://www.sphinx-doc.org>`_ to generate the full documentation\nin various formats (including html or pdf) yourself, as described in the following.\n\nfirst, i will assume that you downloaded the [tenpysource]_ repository with::\n\n    git clone --recursive https://github.com/tenpy/tenpy\n\nthis includes the [tenpynotebooks]_ as a git submodule; you might need to `git submodule update` if it is out of date.\n\nbuilding the documentation requires a few more packages (including `sphinx`_).\nthe recommended way is to create a separate conda environment for it with::\n\n    conda env create -f doc/environment.yml  # make sure to use the file from the doc/ subfolder!\n    conda activate tenpydoc\n\nalternatively, you can use `pip` and ``pip install -r doc/requirements.txt``, but this will not be able to install\nall dependencies: some packages like `graphviz <https://graphviz.org/>`_ are not available from pip alone.\n\nafterwards, simply go to the folder ``doc/`` and run the following command::\n\n    make html\n\nthis should generate the html documentation in the folder `doc/sphinx_build/html`.\nopen this folder (or to be precise: the file `index.html` in it) in your webbrowser\nand enjoy this and other documentation beautifully rendered, with cross links, math formulas\nand even a search function.\nother output formats are available as other make targets, e.g., ``make latexpdf``.\n\n\n   building the documentation with sphinx requires loading the tenpy modules.\n   the `conf.py` adjusts the python `sys.path` to include the `/tenpy` folder from root directory of the git repository.\n   it will not use the cython-compiled parts.\n\ntroubleshooting\n---------------\n\nif you get an error along the lines of ::\n\n    exception occurred:\n    file \"/home/runner/work/tenpy/tenpy/doc/sphinx_ext/sphinx_cfg_options.py\", line 227, in run\n        assert isinstance(desc_content, addnodes.desc_content)\n\nmake sure that the config directives, such as e.g. ``.. cfg:config ::`` or ``.. cfg:configoptions ::``\nare followed by an empty line. tutorial documentation build_doc",
    "tokens": 493
  },
  {
    "category": "tutorials",
    "name": "doc.module",
    "content": "--- DOCUMENTATION: module ---\n{{ name | escape | underline }}\n\n- full name: {{ fullname | escape }}\n- parent module: :mod:`{{ module }}`\n- type: {{ objtype }}\n\n\n{% if classes %}\n\n    :parts: 1\n\n    :toctree: .\n    {% for class in classes %}\n    {{ class }}\n    {% endfor %}\n\n{% endif %}{% if exceptions %}\n\n    :toctree: .\n    {% for exc in exceptions %}\n    {{ exc}}\n    {% endfor %}\n\n{% endif %}{% if functions %}\n\n    :toctree: .\n    {% for function in functions %}\n    {{ function }}\n    {% endfor %}\n\n{% endif %}\n\n\n    :show-inheritance:",
    "search_text": "doc.module --- documentation: module ---\n{{ name | escape | underline }}\n\n- full name: {{ fullname | escape }}\n- parent module: :mod:`{{ module }}`\n- type: {{ objtype }}\n\n\n{% if classes %}\n\n    :parts: 1\n\n    :toctree: .\n    {% for class in classes %}\n    {{ class }}\n    {% endfor %}\n\n{% endif %}{% if exceptions %}\n\n    :toctree: .\n    {% for exc in exceptions %}\n    {{ exc}}\n    {% endfor %}\n\n{% endif %}{% if functions %}\n\n    :toctree: .\n    {% for function in functions %}\n    {{ function }}\n    {% endfor %}\n\n{% endif %}\n\n\n    :show-inheritance: tutorial documentation module",
    "tokens": 153
  },
  {
    "category": "tutorials",
    "name": "doc.class",
    "content": "--- DOCUMENTATION: class ---\n{{ name | escape | underline }}\n\n- full name: {{ fullname | escape }}\n- parent module: :mod:`{{ module }}`\n- type: {{ objtype }}\n\n\n\n    :parts: 1\n\n{% if methods %}\n\n{% for item in methods %}\n    {{ name }}.{{ item }}\n{%- endfor %}\n{% endif %}\n{% if attributes %}\n\n{% for item in attributes %}\n    {{ name }}.{{ item }}\n{%- endfor %}\n{% endif %}\n\n\n    :members:\n    :member-order: bysource\n    :inherited-members:\n    :show-inheritance:",
    "search_text": "doc.class --- documentation: class ---\n{{ name | escape | underline }}\n\n- full name: {{ fullname | escape }}\n- parent module: :mod:`{{ module }}`\n- type: {{ objtype }}\n\n\n\n    :parts: 1\n\n{% if methods %}\n\n{% for item in methods %}\n    {{ name }}.{{ item }}\n{%- endfor %}\n{% endif %}\n{% if attributes %}\n\n{% for item in attributes %}\n    {{ name }}.{{ item }}\n{%- endfor %}\n{% endif %}\n\n\n    :members:\n    :member-order: bysource\n    :inherited-members:\n    :show-inheritance: tutorial documentation class",
    "tokens": 127
  },
  {
    "category": "tutorials",
    "name": "doc.base",
    "content": "--- DOCUMENTATION: base ---\n{{ name | escape | underline}}\n\n- full name: {{ fullname | escape }}\n- parent module: :mod:`{{ module }}`\n- type: {{ objtype }}\n\n",
    "search_text": "doc.base --- documentation: base ---\n{{ name | escape | underline}}\n\n- full name: {{ fullname | escape }}\n- parent module: :mod:`{{ module }}`\n- type: {{ objtype }}\n\n tutorial documentation base",
    "tokens": 40
  },
  {
    "category": "tutorials",
    "name": "doc.extra",
    "content": "--- DOCUMENTATION: extra ---\nExtra requirements\n==================\n\nWe have some extra requirements that you don't need to install to use TeNPy, but that you might find useful to work with.\nTeNPy does not import the following libraries (at least not globally), but some functions might expect arguments\nbehaving like objects from these libraries.\n\n\n    If you created a [conda]_ environment with ``conda env create -f environment.yml``, all the extra requirements below\n    should already be installed :)\n    (However, a ``pip install -r requirements.txt`` does not install all of them.)\n\nMatplotlib\n^^^^^^^^^^\nThe first extra requirement is the [matplotlib]_ plotting library.\nSome functions expect a matplotlib.axes.Axes instance as argument to plot some data for visualization.\n\nIntel's Math Kernel Library (MKL)\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nIf you want to run larger simulations, we recommend the use of Intel's MKL.\nIt ships with a Lapack library, and uses optimization for Intel CPUs.\nMoreover, it uses parallelization of the LAPACK/BLAS routines, which makes execution much faster.\nAs of now, the library itself supports no other way of parallelization.\n\nIf you don't have a python version which is built against MKL,\nwe recommend using [conda]_ or directly `intelpython <https://software.intel.com/en-us/distribution-for-python/get-started>`_.\nConda has the advantage that it allows to use different environments for different projects.\nBoth are available for Linux, Mac and Windows; note that you don't even need administrator rights to install it on linux.\nSimply follow the (straight-forward) instructions of the web page for the installation.\nAfter a successful installation, if you run ``python`` interactively, the first output line should\nstate the python version and contain ``Anaconda`` or ``Intel Corporation``, respectively.\n\nIf you have a working conda package manager, you can install the numpy build against MKL with::\n\n    conda install mkl mkl-devel numpy scipy\n\nThe ``mkl-devel`` package is required for linking against MKL, i.e. for compiling the Cython code.\nAs outlined in :doc:`/install/conda`, on Linux/Mac you also need to pin blas to use MKL with the following line, **if you use the `conda-forge` channel**::\n\n    conda install \"libblas=*=*mkl\"\n\n\n    MKL uses different threads to parallelize various BLAS and LAPACK routines.\n    If you run the code on a cluster, make sure that you specify the number of used cores/threads correctly.\n    By default, MKL uses all the available CPUs, which might be in stark contrast than what you required from the\n    cluster. The easiest way to set the used threads is using the environment variable `MKL_NUM_THREADS` (or `OMP_NUM_THREADS`).\n    For a dynamic change of the used threads, you might want to look at tenpy.tools.process.\n\n\n\n\nCompile linking against MKL\n---------------------------\nWhen you compile the Cython files of TeNPy, you have the option to explicitly link against MKL, such\nthat e.g. tenpy.linalg.np_conserved.tensordot is guaranteed to call the corresponding `dgemm` or `zgemm`\nfunction in the BLAS from MKL.\nTo link against MKL, the MKL library *including the headers* must be available during the compilation of TeNPy's Cython\nfiles. If you have the MKL library installed, you can export the environment variable `MKLROOT` to point to the\nroot folder.\nAlternatively, TeNPy will recognize if you are in an active conda environment and have the `mkl` *and* `mkl-devel` conda\npackages installed during compilation. In this case, it will link against the MKL provided as conda package.\n\ntenpy.show_config indicates whether you linked successfully against MKL::\n\n    >>> import tenpy\n    >>> tenpy.show_config()\n    tenpy 0.7.2.dev130+76c5b7f (compiled with HAVE_MKL),\n    git revision 76c5b7fe46df3e2241d85c47cbced3400caad05a using\n    python 3.9.1 | packaged by conda-forge | (default, Jan 10 2021, 02:55:42)\n    [GCC 9.3.0]\n    numpy 1.19.5, scipy 1.6.0\n\n\nHDF5 file format support\n^^^^^^^^^^^^^^^^^^^^^^^^\nWe support exporting data to files in the [HDF5]_ format through the python interface of the\n`h5py <https://docs.h5py.org/en/stable/>`_ package, see :doc:`/intro/input_output` for more information.\nHowever, that requires the installation of the HDF5 library and h5py.\n\nYAML parameter files\n^^^^^^^^^^^^^^^^^^^^\nThe tenpy.tools.params.Config class supports reading and writing YAML files, which requires the package\n`pyyaml`; ``pip install pyyaml``.\n\nTests\n^^^^^\nTo run the tests, you need to install `pytest <http://pytest.org>`_, which you can for example do with ``pip install pytest``.\nFor information how to run the tests, see :doc:`/install/test`.",
    "search_text": "doc.extra --- documentation: extra ---\nextra requirements\n==================\n\nwe have some extra requirements that you don't need to install to use tenpy, but that you might find useful to work with.\ntenpy does not import the following libraries (at least not globally), but some functions might expect arguments\nbehaving like objects from these libraries.\n\n\n    if you created a [conda]_ environment with ``conda env create -f environment.yml``, all the extra requirements below\n    should already be installed :)\n    (however, a ``pip install -r requirements.txt`` does not install all of them.)\n\nmatplotlib\n^^^^^^^^^^\nthe first extra requirement is the [matplotlib]_ plotting library.\nsome functions expect a matplotlib.axes.axes instance as argument to plot some data for visualization.\n\nintel's math kernel library (mkl)\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nif you want to run larger simulations, we recommend the use of intel's mkl.\nit ships with a lapack library, and uses optimization for intel cpus.\nmoreover, it uses parallelization of the lapack/blas routines, which makes execution much faster.\nas of now, the library itself supports no other way of parallelization.\n\nif you don't have a python version which is built against mkl,\nwe recommend using [conda]_ or directly `intelpython <https://software.intel.com/en-us/distribution-for-python/get-started>`_.\nconda has the advantage that it allows to use different environments for different projects.\nboth are available for linux, mac and windows; note that you don't even need administrator rights to install it on linux.\nsimply follow the (straight-forward) instructions of the web page for the installation.\nafter a successful installation, if you run ``python`` interactively, the first output line should\nstate the python version and contain ``anaconda`` or ``intel corporation``, respectively.\n\nif you have a working conda package manager, you can install the numpy build against mkl with::\n\n    conda install mkl mkl-devel numpy scipy\n\nthe ``mkl-devel`` package is required for linking against mkl, i.e. for compiling the cython code.\nas outlined in :doc:`/install/conda`, on linux/mac you also need to pin blas to use mkl with the following line, **if you use the `conda-forge` channel**::\n\n    conda install \"libblas=*=*mkl\"\n\n\n    mkl uses different threads to parallelize various blas and lapack routines.\n    if you run the code on a cluster, make sure that you specify the number of used cores/threads correctly.\n    by default, mkl uses all the available cpus, which might be in stark contrast than what you required from the\n    cluster. the easiest way to set the used threads is using the environment variable `mkl_num_threads` (or `omp_num_threads`).\n    for a dynamic change of the used threads, you might want to look at tenpy.tools.process.\n\n\n\n\ncompile linking against mkl\n---------------------------\nwhen you compile the cython files of tenpy, you have the option to explicitly link against mkl, such\nthat e.g. tenpy.linalg.np_conserved.tensordot is guaranteed to call the corresponding `dgemm` or `zgemm`\nfunction in the blas from mkl.\nto link against mkl, the mkl library *including the headers* must be available during the compilation of tenpy's cython\nfiles. if you have the mkl library installed, you can export the environment variable `mklroot` to point to the\nroot folder.\nalternatively, tenpy will recognize if you are in an active conda environment and have the `mkl` *and* `mkl-devel` conda\npackages installed during compilation. in this case, it will link against the mkl provided as conda package.\n\ntenpy.show_config indicates whether you linked successfully against mkl::\n\n    >>> import tenpy\n    >>> tenpy.show_config()\n    tenpy 0.7.2.dev130+76c5b7f (compiled with have_mkl),\n    git revision 76c5b7fe46df3e2241d85c47cbced3400caad05a using\n    python 3.9.1 | packaged by conda-forge | (default, jan 10 2021, 02:55:42)\n    [gcc 9.3.0]\n    numpy 1.19.5, scipy 1.6.0\n\n\nhdf5 file format support\n^^^^^^^^^^^^^^^^^^^^^^^^\nwe support exporting data to files in the [hdf5]_ format through the python interface of the\n`h5py <https://docs.h5py.org/en/stable/>`_ package, see :doc:`/intro/input_output` for more information.\nhowever, that requires the installation of the hdf5 library and h5py.\n\nyaml parameter files\n^^^^^^^^^^^^^^^^^^^^\nthe tenpy.tools.params.config class supports reading and writing yaml files, which requires the package\n`pyyaml`; ``pip install pyyaml``.\n\ntests\n^^^^^\nto run the tests, you need to install `pytest <http://pytest.org>`_, which you can for example do with ``pip install pytest``.\nfor information how to run the tests, see :doc:`/install/test`. tutorial documentation extra",
    "tokens": 1128
  },
  {
    "category": "tutorials",
    "name": "doc.updating",
    "content": "--- DOCUMENTATION: updating ---\nUpdating to a new version\n=========================\n\n**Before** you update, take a look at the :doc:`/releases`, which lists the changes, fixes, and new stuff.\nMost importantly, it has a section on *backwards incompatible changes* (i.e., changes which may break your\nexisting code) along with information how to fix it. Of course, we try to avoid introducing such incompatible changes,\nbut sometimes, there's no way around them. If you skip some intermediate version(s) for the update, read also the release\nnotes of those!\n\nHow to update depends a little bit on the way you installed TeNPy.\nOf course, you have always the option to just remove the TeNPy files (possibly with a ``pip uninstall physics-tenpy`` or\n``conda uninstall physics-tenpy``),\nand to start over with downloading and installing the newest version.\n\nWhen installed with `conda`\n---------------------------\nWhen you installed TeNPy with [conda]_, you just need to activate the corresponding environment\n(e.g. ``conda activate tenpy``) and do a::\n\n    conda update physics-tenpy\n\nWhen installed with `pip`\n-------------------------\nWhen you installed TeNPy with [pip]_, you just need to do a::\n\n    pip install --upgrade physics-tenpy\n\nWhen installed from source\n--------------------------\n\nIf you used ``git clone ...`` to download the repository, you can update to the newest version using [git]_.\nFirst, briefly check that you didn't change anything you need to keep with ``git status``.\nThen, do a ``git pull`` to download (and possibly merge) the newest commit from the repository.\n\n\n\n    If some Cython file (ending in ``.pyx``) got renamed/removed (e.g., when updating from v0.3.0 to v0.4.0),\n    you first need to remove the corresponding binary files.\n    You can do so with the command ``bash cleanup.sh``.\n\n    Furthermore, whenever one of the cython files (ending in ``.pyx``) changed, you need to re-compile it.\n    To do that, simply call the command ``bash ./compile`` again.\n    If you are unsure whether a cython file changed, compiling again doesn't hurt.\n\nTo summarize, you need to execute the following bash commands in the repository::\n\n    # 0) make a backup of the whole folder\n    git status   # check the output whether you modified some files\n    git pull\n    bash ./cleanup.sh  # (confirm with 'y')\n    bash ./compile.sh",
    "search_text": "doc.updating --- documentation: updating ---\nupdating to a new version\n=========================\n\n**before** you update, take a look at the :doc:`/releases`, which lists the changes, fixes, and new stuff.\nmost importantly, it has a section on *backwards incompatible changes* (i.e., changes which may break your\nexisting code) along with information how to fix it. of course, we try to avoid introducing such incompatible changes,\nbut sometimes, there's no way around them. if you skip some intermediate version(s) for the update, read also the release\nnotes of those!\n\nhow to update depends a little bit on the way you installed tenpy.\nof course, you have always the option to just remove the tenpy files (possibly with a ``pip uninstall physics-tenpy`` or\n``conda uninstall physics-tenpy``),\nand to start over with downloading and installing the newest version.\n\nwhen installed with `conda`\n---------------------------\nwhen you installed tenpy with [conda]_, you just need to activate the corresponding environment\n(e.g. ``conda activate tenpy``) and do a::\n\n    conda update physics-tenpy\n\nwhen installed with `pip`\n-------------------------\nwhen you installed tenpy with [pip]_, you just need to do a::\n\n    pip install --upgrade physics-tenpy\n\nwhen installed from source\n--------------------------\n\nif you used ``git clone ...`` to download the repository, you can update to the newest version using [git]_.\nfirst, briefly check that you didn't change anything you need to keep with ``git status``.\nthen, do a ``git pull`` to download (and possibly merge) the newest commit from the repository.\n\n\n\n    if some cython file (ending in ``.pyx``) got renamed/removed (e.g., when updating from v0.3.0 to v0.4.0),\n    you first need to remove the corresponding binary files.\n    you can do so with the command ``bash cleanup.sh``.\n\n    furthermore, whenever one of the cython files (ending in ``.pyx``) changed, you need to re-compile it.\n    to do that, simply call the command ``bash ./compile`` again.\n    if you are unsure whether a cython file changed, compiling again doesn't hurt.\n\nto summarize, you need to execute the following bash commands in the repository::\n\n    # 0) make a backup of the whole folder\n    git status   # check the output whether you modified some files\n    git pull\n    bash ./cleanup.sh  # (confirm with 'y')\n    bash ./compile.sh tutorial documentation updating",
    "tokens": 541
  },
  {
    "category": "tutorials",
    "name": "doc.test",
    "content": "--- DOCUMENTATION: test ---\nChecking the installation\n^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe first check of whether tenpy is installed successfully, is to try to import it from within python::\n\n    >>> import tenpy\n\n\n    If this raises a warning ``Couldn't load compiled cython code. Code will run a bit slower.``, something went wrong with\n    the compilation of the Cython parts (or you didn't compile at all).\n    While the code might run slower, the results should still be the same.\n\nThe function tenpy.show_config prints information about the used versions of tenpy, numpy and\nscipy, as well on the fact whether the Cython parts were compiled and could be imported.\n\nAs a further check of the installation you can try to run (one of) the python files in the `examples/` subfolder;\nhopefully all of them should run without error.\n\nYou can also run the automated testsuite with `pytest <http://pytest.org>`_ to make sure everything works fine.\nIf you have ``pytest`` installed, you can go to the `tests` folder of the repository, and run the tests with::\n\n    cd tests\n    pytest\n\nIn case of errors or failures it gives a detailed traceback and possibly some output of the test.\nAt least the stable releases should run these tests without any failures.\n\nIf you can run the examples but not the tests, check whether `pytest` actually uses the correct python version.\n\nThe test suite is also run automatically by `github actions <https://github.com/tenpy/tenpy/actions>`_ and with `travis-ci <https://travis-ci.org>`_, results can be inspected `here <https://travis-ci.org/tenpy/tenpy>`_.",
    "search_text": "doc.test --- documentation: test ---\nchecking the installation\n^^^^^^^^^^^^^^^^^^^^^^^^^\n\nthe first check of whether tenpy is installed successfully, is to try to import it from within python::\n\n    >>> import tenpy\n\n\n    if this raises a warning ``couldn't load compiled cython code. code will run a bit slower.``, something went wrong with\n    the compilation of the cython parts (or you didn't compile at all).\n    while the code might run slower, the results should still be the same.\n\nthe function tenpy.show_config prints information about the used versions of tenpy, numpy and\nscipy, as well on the fact whether the cython parts were compiled and could be imported.\n\nas a further check of the installation you can try to run (one of) the python files in the `examples/` subfolder;\nhopefully all of them should run without error.\n\nyou can also run the automated testsuite with `pytest <http://pytest.org>`_ to make sure everything works fine.\nif you have ``pytest`` installed, you can go to the `tests` folder of the repository, and run the tests with::\n\n    cd tests\n    pytest\n\nin case of errors or failures it gives a detailed traceback and possibly some output of the test.\nat least the stable releases should run these tests without any failures.\n\nif you can run the examples but not the tests, check whether `pytest` actually uses the correct python version.\n\nthe test suite is also run automatically by `github actions <https://github.com/tenpy/tenpy/actions>`_ and with `travis-ci <https://travis-ci.org>`_, results can be inspected `here <https://travis-ci.org/tenpy/tenpy>`_. tutorial documentation test",
    "tokens": 357
  },
  {
    "category": "tutorials",
    "name": "doc.conda",
    "content": "--- DOCUMENTATION: conda ---\nInstallation with conda from conda-forge\n========================================\n\nWe provide a package for the [conda]_ package manager in the `conda-forge` channel, so you can install TeNPy as::\n\n    conda install --channel=conda-forge physics-tenpy\n\n\nFollowing the recommendation of `conda-forge <https://conda-forge.org/docs/user/introduction.html>`_, you can also make\nconda-forge the default channel as follows::\n\n    conda config --add channels conda-forge\n    conda config --set channel_priority strict\n\nIf you have done this, you don't need to specify the ``--channel=conda-forge`` explicitly.\n\n\n    The `numpy` package provided by the `conda-forge` channel by default uses openblas on linux.\n    As outlined in the `conda forge docs <https://conda-forge.org/docs/maintainer/knowledge_base.html#switching-blas-implementation>`_,\n    you can switch to MKL using::\n\n        conda install \"libblas=*=*mkl\"\n\n\n    If you use the `conda-forge` channel and don't pin BLAS to the MKL version as outlined in the above version,\n    but nevertheless have mkl-devel installed during compilation of TeNPy, this can have *crazy* effects on the number\n    of threads used: `numpy` will call openblas and open up ``$OMP_NUM_THREADS - 1`` new threads,\n    while MKL called from tenpy will open another ``$MKL_NUM_THREADS - 1`` threads, making it very hard to control the\n    number of threads used!\n\nMoreover, it is actually recommended to create a separate environment.\nTo create a conda environment with the name `tenpy`, where the TeNPy package (called `physics-tenpy`) is installed::\n\n    conda create --name tenpy --channel=conda-forge physics-tenpy\n\nIn that case, you need to activate the environment each time you want to use the package with::\n\n    conda activate tenpy\n\nThe big advantage of this approach is that it allows multiple version of software to be installed in parallel,\ne.g., if one of your projects requires python>=3.8 and another one requires an old library which doesn't support that.\nFurther info can be found in the `conda documentation <https://docs.conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html>`_.",
    "search_text": "doc.conda --- documentation: conda ---\ninstallation with conda from conda-forge\n========================================\n\nwe provide a package for the [conda]_ package manager in the `conda-forge` channel, so you can install tenpy as::\n\n    conda install --channel=conda-forge physics-tenpy\n\n\nfollowing the recommendation of `conda-forge <https://conda-forge.org/docs/user/introduction.html>`_, you can also make\nconda-forge the default channel as follows::\n\n    conda config --add channels conda-forge\n    conda config --set channel_priority strict\n\nif you have done this, you don't need to specify the ``--channel=conda-forge`` explicitly.\n\n\n    the `numpy` package provided by the `conda-forge` channel by default uses openblas on linux.\n    as outlined in the `conda forge docs <https://conda-forge.org/docs/maintainer/knowledge_base.html#switching-blas-implementation>`_,\n    you can switch to mkl using::\n\n        conda install \"libblas=*=*mkl\"\n\n\n    if you use the `conda-forge` channel and don't pin blas to the mkl version as outlined in the above version,\n    but nevertheless have mkl-devel installed during compilation of tenpy, this can have *crazy* effects on the number\n    of threads used: `numpy` will call openblas and open up ``$omp_num_threads - 1`` new threads,\n    while mkl called from tenpy will open another ``$mkl_num_threads - 1`` threads, making it very hard to control the\n    number of threads used!\n\nmoreover, it is actually recommended to create a separate environment.\nto create a conda environment with the name `tenpy`, where the tenpy package (called `physics-tenpy`) is installed::\n\n    conda create --name tenpy --channel=conda-forge physics-tenpy\n\nin that case, you need to activate the environment each time you want to use the package with::\n\n    conda activate tenpy\n\nthe big advantage of this approach is that it allows multiple version of software to be installed in parallel,\ne.g., if one of your projects requires python>=3.8 and another one requires an old library which doesn't support that.\nfurther info can be found in the `conda documentation <https://docs.conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html>`_. tutorial documentation conda",
    "tokens": 510
  },
  {
    "category": "tutorials",
    "name": "doc.from_source",
    "content": "--- DOCUMENTATION: from_source ---\nInstallation from source\n------------------------\n\nMinimal Requirements\n^^^^^^^^^^^^^^^^^^^^\nThis code works with a minimal requirement of pure Python>=3.6\nand somewhat recent versions of `NumPy <https://www.numpy.org>`_ and `SciPy <https://www.scipy.org>`_.\n\nGetting the source\n^^^^^^^^^^^^^^^^^^\n\nThe following instructions are for (some kind of) Linux, and tested on Ubuntu.\nHowever, the code itself should work on other operating systems as well (in particular MacOS and Windows).\n\nThe official repository is at https://github.com/tenpy/tenpy.git.\nTo get the latest version of the code, you can clone it with [git]_ using the following commands::\n\n    git clone https://github.com/tenpy/tenpy.git $HOME/TeNPy\n    cd $HOME/TeNPy\n\n\n    Adjust ``$HOME/TeNPy`` to the path wherever you want to save the library.\n\nOptionally, if you don't want to contribute, you can checkout the latest stable release::\n\n    git tag   # this prints the available version tags\n    git checkout v0.3.0  # or whatever is the latest stable version\n\n\n    In case you don't have [git]_ installed, you can download the repository as a ZIP archive.\n    You can find it under `releases <https://github.com/tenpy/tenpy/releases>`_,\n    or the `latest development version <https://github.com/tenpy/tenpy/archive/main.zip>`_.\n\n\nMinimal installation: Including tenpy into PYTHONPATH\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nThe python source is in the directory `tenpy/` of the repository.\nThis folder `tenpy/` should be placed in (one of the folders of) the environment variable\n`PYTHONPATH <https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH>`_.\nOn Linux, you can simply do this with the following line in the terminal::\n\n    export PYTHONPATH=$HOME/TeNPy\n\n(If you have already a path in this variable, separate the paths with a colon ``:``.)\nHowever, if you enter this in the terminal, it will only be temporary for the terminal session where you entered it.\nTo make it permanently, you can add the above line to the file ``$HOME/.bashrc``.\nYou might need to restart the terminal session or need to re-login to force a reload of the ``~/.bashrc``.\n\nWhenever the path is set, you should be able to use the library from within python::\n\n    >>> import tenpy\n    /home/johannes/postdoc/2021-01-TenPy-with-MKL/TeNPy/tenpy/tools/optimization.py:308: UserWarning: Couldn't load compiled cython code. Code will run a bit slower.\n    warnings.warn(\"Couldn't load compiled cython code. Code will run a bit slower.\")\n    >>> tenpy.show_config()\n    tenpy 0.7.2.dev130+76c5b7f (not compiled),\n    git revision 76c5b7fe46df3e2241d85c47cbced3400caad05a using\n    python 3.9.1 | packaged by conda-forge | (default, Jan 10 2021, 02:55:42)\n    [GCC 9.3.0]\n    numpy 1.19.5, scipy 1.6.0\n\n\ntenpy.show_config prints the current version of the used TeNPy library as well as the versions of the used python, numpy and scipy libraries,\nwhich might be different on your computer. It is a good idea to save this data (given as string in ``tenpy.version.version_summary`` along with your data to allow to reproduce your results exactly.\n\nIf you got a similar output as above: congratulations! You can now run the codes :)\n\n\nCompilation of np_conserved\n^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAt the heart of the TeNPy library is the module tenpy.linalg.np_conserved, which provides an Array class to exploit the\nconservation of abelian charges. The data model of python is not ideal for the required book-keeping, thus\nwe have implemented the same np_conserved module in `Cython <https://cython.org>`_.\nThis allows to compile (and thereby optimize) the corresponding python module, thereby speeding up the execution of the\ncode. While this might give a significant speed-up for code with small matrix dimensions, don't expect the same speed-up in\ncases where most of the CPU-time is already spent in matrix multiplications (i.e. if the bond dimension of your MPS is huge).\n\nTo compile the code, you first need to install `Cython <https://cython.org>`_ ::\n\n    conda install cython                    # when using anaconda, or\n    pip install --upgrade Cython            # when using pip\n\nMoreover, you need a C++ compiler.\nFor example, on Ubuntu you can install ``sudo apt-get install build_essential``,\nor on Windows you can download MS Visual Studio 2015.\nIf you use anaconda, you can also use ``conda install -c conda-forge cxx-compiler``.\n\nAfter that, go to the root directory of TeNPy (``$HOME/TeNPy``) and simply run ::\n\n    bash ./compile.sh\n\n\n   There is no need to compile if you installed TeNPy directly with conda or pip.\n   (You can verify this with `tenpy.show_config()` as illustrated below.)\n\nNote that it is not required to separately download (and install) Intel MKL: the compilation just obtains the includes\nfrom numpy. In other words, if your current numpy version uses MKL (as the one provided by anaconda),\nthe compiled TeNPy code will also use it.\n\nAfter a successful compilation, the warning that TeNPy was not compiled should go away::\n\n    >>> import tenpy\n    >>> tenpy.show_config()\n    tenpy 0.7.2.dev130+76c5b7f (compiled without HAVE_MKL),\n    git revision 76c5b7fe46df3e2241d85c47cbced3400caad05a using\n    python 3.9.1 | packaged by conda-forge | (default, Jan 10 2021, 02:55:42)\n    [GCC 9.3.0]\n    numpy 1.19.5, scipy 1.6.0\n\n\n    For further optimization options, e.g. how to link against MKL, look at :doc:`/install/extra` and tenpy.tools.optimization.\n\n\nQuick-setup of a development environment with conda\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nYou can use the following bash commands to setup a new conda environment called `tenpy_dev` (call it whatever you\nwant!) and install TeNPy in there in a way which allows editing TeNPy's python code and still have it available everywhere in the conda environment::\n\n    git clone https://github.com/tenpy/tenpy TeNPy\n    cd TeNPy\n    conda env create -f environment.yml -n tenpy_dev\n    conda activate tenpy_dev\n    pip install -e .",
    "search_text": "doc.from_source --- documentation: from_source ---\ninstallation from source\n------------------------\n\nminimal requirements\n^^^^^^^^^^^^^^^^^^^^\nthis code works with a minimal requirement of pure python>=3.6\nand somewhat recent versions of `numpy <https://www.numpy.org>`_ and `scipy <https://www.scipy.org>`_.\n\ngetting the source\n^^^^^^^^^^^^^^^^^^\n\nthe following instructions are for (some kind of) linux, and tested on ubuntu.\nhowever, the code itself should work on other operating systems as well (in particular macos and windows).\n\nthe official repository is at https://github.com/tenpy/tenpy.git.\nto get the latest version of the code, you can clone it with [git]_ using the following commands::\n\n    git clone https://github.com/tenpy/tenpy.git $home/tenpy\n    cd $home/tenpy\n\n\n    adjust ``$home/tenpy`` to the path wherever you want to save the library.\n\noptionally, if you don't want to contribute, you can checkout the latest stable release::\n\n    git tag   # this prints the available version tags\n    git checkout v0.3.0  # or whatever is the latest stable version\n\n\n    in case you don't have [git]_ installed, you can download the repository as a zip archive.\n    you can find it under `releases <https://github.com/tenpy/tenpy/releases>`_,\n    or the `latest development version <https://github.com/tenpy/tenpy/archive/main.zip>`_.\n\n\nminimal installation: including tenpy into pythonpath\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nthe python source is in the directory `tenpy/` of the repository.\nthis folder `tenpy/` should be placed in (one of the folders of) the environment variable\n`pythonpath <https://docs.python.org/3/using/cmdline.html#envvar-pythonpath>`_.\non linux, you can simply do this with the following line in the terminal::\n\n    export pythonpath=$home/tenpy\n\n(if you have already a path in this variable, separate the paths with a colon ``:``.)\nhowever, if you enter this in the terminal, it will only be temporary for the terminal session where you entered it.\nto make it permanently, you can add the above line to the file ``$home/.bashrc``.\nyou might need to restart the terminal session or need to re-login to force a reload of the ``~/.bashrc``.\n\nwhenever the path is set, you should be able to use the library from within python::\n\n    >>> import tenpy\n    /home/johannes/postdoc/2021-01-tenpy-with-mkl/tenpy/tenpy/tools/optimization.py:308: userwarning: couldn't load compiled cython code. code will run a bit slower.\n    warnings.warn(\"couldn't load compiled cython code. code will run a bit slower.\")\n    >>> tenpy.show_config()\n    tenpy 0.7.2.dev130+76c5b7f (not compiled),\n    git revision 76c5b7fe46df3e2241d85c47cbced3400caad05a using\n    python 3.9.1 | packaged by conda-forge | (default, jan 10 2021, 02:55:42)\n    [gcc 9.3.0]\n    numpy 1.19.5, scipy 1.6.0\n\n\ntenpy.show_config prints the current version of the used tenpy library as well as the versions of the used python, numpy and scipy libraries,\nwhich might be different on your computer. it is a good idea to save this data (given as string in ``tenpy.version.version_summary`` along with your data to allow to reproduce your results exactly.\n\nif you got a similar output as above: congratulations! you can now run the codes :)\n\n\ncompilation of np_conserved\n^^^^^^^^^^^^^^^^^^^^^^^^^^^\nat the heart of the tenpy library is the module tenpy.linalg.np_conserved, which provides an array class to exploit the\nconservation of abelian charges. the data model of python is not ideal for the required book-keeping, thus\nwe have implemented the same np_conserved module in `cython <https://cython.org>`_.\nthis allows to compile (and thereby optimize) the corresponding python module, thereby speeding up the execution of the\ncode. while this might give a significant speed-up for code with small matrix dimensions, don't expect the same speed-up in\ncases where most of the cpu-time is already spent in matrix multiplications (i.e. if the bond dimension of your mps is huge).\n\nto compile the code, you first need to install `cython <https://cython.org>`_ ::\n\n    conda install cython                    # when using anaconda, or\n    pip install --upgrade cython            # when using pip\n\nmoreover, you need a c++ compiler.\nfor example, on ubuntu you can install ``sudo apt-get install build_essential``,\nor on windows you can download ms visual studio 2015.\nif you use anaconda, you can also use ``conda install -c conda-forge cxx-compiler``.\n\nafter that, go to the root directory of tenpy (``$home/tenpy``) and simply run ::\n\n    bash ./compile.sh\n\n\n   there is no need to compile if you installed tenpy directly with conda or pip.\n   (you can verify this with `tenpy.show_config()` as illustrated below.)\n\nnote that it is not required to separately download (and install) intel mkl: the compilation just obtains the includes\nfrom numpy. in other words, if your current numpy version uses mkl (as the one provided by anaconda),\nthe compiled tenpy code will also use it.\n\nafter a successful compilation, the warning that tenpy was not compiled should go away::\n\n    >>> import tenpy\n    >>> tenpy.show_config()\n    tenpy 0.7.2.dev130+76c5b7f (compiled without have_mkl),\n    git revision 76c5b7fe46df3e2241d85c47cbced3400caad05a using\n    python 3.9.1 | packaged by conda-forge | (default, jan 10 2021, 02:55:42)\n    [gcc 9.3.0]\n    numpy 1.19.5, scipy 1.6.0\n\n\n    for further optimization options, e.g. how to link against mkl, look at :doc:`/install/extra` and tenpy.tools.optimization.\n\n\nquick-setup of a development environment with conda\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nyou can use the following bash commands to setup a new conda environment called `tenpy_dev` (call it whatever you\nwant!) and install tenpy in there in a way which allows editing tenpy's python code and still have it available everywhere in the conda environment::\n\n    git clone https://github.com/tenpy/tenpy tenpy\n    cd tenpy\n    conda env create -f environment.yml -n tenpy_dev\n    conda activate tenpy_dev\n    pip install -e . tutorial documentation from_source",
    "tokens": 1564
  },
  {
    "category": "tutorials",
    "name": "doc.pip",
    "content": "--- DOCUMENTATION: pip ---\nInstallation from PyPi with pip\n===============================\n\nPreparation: install requirements\n---------------------------------\n\nIf you have the [conda]_ package manager from `anaconda <https://www.anaconda.com/distribution>`_, you can just download the\n`environment.yml <https://raw.githubusercontent.com/tenpy/tenpy/main/environment.yml>`_ file (using the `conda-forge`\nchannel, or the `environment_other.yml <https://raw.githubusercontent.com/tenpy/tenpy/main/environment_other.yml>`_ for all other channels) out of the repository\nand create a new environment (called ``tenpy``, if you don't specify another name) for TeNPy with all the required packages::\n\n    conda env create -f environment.yml\n    conda activate tenpy\n\nFurther information on conda environments can be found in the `conda documentation <https://docs.conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html>`_. Note that installing conda also installs a version of [pip]_.\n\nAlternatively, if you only have [pip]_ (and not [conda]_), install the\nrequired packages with the following command (after downloading the\n`requirements.txt <https://raw.githubusercontent.com/tenpy/tenpy/main/requirements.txt>`_ file from the repository)::\n\n    pip install -r requirements.txt\n\n\n    Make sure that the ``pip`` you call corresponds to the python version you want to use.\n    (One way to ensure this is to use ``python -m pip`` instead of a simple ``pip``.)\n    Also, you might need to use the argument ``--user`` to install the packages to your home directory,\n    if you don't have ``sudo`` rights. (Using ``--user`` with conda's ``pip`` is discouraged, though.)\n\n\n    It might just be a temporary problem, but I found that the `pip` version of numpy is incompatible with\n    the python distribution of anaconda.\n    If you have installed the intelpython or anaconda distribution, use the `conda` package manager instead of `pip` for updating the packages whenever possible!\n\nInstalling the latest stable TeNPy package\n------------------------------------------\n\nNow we are ready to install TeNPy. It should be as easy as (note the different package name - 'tenpy' was taken!) ::\n\n    pip install physics-tenpy\n\n\n    If the installation fails, don't give up yet. In the minimal version, tenpy requires only pure Python with\n    somewhat up-to-date NumPy and SciPy. See from_source.\n\nInstallation of the latest version from Github\n----------------------------------------------\n\nTo get the latest development version from the github main branch, you can use::\n\n    pip install git+git://github.com/tenpy/tenpy.git\n\nThis should already have the latest features described in :doc:`/changelog/_latest`.\nDisclaimer: this might sometimes be broken, although we do our best to keep to keep it stable as well.\n\nInstallation from the downloaded source folder\n----------------------------------------------\n\nFinally, if you downloaded the source and want to **modify parts of the source**,\nYou can also install TeNPy with in\ndevelopment version with ``--editable``::\n\n    cd $HOME/tenpy # after downloading the source, got to the repository\n    pip install --editable .\n\nUninstalling a pip-installed version\n------------------------------------\n\nIn all of the above cases, you can uninstall tenpy with::\n\n    pip uninstall physics-tenpy",
    "search_text": "doc.pip --- documentation: pip ---\ninstallation from pypi with pip\n===============================\n\npreparation: install requirements\n---------------------------------\n\nif you have the [conda]_ package manager from `anaconda <https://www.anaconda.com/distribution>`_, you can just download the\n`environment.yml <https://raw.githubusercontent.com/tenpy/tenpy/main/environment.yml>`_ file (using the `conda-forge`\nchannel, or the `environment_other.yml <https://raw.githubusercontent.com/tenpy/tenpy/main/environment_other.yml>`_ for all other channels) out of the repository\nand create a new environment (called ``tenpy``, if you don't specify another name) for tenpy with all the required packages::\n\n    conda env create -f environment.yml\n    conda activate tenpy\n\nfurther information on conda environments can be found in the `conda documentation <https://docs.conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html>`_. note that installing conda also installs a version of [pip]_.\n\nalternatively, if you only have [pip]_ (and not [conda]_), install the\nrequired packages with the following command (after downloading the\n`requirements.txt <https://raw.githubusercontent.com/tenpy/tenpy/main/requirements.txt>`_ file from the repository)::\n\n    pip install -r requirements.txt\n\n\n    make sure that the ``pip`` you call corresponds to the python version you want to use.\n    (one way to ensure this is to use ``python -m pip`` instead of a simple ``pip``.)\n    also, you might need to use the argument ``--user`` to install the packages to your home directory,\n    if you don't have ``sudo`` rights. (using ``--user`` with conda's ``pip`` is discouraged, though.)\n\n\n    it might just be a temporary problem, but i found that the `pip` version of numpy is incompatible with\n    the python distribution of anaconda.\n    if you have installed the intelpython or anaconda distribution, use the `conda` package manager instead of `pip` for updating the packages whenever possible!\n\ninstalling the latest stable tenpy package\n------------------------------------------\n\nnow we are ready to install tenpy. it should be as easy as (note the different package name - 'tenpy' was taken!) ::\n\n    pip install physics-tenpy\n\n\n    if the installation fails, don't give up yet. in the minimal version, tenpy requires only pure python with\n    somewhat up-to-date numpy and scipy. see from_source.\n\ninstallation of the latest version from github\n----------------------------------------------\n\nto get the latest development version from the github main branch, you can use::\n\n    pip install git+git://github.com/tenpy/tenpy.git\n\nthis should already have the latest features described in :doc:`/changelog/_latest`.\ndisclaimer: this might sometimes be broken, although we do our best to keep to keep it stable as well.\n\ninstallation from the downloaded source folder\n----------------------------------------------\n\nfinally, if you downloaded the source and want to **modify parts of the source**,\nyou can also install tenpy with in\ndevelopment version with ``--editable``::\n\n    cd $home/tenpy # after downloading the source, got to the repository\n    pip install --editable .\n\nuninstalling a pip-installed version\n------------------------------------\n\nin all of the above cases, you can uninstall tenpy with::\n\n    pip uninstall physics-tenpy tutorial documentation pip",
    "tokens": 722
  }
]