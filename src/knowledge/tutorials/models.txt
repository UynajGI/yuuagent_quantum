

--- DOC: model_details ---
Details on the implementation of Models
=======================================

In this chapter, we provide some more detail on how models work, and how you might customize them.
You should probably read :doc:`/intro/model` first.

We distinguish three different ways in which the Hamiltonian can be given, and there is a
base class for each one of them:

1. In a tenpy.models.model.NearestNeighborModel, we have the Hamiltonian as a sum of
   two-body terms, which are stored explicitly as a list
   of tenpy.linalg.np_conserved.Array\s.
   This is the structure you need to do TEBD with the model.
2. In a tenpy.models.model.MPOModel, we have the Hamiltonian directly given as a
   tenpy.networks.mpo.MPO.
   This is the structure you need to do DMRG, ExpMPOEvolution or TDVP.
3. In a tenpy.models.model.CouplingModel, the Hamiltonian is given symbolically, in
   the form of terms (see tenpy.networks.terms).
   There are (currently) no algorithms in TeNPy that require this particular structure.
   We can view it more as a convenient way to specify models, which also allows us to
   initialize the other two structures easily.

A custom model (as well as the pre-defined models in TeNPy) should then inherit from all of the
classes that are applicable.

If you define a tenpy.models.model.CouplingModel structure for the model, that class
offers convenient methods to initialize the other two structures, as shown in more detail below.
There is a convenience class that achieves this directly, the tenpy.models.model.CouplingMPOModel.
It uses the same symbolical representation of the Hamiltonian, but in contrast to the
plain tenpy.models.model.CouplingModel, automates the initialization of the lattice and
of the MPO. It also automatically initializes ``H_bond``, if it detects that the custom model
is also a subclass of tenpy.models.model.NearestNeighborModel.
This means that there is virtually no explicit code needed, e.g. when the
tenpy.models.tf_ising.TFIModel is specialized to the tenpy.models.tf_ising.TFIChain.

In the rest of this intro, we introduce the classes and their ways of initializing models in more detail.


The CouplingModel: general structure
------------------------------------

The tenpy.models.model.CouplingModel provides a general, quite abstract way to specify a Hamiltonian
of couplings on a given lattice.
Once initialized, its methods tenpy.models.CouplingModel.add_onsite and
tenpy.models.model.CouplingModel.add_coupling allow to add onsite and coupling terms repeated over the different
unit cells of the lattice.
In that way, it basically allows a straight-forward translation of the Hamiltonian given as a math formula
:math:`H = \sum_{i} A_i B_{i+dx} + ...` with onsite operators `A`, `B`,... into a model class.

The general structure for a new model based on the tenpy.models.model.CouplingModel is then::

    class MyNewModel3(CouplingModel,MPOModel,NearestNeighborModel):
        def __init__(self, ...):
            ...  # follow the basic steps explained below


In the initialization method ``__init__(self, ...)`` of this class you can then follow these basic steps:

0. Read out the parameters.
1. Given the parameters, determine the charges to be conserved.
   Initialize the tenpy.linalg.charges.LegCharge of the local sites accordingly.
2. Define (additional) local operators needed.
3. Initialize the needed tenpy.networks.site.Site.


      Using pre-defined sites like the tenpy.networks.site.SpinHalfSite is recommended and
      can replace steps 1-3.

4. Initialize the lattice (or if you got the lattice as a parameter, set the sites in the unit cell).
5. Initialize the tenpy.models.model.CouplingModel with ``CouplingModel.__init__(self, lat)``.
6. Use tenpy.models.model.CouplingModel.add_onsite and tenpy.models.model.CouplingModel.add_coupling
   to add all terms of the Hamiltonian. Here, the tenpy.models.lattice.Lattice.pairs of the lattice
   can come in handy, for example::

       self.add_onsite(-np.asarray(h), 0, 'Sz')
       for u1, u2, dx in self.lat.pairs['nearest_neighbors']:
           self.add_coupling(0.5*J, u1, 'Sp', u2, 'Sm', dx, plus_hc=True)
           self.add_coupling(    J, u1, 'Sz', u2, 'Sz', dx)


      The method tenpy.models.model.CouplingModel.add_coupling adds the coupling only in one direction, i.e.
      not switching `i` and `j` in a :math:`\sum_{\langle i, j\rangle}`.
      If you have terms like :math:`c^\dagger_i c_j` or :math:`S^{+}_i S^{-}_j` in your Hamiltonian,
      you *need* to add it in both directions to get a Hermitian Hamiltonian!
      The easiest way to do that is to use the `plus_hc` option of
      tenpy.models.model.CouplingModel.add_onsite and tenpy.models.model.CouplingModel.add_coupling,
      as we did for the :math:`J/2 (S^{+}_i S^{-}_j + h.c.)` terms of the Heisenberg model above.
      Alternatively, you can add the hermitian conjugate terms explicitly, see the examples in
      tenpy.models.model.CouplingModel.add_coupling for more details.

   Note that the `strength` arguments of these functions can be (numpy) arrays for site-dependent couplings.
   If you need to add or multiply some parameters of the model for the `strength` of certain terms,
   it is recommended use ``np.asarray`` beforehand -- in that way lists will also work fine.
7. Finally, if you derived from the tenpy.models.model.MPOModel, you can call
   tenpy.models.model.CouplingModel.calc_H_MPO to build the MPO and use it for the initialization
   as ``MPOModel.__init__(self, lat, self.calc_H_MPO())``.
8. Similarly, if you derived from the tenpy.models.model.NearestNeighborModel, you can call
   tenpy.models.model.CouplingModel.calc_H_bond to initialize it
   as ``NearestNeighborModel.__init__(self, lat, self.calc_H_bond())``.
   Calling ``self.calc_H_bond()`` will fail for models which are not nearest-neighbors (with respect to the MPS ordering),
   so you should only subclass the tenpy.models.model.NearestNeighborModel if the lattice is a simple
   tenpy.models.lattice.Chain.


    The method tenpy.models.model.CouplingModel.add_coupling works only for terms involving operators on 2
    sites. If you have couplings involving more than two sites, you can use the
    tenpy.models.model.CouplingModel.add_multi_coupling instead.
    A prototypical example is the exactly solvable tenpy.models.toric_code.ToricCode.


The code of the module tenpy.models.xxz_chain is included below as an illustrative example how to implement a
Model. The implementation of the tenpy.models.xxz_chain.XXZChain directly follows the steps
outline above.
The tenpy.models.xxz_chain.XXZChain2 implements the very same model, but based on the
tenpy.models.model.CouplingMPOModel explained in the next section.



The easiest way: the CouplingMPOModel
-------------------------------------
Since many of the basic steps above are always the same, we don't need to repeat them all the time.
So we have yet another class helping to structure the initialization of models: the tenpy.models.model.CouplingMPOModel.
The general structure of this class is like this::

    class CouplingMPOModel(CouplingModel,MPOModel):
        default_lattice = "Chain"
        "

        def __init__(self, model_param):
            # ... follows the basic steps 1-8 using the methods
            lat = self.init_lattice(self, model_param)  # for step 4
            # ...
            self.init_terms(self, model_param) # for step 6
            # ...

        def init_sites(self, model_param):
            # You should overwrite this in most cases to ensure
            # getting the site(s) and charge conservation you want
            site = SpinSite(...)  # or FermionSite, BosonSite, ...
            return site  # (or tuple of sites)

        def init_lattice(self, model_param):
            sites = self.init_sites(self, model_param) # for steps 1-3
            # and then read out the class attribute `default_lattice`,
            # initialize an arbitrary pre-defined lattice
            # using model_params['lattice']
            # and ensure it's the default lattice if the class attribute
            # `force_default_lattice` is True.

        def init_terms(self, model_param):
            # does nothing.
            # You should overwrite this

The tenpy.models.xxz_chain.XXZChain2 included above illustrates, how it can be used.
You need to implement steps 1-3) by overwriting the method tenpy.models.model.CouplingMPOModel.init_sites
Step 4) is performed in the method tenpy.models.model.CouplingMPOModel.init_lattice, which initializes arbitrary 1D or 2D
lattices; by default a simple 1D chain.
If your model only works for specific lattices, you can overwrite this method in your own class.
Step 6) should be done by overwriting the method tenpy.models.model.CouplingMPOModel.init_terms.
Steps 5,7,8 and calls to the `init_...` methods for the other steps are done automatically if you just call the
``CouplingMPOModel.__init__(self, model_param)``.

The tenpy.models.xxz_chain.XXZChain and tenpy.models.xxz_chain.XXZChain2 work only with the
tenpy.models.lattice.Chain as lattice, since they are derived from the tenpy.models.model.NearestNeighborModel.
This allows to use them for TEBD in 1D (yeah!), but we can't get the MPO for DMRG on (for example) a tenpy.models.lattice.Square
lattice cylinder - although it's intuitively clear, what the Hamiltonian there should be: just put the nearest-neighbor
coupling on each bond of the 2D lattice.

It's not possible to generalize a tenpy.models.model.NearestNeighborModel to an arbitrary lattice where it's
no longer nearest Neighbors in the MPS sense, but we can go the other way around:
first write the model on an arbitrary 2D lattice and then restrict it to a 1D chain to make it a tenpy.models.model.NearestNeighborModel.

Let me illustrate this with another standard example model: the transverse field Ising model, implemented in the module
tenpy.models.tf_ising included below.
The tenpy.models.tf_ising.TFIModel works for arbitrary 1D or 2D lattices.
The tenpy.models.tf_ising.TFIChain is then taking the exact same model making a tenpy.models.model.NearestNeighborModel,
which only works for the 1D chain.



Automation of Hermitian conjugation
-----------------------------------
As most physical Hamiltonians are Hermitian, these Hamiltonians are fully determined when only half of the mutually conjugate terms is defined. For example, a simple Hamiltonian:

        H = \sum_{\langle i,j\rangle, i<j}
              - \mathtt{J} (c^{\dagger}_i c_j + c^{\dagger}_j c_i)

is fully determined by the term :math:`c^{\dagger}_i c_j` if we demand that Hermitian conjugates are included automatically.
In TeNPy, whenever you add a coupling using tenpy.models.model.CouplingModel.add_onsite,
tenpy.models.model.CouplingModel.add_coupling, or tenpy.models.model.CouplingModel.add_multi_coupling,
you can use the optional argument `plus_hc` to automatically create and add the Hermitian conjugate of that coupling term - as shown above.

Additionally, in an MPO, explicitly adding both a non-Hermitian term and its conjugate increases the bond dimension of the MPO, which increases the memory requirements of the tenpy.networks.mpo.MPOEnvironment.
Instead of adding the conjugate terms explicitly, you can set a flag `explicit_plus_hc` in the tenpy.models.model.MPOCouplingModel parameters, which will ensure two things:

1. The model and the MPO will only store half the terms of each Hermitian conjugate pair added, but the flag `explicit_plus_hc` indicates that they *represent* `self + h.c.`.
   In the example above, only the term :math:`c^{\dagger}_i c_j` would be saved.
2. At runtime during DMRG, the Hermitian conjugate of the (now non-Hermitian) MPO will be computed and applied along with the MPO, so that the effective Hamiltonian is still Hermitian.


    The model flag `explicit_plus_hc` should be used in conjunction with the flag `plus_hc` in tenpy.models.model.CouplingModel.add_coupling or tenpy.models.model.CouplingModel.add_multi_coupling.
    If `plus_hc` is `False` while `explicit_plus_hc` is `True` the MPO bond dimension will not be reduced, but you will still pay the additional computational cost of computing the Hermitian conjugate at runtime.

Thus, we end up with several use cases, depending on your preferences.
Consider the tenpy.models.fermions_spinless.FermionModel.
If you do not care about the MPO bond dimension, and want to add Hermitian conjugate terms manually, you would set `model_par['explicit_plus_hc'] = False` and write::

    self.add_coupling(-J, u1, 'Cd', u2, 'C', dx)
    self.add_coupling(np.conj(-J), u2, 'Cd', u1, 'C', -dx)

If you wanted to save the trouble of the extra line of code (but still did not care about MPO bond dimension), you would keep the `model_par`, but instead write::

    self.add_coupling(-J, u1, 'Cd', u2, 'C', dx, plus_hc=True)

Finally, if you wanted a reduction in MPO bond dimension, you would need to set `model_par['explicit_plus_hc'] = True`, and write::

    self.add_coupling(-J, u1, 'Cd', u2, 'C', dx, plus_hc=True)


Non-uniform terms and couplings
-------------------------------
The CouplingModel-methods tenpy.models.model.CouplingModel.add_onsite, tenpy.models.model.CouplingModel.add_coupling,
and tenpy.models.model.CouplingModel.add_multi_coupling add a sum over a "coupling" term shifted by lattice
vectors. However, some models are not that "uniform" over the whole lattice.

First of all, you might have some local term that gets added only at one specific location in the lattice.
You can add such a term for example with tenpy.models.model.CouplingModel.add_local_term.

Second, if you have irregular lattices, take a look at the corresponding section in :doc:`/intro/lattices`.

Finally, note that the argument `strength` for the `add_onsite`, `add_coupling`, and `add_multi_coupling` methods
can not only be a numpy scalar, but also a (numpy) array.
In general, the sum performed by the methods runs over the given term
shifted by lattice vectors *as far as possible to still fit the term into the lattice*.

For the tenpy.models.model.CouplingModel.add_onsite case this criterion is simple: there is exactly one site in each lattice unit cell with the `u` specified as separate argument, so the correct shape for the `strength` array is simply given by tenpy.models.lattice.Lattice.Ls.
For example, if you want the defacto standard model studied for many-body localization, a Heisenberg chain with random , uniform onsite field :math:`h^z_i \in [-W, W]`,


    H = J \sum_{i=0}^{L-1} \vec{S}_i \cdot \vec{S}_{i+1} - \sum_{i=0}^{L} h^z_i S^z_i

you can use the tenpy.models.spins.SpinChain with the following model parameters::

    L = 30 # or whatever you like...
    W = 5.  # MBL transition at W_c ~= 3.5 J
    model_params = {
        'L': L,
        'Jx': 1., 'Jy': 1., 'Jz': 1.,
        'hz': 2.*W*(np.random.random(L) - 0.5),  # random values in [-W, W], shape (L,)
        'conserve': 'best',
    }
    M = tenpy.models.spins.SpinChain(model_params)

For tenpy.models.model.CouplingModel.add_coupling and tenpy.models.model.CouplingModel.add_multi_coupling,
things become a little bit more complicated, and the correct shape of the `strength` array depends not only on the tenpy.models.lattice.Lattice.Ls
but also on the boundary conditions of the lattice. Given a term, you can call
tenpy.models.lattice.Lattice.coupling_shape and tenpy.models.lattice.Lattice.multi_coupling_shape to find out the correct shape for `strength`.
To avoid any ambiguity, the shape of the `strength` always has to fit, at least after a tiling performed by tenpy.tools.misc.to_array.

For example, consider the Su-Schrieffer-Heeger model, a spin-less tenpy.models.fermions.FermionChain with hopping strength alternating between two values, say `t1` and `t2`.
You can generate this model for example like this::

    L = 30 # or whatever you like...
    t1, t2 = 0.5, 1.5
    t_array = np.array([(t1 if i % 2 == 0 else t2) for i in range(L-1)])
    model_params = {
        'L': L,
        't': t_array,
        'V': 0., 'mu': 0.,  # just free fermions, but you can generalize...
        'conserve': 'best'
    }
    M = tenpy.models.fermions.FermionChain(model_params)


Some random remarks on models
-----------------------------

- Needless to say that we have also various predefined models under tenpy.models.
- If you want to use random parameters, you should use ``model.rng`` as a random number generator and change ``model_params['random_seed']`` for different configurations.
- Of course, an MPO is all you need to initialize a tenpy.models.model.MPOModel to be used for DMRG; you don't have to use the tenpy.models.model.CouplingModel
  or tenpy.models.model.CouplingMPOModel.
  For example, we build the model directly from an MPO in ``examples/mpo_exponentially_decaying.py``.
  The tenpy.models.aklt.AKLTChain is another example which is directly constructed from the `H_bond` terms.
- We suggest writing the model to take a single parameter dictionary for the initialization,
  as the tenpy.models.model.CouplingMPOModel does.
  The tenpy.models.model.CouplingMPOModel converts the dictionary to a dict-like
  tenpy.tools.params.Config with some additional features before passing it on to the `init_lattice`,
  `init_site`, ... methods.
  It is recommended to read out providing default values with ``model_params.get("key", default_value)``,
  see tenpy.tools.params.Config.get.
- When you write a model and want to include a test that it can be at least constructed,
  take a look at ``tests/test_model.py``.

--- DOC: model ---
Models (Introduction)
=====================

This is an introduction to models in TeNPy, intended to guide new-comers towards defining
their own custom models.

We go step by step to introduce the relevant concepts and "derive" how you could have come up
with the following example code to implement an anisotropic Heisenberg model on a square lattice::

    class MyModel(CouplingMPOModel):
        r"""The anisotropic spin-1/2 Heisenberg model in an external field.

        This is a pedagogical example, and you should probably use the SpinModel instead.
        The Hamiltonian is:

            H = J_x \sum_i (S^x_i S^x_{i+1} + S^y_i S^y_{i+1})
                + J_z \sum_i S^z_i S^z_{i+1}
                - h_x \sum_i S^z_i - h_z \sum_i S^z_i
        """

        def init_sites(self, model_params):
            conserve = model_params.get('conserve', 'best')
            if conserve == 'best':
                if model_params.get('hx', 0) == 0:
                    conserve = 'Sz'
                else:
                    conserve = None
            return SpinHalfSite(conserve=conserve)

        def init_terms(self, model_params):
            Jx = model_params.get('Jx', 1.)
            Jz = model_params.get('Jz', 1.)
            hx = model_params.get('hx', 0.)
            hz = model_params.get('hz', 0.)

            for u in range(len(self.lat.unit_cell)):
                self.add_onsite(-hx, u, 'Sx')
                self.add_onsite(-hz, u, 'Sz')

            for u1, u2, dx in self.lat.pairs['nearest_neighbors']:
                self.add_coupling(Jz, u1, 'Sz', u2, 'Sz', dx)
                self.add_coupling(.5 * Jx, u1, 'Sp', u2, 'Sm', dx, plus_hc=True)

    model = MyModel({'lattice': 'Square', 'Lx': 2, 'Ly': 4, 'Jx': 0})


What is a model?
----------------

Abstractly, a **model** stands for some physical (quantum) system, described by a Hamiltonian.
For example, let us consider an anisotropic spin-1/2 Heisenberg model in a field, described by


    H = J_x \sum_i (S^x_i S^x_{i+1} + S^y_i S^y_{i+1}) + J_z \sum_i S^z_i S^z_{i+1} - h_x \sum_i S^x_i - h_z \sum_i S^z_i

The main features that need to be defined for a model are

1. The local Hilbert space. In this example it is a Spin-1/2 degree of freedom with the usual spin operators :math:`S^x, S^y, S^z`.
2. The problem geometry, in terms of lattice type, size and boundary conditions.
3. The Hamiltonian itself. Here, it is naturally expressed as a sum of couplings.

In the following, we guide you towards defining your own custom model, with the above case as an example.
We follow the most direct route, using the tenpy.models.model.CouplingMPOModel framework,
for more flexible alternatives see :doc:`/intro/model_details`.

    This Hamiltonian is already implemented as one of the pre-defined models.
    Here, we implement it from scratch as an example, but if you wanted to simulate this particular
    Hamiltonian in practice, you would use the tenpy.models.spins.SpinModel, which has a
    more general Hamiltonian and contains our example as a special case.


The first step is to identify what the **parameters** of your model are.
In this case, we have the coupling constants :math:`J_x, J_z, h_x, h_z`, and parameters that specify
the lattice geometry (discussed later). In the TeNPy ecosystem, these parameters are
gathered into dictionary-like tenpy.tools.params.Config objects, and for the rest of this
guide you can think of ``model_params`` as a dictionary of these parameters, e.g.
``model_params = {'Jx': 0.5, 'Jz': 1}``.
It is common practice to make all parameters optional, in which case you should think about
(and ideally document) the default values for the parameters.

We start implementing our custom model by defining a class for it::

    class MyModel(CouplingMPOModel):
        r"""The anisotropic spin-1/2 Heisenberg model in an external field.

        This is a pedagogical example, and you should probably use the SpinModel instead.
        The Hamiltonian is:

            H = J_x \sum_i (S^x_i S^x_{i+1} + S^y_i S^y_{i+1})
                + J_z \sum_i S^z_i S^z_{i+1}
                - h_x \sum_i S^z_i - h_z \sum_i S^z_i

        """
        pass  # content will be added later


Note that we define our model as a subclass of tenpy.models.model.CouplingMPOModel.
This means our model inherits all the machinery to build Hamiltonians etc, and we only need
to implement the code that is specific to our model.


The local Hilbert space
-----------------------
The **local Hilbert** space is represented by a tenpy.networks.site.Site (read its doc-string!).
A site defines the meaning of each basis state (i.e. by fixing an order, to define e.g.
that the state are ``spin_down, spin_up``). Additionally, it stores common local operators, such as
:math:`S^z` and makes them accessible by name.

We need to tell our model, what its local Hilbert space is.
This is done by implementing the tenpy.models.model.CouplingMPOModel.init_sites method.
It needs to take the ``model_params`` as input and returns one tenpy.networks.site.Site
instance per site in the unit cell of the lattice (see lattice section below, here this is one site).
The most common sites -- e.g. for spins, spin-less or spin-full fermions, or bosons -- are predefined
in the module tenpy.networks.site, and in this example we can use one of them directly::

    class MyModel(CouplingMPOModel):

        def init_sites(self, model_params):
            # simple version: no charge conservation
            return SpinHalfSite(conserve='None')


If necessary, you can easily extend a pre-defined site by adding further local operators or
completely write your own subclasses of tenpy.networks.site.Site.

If you want to use charge conservation (and you probably should, if possible), we need to specify
what charges are conserved at this point already, i.e. we should give a value to the ``conserve``
argument of the site.


    If you don't know about :doc:`/intro/npc` yet, but want to get started with models right away,
    you can set ``conserve=None`` in the existing sites as above and skip the rest of this
    section. If you need a custom site, you can use
    ``leg = tenpy.linalg.np_conserved.LegCharge.from_trivial(d)`` for an implementation of your
    site, where `d` is the dimension of the local Hilbert space.


In many cases, the possible symmetries we may exploit depend on the
values of the parameters, which is why they are an input to ``init_sites``.
In our example, we can conserve the total :math:`S^z` if :math:`h_x = 0`::

    class MyModel(CouplingMPOModel):

        def init_sites(self, model_params):
            conserve = model_params.get('conserve', 'best')
            if conserve == 'best':
                if model_params.get('hx', 0) == 0:
                    conserve = 'Sz'
                else:
                    conserve = None
            return SpinHalfSite(conserve=conserve)


Note that we added ``conserve`` as a model parameter, such that we can later turn charge
conservation on or off. The possible values for ``conserve`` are documented in the site class,
here tenpy.networks.site.SpinHalfSite, and it is common to support ``'best'``
as a value for the ``conserve`` model parameter and translate it to the largest possible symmetry,
given the values of the coupling strengths.


    The tenpy.linalg.charges.LegCharge of all involved sites need to have a common
    tenpy.linalg.charges.ChargeInfo in order to allow the contraction of tensors
    acting on the various sites.
    This can be ensured with the function tenpy.networks.site.set_common_charges.

    An example where tenpy.networks.site.set_common_charges is needed would be a coupling
    of different types of sites, e.g., when a tight binding chain of fermions is coupled to some
    local spin degrees of freedom. Another use case of this function would be a model with a U(1)
    symmetry involving only half the sites, say :math:`\sum_{i=0}^{L/2} n_{2i}`.


The geometry (lattice)
----------------------
The geometry is usually given by some kind of **lattice** structure that determines how the sites
are arranged spatially. This implicitly defines e.g. the meaning of a sum over nearest neighbors
:math:`\sum_{<i, j>}`.
In TeNPy, this is specified by a tenpy.models.lattice.Lattice class, which contains a unit cell of
a few tenpy.networks.site.Site\s which are repeated periodically according to the lattice
basis vectors, to form a regular lattice.
Again, we have pre-defined some basic lattices like a tenpy.models.lattice.Chain,
two chains coupled as a tenpy.models.lattice.Ladder or 2D lattices like the
tenpy.models.lattice.Square, tenpy.models.lattice.Honeycomb and
tenpy.models.lattice.Kagome lattices; but you are also free to define your own generalizations.
See :doc:`/intro/lattices`.


By default, the tenpy.models.model.CouplingMPOModel puts your model on
a tenpy.models.lattice.Chain, and looks for its length as ``model_params['L']``.
If you want to use a different pre-defined lattice, you can put it into the parameters, e.g.
as ``model_params['lattice'] = 'Square'``, and the size is taken from ``model_params['Lx']``
and ``model_params['Ly']``, while the boundary conditions are ``model_params['bc_x']``
and ``model_params['bc_y']``.
Of course, simply changing the lattice only makes sense if the Hamiltonian is defined in a lattice
independent language, e.g. in terms of "nearest neighbor pairs".
As we will explore in the next section, this is in fact the natural way to define Hamiltonians in TeNPy.

It is also common to have specialized classes for special lattices::

    class MyModelKagome(MyModel):
        default_lattice = Kagome
        force_default_lattice = True

        def init_sites(self, model_params):
            # note: Kagome has three sites per unit-cell
            site = MyModel.init_site(model_params)
            return (site, site, site)


Setting ``default_lattice = Kagome`` means that the lattice defaults to Kagome, if ``'lattice' not in model_params``,
while setting ``force_default_lattice = True`` means that this model does not allow any other
lattice. Thus, ``MyModelKagome`` does what its name promises to do.

For custom lattices, or more complicated code, you can overwrite the
tenpy.models.model.CouplingMPOModel.init_lattice method, similar to how we did
for ``init_sites`` above.


The Hamiltonian
---------------
The last ingredient we need to implement for a custom model is its Hamiltonian.
To that end, we override the tenpy.models.model.CouplingMPOModel.init_terms method.
At this point during model initialization, the lattice is already initialized, and we
may access ``self.lat`` and use e.g. the tenpy.models.lattice.Lattice.pairs attribute
for convenient definition of couplings between e.g. nearest-neighbor pairs.

There are a bunch of convenience methods implemented in tenpy.models.model.CouplingModel,
which make this easy. Let us summarize them here:

- tenpy.models.model.CouplingModel.add_onsite for a sum of onsite terms :math:`\sum_i h_i \hat{A}_i`.
- tenpy.models.model.CouplingModel.add_coupling for a sum of two-body couplings :math:`\sum_i J_i \hat{A}_i \hat{B}_{i+n}`.
- tenpy.models.model.CouplingModel.add_multi_coupling for a sum of multi-body couplings :math:`\sum_i J_i \hat{A}_i \hat{B}_{i+n} ... \hat{F}_{i+m}`.

    A single call to each of these methods adds an extensive number of terms to your Hamiltonian,
    as it includes a sum over all sites in the definition.
    This means that a Hamiltonian like :math:`H = -3 \sum_i S_i^z` is realized as a **single** call to
    tenpy.models.model.CouplingModel.add_onsite, **without**  an explicit loop over `i`.

    These methods allow the prefactors to be site-dependent; you can either give a single number
    as the prefactor, or a list/array that is tiled to fit the size.
    E.g. if an onsite term with ``strength=1`` gives you a uniform magnetic field,
    ``strength=[1, -1]`` gives you the corresponding staggered field,
    assuming a chain of even length.

- tenpy.models.model.CouplingModel.add_local_term for a single term :math:`\hat{A}_i` or :math:`\hat{A}_i \hat{B}_{j}`
  or :math:`\hat{A}_i \hat{B}_{j} ... \hat{F}_k`.

    You probably should not directly use tenpy.models.model.CouplingModel.add_onsite_term,
    tenpy.models.model.CouplingModel.add_coupling_term and
    tenpy.models.model.CouplingModel.add_multi_coupling_term.
    They do not handle Jordan-Wigner strings and they need MPS indices as inputs, not
    lattice positions.

See also tenpy.models.model.CouplingModel.add_exponentially_decaying_coupling

    Instead of a single operator name like ``'Sx'``, you can put multiple operator names
    separated by whitespace to represent the product of these operators.
    For example, ``self.add_onsite(-2.j * (-hz), u, 'Sx Sy')`` is equivalent to (but worse than)
    to ``self.add_onsite(-hz, u, 'Sz')``.

For our example, we define the Hamiltonian by implementing::

    class MyModel(CouplingMPOModel):

        def init_sites(self, model_params):
            ...

        def init_terms(self, model_params):
            Jx = model_params.get('Jx', 1.)
            Jz = model_params.get('Jz', 1.)
            hx = model_params.get('hx', 0.)
            hz = model_params.get('hz', 0.)

            for u in range(len(self.lat.unit_cell)):
                self.add_onsite(-hx, u, 'Sx')
                self.add_onsite(-hz, u, 'Sz')

            for u1, u2, dx in self.lat.pairs['nearest_neighbors']:
                self.add_coupling(Jz, u1, 'Sz', u2, 'Sz', dx)

                # Sx and Sy violate Sz conservation.
                # need to define them using Sp = Sx + i Sy, Sm = Sx - i Sy
                # Sx.Sx + Sy.Sy = .5 * (Sp.Sm + Sm.Sp) = .5 * (Sp.Sm + hc)
                self.add_coupling(.5 * Jx, u1, 'Sp', u2, 'Sm', dx, plus_hc=True)

    If we did not care about charge conservation, we could have also done
    ``add_coupling(Jx, u1, 'Sx', u2, 'Sx', dx)`` and
    ``add_coupling(Jx, u1, 'Sy', u2, 'Sy', dx)``.
    This only works if we set ``conserve='None'`` or ``conserve='parity'``,
    as otherwise the site does not even define ``'Sx'``.

    Also, note that that the on-site operators ``Sp=``:math:`S^+_i` and ``Sm=``:math:`S^-_i`
    do not conserve the total :math:`S^z`, but you can still use them to define the combined
    coupling :math:`S^+_i S^-_j` that *does* conserve :math:`S^z`.


At this point we are done defining our model, and have reproduced the result at the very top
of the chapter. We should, however, make sure that we defined the model correctly.


Verifying models
----------------
Especially when you define custom models, we strongly recommend you triple-check if you correctly
implemented the model you are interested in (i.e. have the correct couplings between correct sites).
This is a crucial step to make sure you are in fact simulating the model that you are thinking
about and not some random other model with entirely different physics.

    If the model contains Fermions, you should read the introduction to :doc:`/intro/JordanWigner`.


To verify that you have added the correct terms, initialize the model on a small lattice (we also
set :math:`J_x=0` here for readability, but you should turn it on to verify the full model),
e.g.::

    model = MyModel({'lattice': 'Square', 'Lx': 2, 'Ly': 3, 'Jx': 0, 'hz': 0.2})


Now, print all couplings and onsite terms in the model to console::

    print(model.all_coupling_terms().to_TermList() + model.all_onsite_terms().to_TermList())


Which gives you the following output for our example::

    1.00000 * Sz_0 Sz_1 +
    1.00000 * Sz_0 Sz_2 +
    1.00000 * Sz_0 Sz_3 +
    1.00000 * Sz_1 Sz_2 +
    1.00000 * Sz_1 Sz_4 +
    1.00000 * Sz_2 Sz_5 +
    1.00000 * Sz_3 Sz_4 +
    1.00000 * Sz_3 Sz_5 +
    1.00000 * Sz_4 Sz_5 +
    -0.20000 * Sz_0 +
    -0.20000 * Sz_1 +
    -0.20000 * Sz_2 +
    -0.20000 * Sz_3 +
    -0.20000 * Sz_4 +
    -0.20000 * Sz_5


You may be surprised to see nine different two-body couplings on this ``2 x 3`` square patch.
Let us look at the couplings in detail to figure out why this might be.
We need to understand the meaning of the site indices, i.e. where does ``Sz_4`` live spatially?
The convention for site indices comes from the MPS geometry and may be hard to read.
To visualize the site order of the lattice, you may run the following snippet::

    import matplotlib.pyplot as plt
    plt.figure(figsize=(5, 6))
    ax = plt.gca()
    model.lat.plot_coupling(ax)
    model.lat.plot_sites(ax)
    model.lat.plot_order(ax)
    plt.show()



    from tenpy import SpinHalfSite
    from tenpy.models import CouplingMPOModel
    import matplotlib.pyplot as plt

    class MyModel(CouplingMPOModel):
        def init_sites(self, model_params):
            return SpinHalfSite()

        def init_terms(self, model_params):
            # note: terms dont matter for this plot, so we simplify here
            self.add_onsite(1., 0, 'Sz')

    model = MyModel({'lattice': 'Square', 'Lx': 2, 'Ly': 3})
    plt.figure(figsize=(5, 6))
    ax = plt.gca()
    model.lat.plot_coupling(ax)
    model.lat.plot_sites(ax)
    model.lat.plot_order(ax)
    plt.show()


We see the lattice plotted in black. Concretely, we get a black line for each pair of nearest-neighbor
sites. The red line goes through the sites in order, and we see the site indices labelled.

In particular, we can now understand why we get nine different couplings; we see from the plot
that the lattice has open boundaries in x-direction but periodic boundaries in y-direction.
Try playing around with different boundary conditions, e.g.
``MyModel({'lattice': 'Square', 'Lx': 2, 'Ly': 3, 'Jx': 0, 'bc_y': 'open'})``
or
``MyModel({'lattice': 'Square', 'Lx': 2, 'Ly': 3, 'Jx': 0, 'bc_x': 'periodic'})``.
See :doc:`/intro/lattices` regarding boundary conditions.

You can also use tenpy.algorithms.exact_diag.get_numpy_Hamiltonian to see if the Hamiltonian
is what you expect it to be.
You will need to choose a relatively small system for the full Hamiltonian to fit into RAM.
This is strongly recommended if you defined your own operators, as e.g. the
tenpy.models.pxp.PXPChain does.


Contribute your model?
----------------------
If you have implemented a model, and you think it may be useful to the broader community, consider
contributing it to TeNPy via a pull request.
We have :doc:`/contr/guidelines`, and you can have a look at the implementation
of e.g. the tenpy.models.spins.SpinModel as a guide, but do not let formalities
stop you from sharing your code, we can always address any nitpicks ourselves.


Further Reading
---------------
- Details and ideas behind the implementation: :doc:`/intro/model_details`
- Look at the implementation of the pre-defined models in tenpy.models.
  Most are based on the tenpy.models.model.CouplingMPOModel as discussed here.
- The tenpy.models.aklt.AKLTChain is a notable counter-example where it is actually
  easier to define ``H_bond`` than to write down couplings.
- If the Hamiltonian is already given in MPO form (e.g. because it comes from some other software),
  it can be used to directly build a model, as is done in ``examples/mpo_exponentially_decaying.py``.