

--- DOC: lattices ---
Details on the lattice geometry
===============================

The tenpy.models.lattice.Lattice class defines the geometry of the system.
In the basic form, it represents a unit cell of a few sites repeated in one or multiple directions.
Moreover, it maps this higher-dimensional geometry to a one-dimensional chain for MPS-based algorithms.

Visualization
-------------

A plot of the lattice can greatly help to understand which sites are connected by what couplings.
The methods ``plot_*`` of the tenpy.models.lattice.Lattice can do a good job for a quick illustration.
Let's look at the Honeycomb lattice as an example.

    :include-source:

    import matplotlib.pyplot as plt
    from tenpy.models import lattice

    plt.figure(figsize=(5, 6))
    ax = plt.gca()
    lat = lattice.Honeycomb(Lx=4, Ly=4, sites=None, bc='periodic')
    lat.plot_coupling(ax)
    lat.plot_order(ax, linestyle=':')
    lat.plot_sites(ax)
    lat.plot_basis(ax, origin=-0.5*(lat.basis[0] + lat.basis[1]))
    ax.set_aspect('equal')
    ax.set_xlim(-1)
    ax.set_ylim(-1)
    plt.show()

In this case, the unit cell (shaded green) consists of two sites, which for the purpose of plotting we just set to ``sites=None``;
in general you should specify instances of tenpy.networks.site.Site for that.
The unit cell gets repeated in the directions given by the lattice basis (green arrows at the unit cell boundary).
Hence, we can label each site by a **lattice index** ``(x, y, u)`` in this case, where ``x in range(Lx), y in range(Ly)`` specify the translation of the unit cell
and ``u in range(len(unit_cell))``, here ``u in [0, 1]``, specifies the index within the unit cell.

How an MPS winds through the lattice: the `order`
-------------------------------------------------

For MPS-based algorithms, we need to map a 2D lattice like the one above to a 1D chain.
The red, dashed line in the plot indicates how an MPS winds through the 2D
lattice. The **MPS index** `i` is a simple enumeration of the sites along this line, shown as numbers next to the sites
in the plot.
The methods tenpy.models.lattice.Lattice.mps2lat_idx and tenpy.models.lattice.Lattice.lat2mps_idx map
indices of the MPS to and from indices of the lattice.

The tenpy.networks.mps.MPS class itself is (mostly) agnostic of the underlying geometry.
For example, tenpy.networks.mps.MPS.expectation_value will return a 1D array of the expectation value on each
site indexed by the MPS index `i`.
If you have a two-dimensional lattice, you can use tenpy.models.lattice.Lattice.mps2lat_values to map this result to a 2D array index by the lattice indices.

A suitable order is critical for the efficiency of MPS-based algorithms.
On one hand, different orderings can lead to different MPO bond-dimensions, with direct impact on the complexity scaling.
On the other hand, it influences how much entanglement needs to go through each bonds of the underlying MPS,
e.g., the ground state to be found in DMRG, and therefore influences the required MPS bond dimensions.
For the latter reason, the "optimal" ordering can not be known a priori and might even depend on your coupling
parameters (and the phase you are in).
In the end, you can just try different orderings and see which one works best.

The simplest way to *change* the order is to use a non-default value for the initialization parameter `order` of the
tenpy.models.lattice.Lattice class. This gets passed on to tenpy.models.lattice.Lattice.ordering,
which you can override by creating a custom lattice class to define new possible orderings.
Alternatively, you can go the most general way and simply set the attribute `order` to be a 2D numpy array with
lattice indices as rows, in the order you want.

    :include-source:

    import matplotlib.pyplot as plt
    from tenpy.models import lattice

    Lx, Ly = 3, 3
    fig, axes = plt.subplots(2, 2, figsize=(7, 8))

    lat1 = lattice.Honeycomb(Lx, Ly, sites=None, bc='periodic')  # default order
    lat2 = lattice.Honeycomb(Lx, Ly, sites=None, bc='periodic',
                            order="Cstyle")  # first method to change order
    # alternative: directly set "Cstyle" order
    lat3 = lattice.Honeycomb(Lx, Ly, sites=None, bc='periodic')
    lat3.order = lat2.ordering("Cstyle")  # now equivalent to lat2

    # general: can apply arbitrary permutation to the order
    lat4 = lattice.Honeycomb(Lx, Ly, sites=None, bc='periodic',
                            order="Cstyle")
    old_order = lat4.order
    permutation = []
    for i in range(0, len(old_order), 2):
        permutation.append(i+1)
        permutation.append(i)
    lat4.order = old_order[permutation, :]

    for lat, label, ax in zip([lat1, lat2, lat3, lat4],
                              ["order='default'",
                               "order='Cstyle'",
                               "order='Cstyle'",
                               "custom permutation"],
                              axes.flatten()):
        lat.plot_coupling(ax)
        lat.plot_sites(ax)
        lat.plot_order(ax, linestyle=':', linewidth=2.)
        ax.set_aspect('equal')
        ax.set_title('order = ' + repr(label))

    plt.show()


Boundary conditions
-------------------

The tenpy.models.lattice.Lattice defines the **boundary conditions** `bc` in each direction.
It can be one of the usual ``'open'`` or ``'periodic'`` in each direction and will be used by the
tenpy.models.model.CouplingModel to determine whether there should be added periodic couplings in the
corresponding directions.

On top of that, there is the `bc_MPS` boundary condition of the MPS, one of ``'finite', 'segment', 'infinite'``.
For an ``'infinite'`` MPS, the whole lattice is repeated in the direction of the *first* basis vector of the lattice.
For ``bc_MPS='infinite'``, the first direction should always be ``'periodic'``, but you *can* also define a lattice with
``bc_MPS='finite', bc=['periodic', 'periodic']`` for a finite system on the torus.
This is discouraged, though, because the ground state MPS will require the *squared* bond dimension for the *same precision* in this
case!

For two (or higher) dimensional lattices, e.g for DMRG on an infinite cylinder,
you can also specify an integer `shift` instead of just saying ``'periodic'``.
Rolling the 2D lattice up into a cylinder, you have a degree of freedom about which sites to connect.
This is illustrated in the figure below for a tenpy.models.lattice.Square lattice with ``bc=['periodic', shift]``
for ``shift in [-1, 0, 1]`` (different columns).
In the first row, the orange markers indicate a pair of identified sites (see tenpy.models.lattice.Lattice.plot_bc_shift).
The dashed orange line indicates the direction of the cylinder axis.
The line where the cylinder is "cut open" therefore winds around the the cylinder for a non-zero `shift`.
(A similar thing happens even for shift=0 for more complicated lattices with non-orthogonal basis.)
In the second row, we directly draw lines between all sites connected by nearest-neighbor couplings, as they appear in the MPO.


    import matplotlib.pyplot as plt
    from tenpy.models import lattice

    Lx, Ly = 4, 3
    fig, axes = plt.subplots(2, 3, sharex=True, sharey=True, figsize=(7, 4))

    for i, shift in enumerate([1, 0, -1]):
        ax1, ax2 = axes[:, i]
        lat = lattice.Square(Lx, Ly, None, bc=['periodic', shift], bc_MPS='infinite')
        for ax in ax1, ax2:
            lat.plot_sites(ax)
            ax.set_aspect('equal')
            ax.set_ylim(-1, 4)
        lat.plot_coupling(ax1)
        lat.plot_bc_identified(ax1, cylinder_axis=True)
        lat.plot_coupling(ax2, wrap=True)
        ax1.set_title('shift = ' + str(shift))
        ax.set_xlim(-1.5)

    plt.show()


Irregular Lattices
------------------
The tenpy.models.lattice.IrregularLattice allows you to add or remove sites from/to an existing regular lattice.
The doc-string of tenpy.models.lattice.IrregularLattice contains several examples. Let us consider another one
here, where we use the IrregularLattice to "fix" the boundary of the Honeycomb lattice.
When we use ``"open"`` boundary conditions for a finite system, there are two sites (shown on the lower left, and upper right corners of the figure below),
which are not included into any hexagonal. The following example shows how to remove them from the system:

    :include-source:

    import matplotlib.pyplot as plt
    from tenpy.models import lattice

    Lx, Ly = 3, 3
    fig, axes = plt.subplots(1, 2, sharex=True, sharey=True, figsize=(6, 4))

    reg_lat = lattice.Honeycomb(Lx=Lx, Ly=Ly, sites=None, bc='open')
    irr_lat = lattice.IrregularLattice(reg_lat, remove=[[0, 0, 0], [-1, -1, 1]])
    for lat, label, ax in zip([reg_lat, irr_lat],
                              ["regular", "irregular"],
                              axes.flatten()):
        lat.plot_coupling(ax)
        lat.plot_order(ax, linestyle=':')
        lat.plot_sites(ax)
        ax.set_aspect('equal')
        ax.set_title(label)

    plt.show()

--- DOC: input_output ---
Saving to disk: input/output
============================

.. This file is maintained in the repository https://github.com/tenpy/hdf5_io.git
.. It can be read online at https://tenpy.readthedocs.io/en/latest/intro/input_output.html

Using pickle
------------

A simple and pythonic way to store data of TeNPy arrays is to use pickle from the Python standard library.
Pickle allows you to store (almost) arbitrary python objects,
and the tenpy.linalg.np_conserved.Array is no exception (and neither are other TeNPy classes).

Say that you have run DMRG to get a ground state `psi` as an tenpy.networks.mps.MPS.
With pickle, you can save it to disk as follows::

    import pickle
    with open('my_psi_file.pkl', 'wb') as f:
        pickle.dump(psi, f)

Here, the ``with ... :`` structure ensures that the file gets closed after the pickle dump, and the ``'wb'`` indicates
the file opening mode is set to "write binary".
Reading the data from disk is as easy as (``'rb'`` for reading binary)::

    with open('my_psi_file.pkl', 'rb') as f:
        psi = pickle.load(f)

    It is a good (scientific) practice to include meta-data to the file, like the parameters you used to generate that state.
    Instead of just the `psi`, you can simply store a dictionary containing `psi` and other data, e.g.,
    ``data = {'psi': psi, 'dmrg_params': dmrg_params, 'model_params': model_params}``.
    This can *save you a lot of pain*, when you come back to look at the files a few month later and forgot what you've done to generate them!

In some cases, compression can significantly reduce the space needed to save the data.
This can for example be done with gzip (as well in the Python standard library).
However, be warned that it might cause longer loading and saving times, i.e. it comes at the penalty of more CPU usage for the input/output.
In Python, this requires only small adjustments::

    import pickle
    import gzip

    # to save:
    with gzip.open('my_data_file.pkl', 'wb') as f:
        pickle.dump(data, f)
    # and to load:
    with gzip.open('my_data_file.pkl', 'rb') as f:
        data = pickle.load(data, f)


Using HDF5 with h5py
--------------------

While pickle is great for simple input/output of python objects, it also has disadvantages. The probably most
dramatic one is the limited portability: saving data on one PC and loading it on another one might fail!
Even exporting data from Python 2 to load them in Python 3 on the same machine can give quite some troubles.
Moreover, pickle requires to load the whole file at once, which might be unnecessary if you only need part of the data,
or even lead to memory problems if you have more data on disk than fits into RAM.

Hence, we support saving to `HDF5 <https://portal.hdfgroup.org/display/HDF5/HDF5>`_ files as an alternative.
The `h5py <https://docs.h5py.org>`_ package provides a dictionary-like interface for the file/group objects with
numpy-like data sets, and is quite easy to use.
If you don't know about HDF5, read the :ref:`quickstart <h5py:quick>` of the `h5py`_ documentation (and this guide).

The implementation can be found in the tenpy.tools.hdf5_io module with the
tenpy.tools.hdf5_io.Hdf5Saver and tenpy.tools.hdf5_io.Hdf5Loader classes
and the wrapper functions tenpy.tools.hdf5_io.save_to_hdf5, tenpy.tools.hdf5_io.load_from_hdf5.

The usage is very similar to pickle::

    import h5py
    from tenpy.tools import hdf5_io

    data = {"psi": psi,  # e.g. an MPS
            "model": my_model,
            "parameters": {"L": 6, "g": 1.3}}

    with h5py.File("file.h5", 'w') as f:
        hdf5_io.save_to_hdf5(f, data)
    # ...
    with h5py.File("file.h5", 'r') as f:
        data = hdf5_io.load_from_hdf5(f)
        # or for partial reading:
        pars = hdf5_io.load_from_hdf5(f, "/parameters")

    Like loading a pickle file, loading data from a manipulated HDF5 file with the functions
    described has the potential to cause arbitrary code execution.
    Only load data from trusted sources!


    The `hickle <https://github.com/telegraphic/hickle>`_ package imitates the pickle functionality
    while saving the data to HDF5 files.
    However, since it aims to be close to pickle, it results in a more complicated data structure than we want here.

    To use the export/import features to HDF5, you need to install the `h5py`_ python package
    (and hence some version of the HDF5 library).


Data format specification for saving to HDF5
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This section motivates and defines the format how we save data of TeNPy-defined classes.
The goal is to have the tenpy.tools.hdf5_io.save_to_hdf5 function for saving sufficiently simple enough python
objects (supported by the format) to disk in an HDF5 file, such that they can be reconstructed with the
tenpy.tools.hdf5_io.load_from_hdf5 function, as outlined in the example code above.

Guidelines of the format:

0. Store enough data such that tenpy.tools.hdf5_io.load_from_hdf5 can reconstruct a copy of the object
   (provided that the save did not fail with an error).
1. Objects of a type supported by the HDF5 datasets (with the `h5py`_ interface) should be directly stored as h5py Dataset.
   Such objects are for example numpy arrays (of non-object `dtype`), scalars and strings.
2. Allow to save (nested) python lists, tuples and dictionaries with values (and keys) which can be saved.
3. Allow user-defined classes to implement a well-defined interface which allows to save instances of that class, hence extending what data can be saved.
   An instance of a class supporting the interface gets saved as an HDF5 Group.
   Class attributes are stored as entries of the group, metadata like the type should be stored in HDF5 attributes, see :ref:`attributes <h5py:attributes>`.
4. Simple and intuitive, human-readable structure for the HDF5 paths.
   For example, saving a simple dictionary ``{'a': np.arange(10), 'b': 123.45}`` should result in an
   HDF5 file with just the two data sets ``/a`` and ``/b``.
5. Allow loading only a subset of the data by specifying the `path` of the HDF5 group to be loaded.
   For the above example, specifying the path ``/b`` should result in loading the float ``123.45``, not the array.
6. Avoid unnecessary copies if the same python object is referenced by different names, e.g,
   for the data ``{'c': large_obj, 'd': large_obj}`` with to references to the same `large_obj`, save it only once and use HDF5 hard-links
   such that ``/c`` and ``/d`` are the same HDF5 dataset/group.
   Also avoid the copies during the loading, i.e., the loaded dictionary should again have two references to a single object `large_obj`.
   This is also necessary to allow saving and loading of objects with cyclic references.


The full format specification is given by the what the code in tenpy.tools.hdf5_io does...
Since this is not trivial to understand, let me summarize it here:

- Following 1), simple scalars, strings and numpy arrays are saved as Dataset.
  Other objects are saved as a HDF5 Group, with the actual data being saved as group members (as sub-groups and
  sub-datasets) or as attributes (for metadata or simple data).
- The type of the object is stored in the HDF5 attribute ``'type'``, which is one of the global ``REPR_*`` variables in
  tenpy.tools.hdf5_io. The type determines the format for saving/loading of builtin types (list, ...)
- Userdefined classes which should be possible to export/import need to implement the methods ``save_hdf5`` and ``from_hdf5``
  as specified in tenpy.tools.hdf5_io.Hdf5Exportable.
  When saving such a class, the attribute ``'type'`` is automatically set to ``'instance'``, and the class name and
  module are saved under the attributes ``'module'`` and ``'class'``. During loading, this information is used to
  automatically import the module, get the class and call the classmethod ``from_hdf5`` for reconstruction.
  This can only work if the class definition already exists, i.e., you can only save class instances, not classes itself.
- For most (python) classes, simply subclassing tenpy.tools.hdf5_io.Hdf5Exportable should work to make the class exportable.
  The latter saves the contents of object.__dict__, with the extra attribute ``'format'`` specifying
  whether the dictionary is "simple" (see below.).
- The ``None`` object is saved as a group with the attribute ``'type'`` being ``'None'`` and no subgroups.
- For iterables (list, tuple and set), we simple enumerate the entries and save entries as group members under the
  names ``'0', '1', '2', ...``, and a maximum ``'len'`` attribute.
- The format for dictionaries depends on whether all keys are "simple", which we define as being strings which are valid
  path names in HDF5, see tenpy.tools.hdf5_io.valid_hdf5_path_component.
  Following 4), the keys of a simple dictionary are directly used as names for group members,
  and the values being whatever object the group member represents.
- Partial loading along 5) is possible by directly specifying the subgroup or the path to tenpy.tools.hdf5_io.load_from_hdf5.
- Guideline 6) is ensured as much as possible. However, there is a bug/exception:
  tuples with cyclic references are not re-constructed correctly; the inner objects will be lists instead of tuples
  (but with the same object entries).

Finally, we have to mention that many TeNPy classes are tenpy.tools.hdf5_io.Hdf5Exportable.
In particular, the tenpy.linalg.np_conserved.Array supports this.
To see what the exact format for those classes is, look at the `save_hdf5` and `from_hdf5` methods of those classes.

    There can be multiple possible output formats for the same object.
    The dictionary -- with the format for simple keys or general keys -- is such an example,
    but userdefined classes can use the same technique in their `from_hdf5` method.
    The user might also explicitly choose a "lossy" output format (e.g. "flat" for np_conserved Arrays and LegCharges).

    The above format specification is quite general and not bound to TeNPy. Feel free to use it in your own projects ;-)
    To separate the development, versions and issues of the format clearly from TeNPy, we maintain the code for it in a separate git repository,
    https://github.com/tenpy/hdf5_io